{"version":3,"sources":["webpack:///vendors.js","webpack:///webpack/bootstrap e60d7c0b1027f6960c45","webpack:///./core/client/modules/base/core.base.module.js","webpack:///./core/client/components/core.common.module.js","webpack:///external \"angular\"","webpack:///./core/client/components/svg-image/core.common.svg-image.js","webpack:///./core/client/components/static-loader/core.common.static-loader.js","webpack:///./core/client/components/err-src/core.common.err-src.js","webpack:///./~/angular-ui-router/release/angular-ui-router.js","webpack:///./~/angular-translate/dist/angular-translate.js","webpack:///./~/angular-cookies/index.js","webpack:///./~/angular-cookies/angular-cookies.js","webpack:///./~/angular-resource/index.js","webpack:///./~/angular-resource/angular-resource.js"],"names":["modules","__webpack_require__","moduleId","installedModules","exports","module","id","loaded","call","parentJsonpFunction","window","chunkIds","moreModules","chunkId","i","callbacks","length","installedChunks","push","apply","shift","2","e","callback","undefined","head","document","getElementsByTagName","script","createElement","type","charset","async","src","p","0","1","appendChild","m","c","_interopRequireDefault","obj","__esModule","default","Object","defineProperty","value","_coreCommon","_coreCommon2","_angularUiRouter","_angularUiRouter2","_angularTranslate","_angularTranslate2","_angularCookies","_angularCookies2","_angularResource","_angularResource2","angular","name","_angular","_angular2","_coreCommon3","_coreCommon4","_coreCommon5","_coreCommon6","directive","provider","svgImage","$http","restrict","link","scope","element","imgURL","attr","request","get","Content-Type","manipulateImgNode","data","elem","$svg","imgClass","classes","split","classList","add","removeAttribute","success","replaceWith","$inject","_classCallCheck","instance","Constructor","TypeError","_createClass","defineProperties","target","props","descriptor","enumerable","configurable","writable","key","protoProps","staticProps","prototype","StaticLoader","this","rootPath","cacheMap","path","factory","self","then","res","status","errSrc","attrs","bind","isHide","css","$set","inherit","parent","extra","extend","merge","dst","forEach","arguments","hasOwnProperty","ancestors","first","second","n","objectKeys","object","keys","result","val","indexOf","array","Array","Number","len","from","Math","ceil","floor","inheritParams","currentParams","newParams","$current","$to","parentParams","parents","inherited","inheritList","params","j","equalForKeys","a","b","k","filterByKeys","values","filtered","pick","copy","concat","slice","omit","filter","collection","isArray","map","$Resolve","$q","$injector","VISIT_IN_PROGRESS","VISIT_DONE","NOTHING","NO_DEPENDENCIES","NO_LOCALS","NO_PARENT","when","$$promises","$$values","study","invocables","visit","visited","cycle","splice","Error","join","isString","plan","annotate","param","pop","isResolve","isObject","invocableKeys","locals","done","wait","merged","$$inheritedValues","resolution","resolve","fail","reason","$$failure","reject","invoke","invocable","onfailure","invocation","proceed","isDefined","promise","defer","waitParams","dep","promises","ii","$TemplateFactory","$templateCache","fromConfig","config","template","fromString","templateUrl","fromUrl","templateProvider","fromProvider","isFunction","url","cache","headers","Accept","response","UrlMatcher","pattern","parentMatcher","addParameter","location","paramNames","test","$$UMFP","Param","quoteRegExp","string","squash","optional","surroundPattern","replace","matchDetails","isSearch","regexp","segment","cfg","substring","last","index","RegExp","caseInsensitive","placeholder","searchPlaceholder","compiled","segments","$$new","ParamSet","source","exec","isOptional","lastIndex","search","sourceSearch","sourcePath","strict","prefix","$$paramNames","Type","$UrlMatcherFactory","valToString","toString","valFromString","getDefaultConfig","isStrictMode","isCaseInsensitive","isInjectable","flushTypeQueue","typeQueue","$types","injector","def","defaultSquashPolicy","enqueue","defaultTypes","encode","decode","is","int","parseInt","bool","date","getFullYear","getMonth","getDate","match","capture","Date","isNaN","valueOf","equals","toISOString","json","toJson","fromJson","any","identity","$$getDefaultValue","strictMode","compile","isMatcher","o","definition","definitionFn","$get","unwrapShorthand","isShorthand","$$fn","getType","urlType","getArrayMode","arrayDefaults","arrayParamNomenclature","getSquashPolicy","getReplace","arrayMode","configuredKeys","defaultPolicy","to","item","defaultValue","$value","hasReplaceVal","$replace","replacement","$normalize","$asArray","dynamic","$$parent","$$keys","chain","ignore","reverse","paramset","paramValues","$$equals","paramValues1","paramValues2","equal","left","right","$$validates","rawVal","normalized","encoded","$UrlRouterProvider","$locationProvider","$urlMatcherFactory","regExpPrefix","re","interpolate","what","handleIfMatch","handler","$match","$location","$rootScope","$browser","$sniffer","appendBasePath","isHtml5","absolute","baseHref","update","evt","check","rule","handled","defaultPrevented","lastPushedUrl","rules","otherwise","listen","listener","$on","interceptDeferred","sync","read","urlMatcher","options","format","$$avoidResync","href","validates","html5Mode","enabled","history","hashPrefix","slash","port","protocol","host","redirect","handlerIsString","strategies","matcher","regex","global","sticky","deferIntercept","$StateProvider","$urlRouterProvider","isRelative","stateName","findState","stateOrName","base","isStr","rel","pathLength","current","state","states","queueState","parentName","queue","flushQueuedChildren","queued","registerState","lastIndexOf","stateBuilder","$delegates","abstractKey","$stateParams","$state","navigable","transitionTo","isGlob","text","doesStateMatchGlob","glob","globSegments","l","unshift","MAX_VALUE","decorator","func","$view","$resolve","$urlRouter","handleRedirect","$broadcast","TransitionAborted","retry","$retry","TransitionFailed","retryTransition","transition","TransitionSuperseded","toParams","resolveState","paramsAreFiltered","resolveViews","viewsPromises","views","view","injectables","$template","load","globals","notify","controllerProvider","injectLocals","$$controller","controller","$$state","$$controllerAs","controllerAs","$$resolveAs","resolveAs","all","TransitionPrevented","root","reload","go","relative","fromParams","fromPath","toState","hash","redirectResult","toPath","keep","toLocals","reloadState","ownParams","shouldSkipReload","resolved","entering","exiting","onExit","onEnter","error","includes","lossy","nav","context","nonSearchParamsEqual","fromAndToState","notSearchParam","nonQueryParamKeys","nonQueryParams","nonQueryParamSet","reloadOnSearch","compositeName","charAt","","abstract","$ViewProvider","$templateFactory","defaults","$ViewScrollProvider","useAnchorScroll","$anchorScroll","$timeout","$element","scrollIntoView","$ViewDirective","$uiViewScroll","$interpolate","getService","service","has","getRenderer","statics","enter","cb","after","leave","remove","$animate","version","minor","$animator","animate","terminal","priority","transclude","tElement","tAttrs","$transclude","cleanupLastView","previousEl","currentScope","$destroy","currentEl","$uiViewData","renderer","$$animLeave","updateView","firstTime","newScope","getUiViewName","previousLocals","latestLocals","$new","$emit","clone","animEnter","animLeave","viewAnimData","$animEnter","$animLeave","autoScrollExp","$eval","onloadExp","onload","autoscroll","inheritedData","$ViewDirectiveFill","$compile","$controller","initial","html","resolveData","contents","$scope","$onInit","children","uiView","uiViewCreatedBy","parseStateRef","ref","parsed","preparsed","paramExpr","stateContext","el","stateData","getTypeInfo","isSvg","prop","isForm","nodeName","isAnchor","toUpperCase","clickable","clickHook","button","which","ctrlKey","metaKey","shiftKey","preventDefault","ignorePreventDefaultCount","cancel","defaultOpts","$StateRefDirective","require","uiSrefActive","hookFn","uiSref","active","unlinkInfoFn","uiSrefOpts","$$addStateInfo","$watch","unbind","$StateRefDynamicDirective","runStateRefLink","group","uiState","uiStateParams","uiStateOpts","watch","$StateRefActiveDirective","$attrs","addState","stateParams","activeClass","stateHash","createStateHash","stateInfo","activeClasses","idx","anyMatch","addClass","removeClass","exactMatch","activeEqClass","className","uiSrefActiveEq","newState","deregister","$IsStateFilter","isFilter","$stateful","$IncludedByStateFilter","includesFilter","defaultConfig","searchParams","decodePathArray","reverseString","str","unquoteDashes","allReversed","paramName","parameters","nTotal","nPath","paramVal","encodeDashes","encodeURIComponent","charCodeAt","isPathParam","isDefaultValue","nextSegment","isFinalPathParam","$subPattern","sub","substr","mode","ArrayType","bindTo","callbackName","arrayWrap","arrayUnwrap","falsey","arrayHandler","allTruthyMode","arrayEqualsHandler","val1","val2","$arrayMode","run","constant","autoinject","__WEBPACK_AMD_DEFINE_ARRAY__","__WEBPACK_AMD_DEFINE_RESULT__","runTranslate","$translate","storageKey","storage","fallbackFromIncorrectStorageValue","preferred","preferredLanguage","use","put","displayName","$translateSanitizationProvider","$sanitize","currentStrategy","hasConfiguredStrategy","hasShownNoStrategyConfiguredWarning","sanitize","htmlSanitizeValue","escape","htmlEscapeValue","sanitizeParameters","mapInterpolationParameters","escapeParameters","escaped","addStrategy","strategyName","strategyFunction","removeStrategy","useStrategy","strategy","$log","cachedStrategyMap","applyStrategies","selectedStrategies","selectedStrategy","showNoStrategyConfiguredWarning","warn","iteratee","stack","propertyValue","propertyKey","isNumber","$STORAGE_KEY","$windowProvider","pascalprechtTranslateOverrider","$preferredLanguage","$languageKeyAliases","$fallbackLanguage","$fallbackWasString","$uses","$nextLang","$storageFactory","$storagePrefix","$missingTranslationHandlerFactory","$interpolationFactory","$loaderFactory","$loaderOptions","$notFoundIndicatorLeft","$notFoundIndicatorRight","loaderCache","postProcessFn","$translationTable","$availableLanguageKeys","$storageKey","$interpolatorFactories","$cloakClassName","$postCompilingEnabled","$forceAsyncReloadEnabled","$nestedObjectDelimeter","$isReady","$keepContent","directivePriority","statefulFilter","uniformLanguageTagResolver","languageTagResolver","tag","java","temp","parts","toLowerCase","bcp47","iso639-1","getFirstBrowserLanguage","getLocale","language","navigator","browserLanguagePropertyKeys","languages","locale","searchElement","trim","negotiateLocale","avail","lowercase","alias","langKeyAlias","hasWildcardKey","hasExactKey","translations","langKey","translationTable","flatObject","cloakClassName","nestedObjectDelimeter","delimiter","prevKey","keyWithPath","keyWithShortPath","addInterpolation","useMessageFormatInterpolation","useInterpolation","useSanitizeValueStrategy","setupPreferredLanguage","translationNotFoundIndicator","indicator","translationNotFoundIndicatorLeft","translationNotFoundIndicatorRight","fallbackLanguage","fallbackStack","resolveClientLocale","useUrlLoader","useLoader","useStaticFilesLoader","loaderFactory","useLocalStorage","useStorage","useCookieStorage","storageFactory","storagePrefix","useMissingTranslationHandlerLog","useMissingTranslationHandler","usePostCompiling","forceAsyncReload","uniformLanguageTag","standard","determinePreferredLanguage","fn","registerAvailableLanguageKeys","languageKeys","aliases","useLoaderCache","postProcess","keepContent","Storage","fallbackIndex","startFallbackIteration","defaultInterpolator","pendingLoader","interpolatorHashMap","langPromises","translationId","interpolateParams","interpolationId","defaultTranslationText","forceLanguage","uses","loadTranslationsIfMissing","translateAll","translationIds","results","translate","deferred","regardless","promiseToWaitFor","promiseResolved","determineTranslation","applyNotFoundIndicators","useLanguage","setLocale","eachInterpolator","interpolator","loadAsync","loaderOptions","onLoaderSuccess","table","onLoaderError","eachInterpolationFactory","interpolatorFactory","getInterpolationIdentifier","getTranslationTable","onResolve","getFallbackTranslation","Interpolator","translation","interpolatedValue","applyPostProcessing","getFallbackTranslationInstant","translateByHandler","resultString","resolveForFallbackLanguage","fallbackLanguageIndex","resolveForFallbackLanguageInstant","fallbackTranslation","fallbackTranslationInstant","resolvedTranslation","missingTranslationHandlerTranslation","_translationId","determineTranslationInstant","clearNextLangAndPromise","useFallbackLanguage","langKeyPosition","proposedLanguage","aliasedKey","isPostCompilingEnabled","isForceAsyncReloadEnabled","isKeepContent","refresh","oneTranslationsLoaded","tables","loadingKeys","allTranslationsLoaded","tableData","instant","isUndefined","possibleLangKeys","d","possibleLangKey","versionInfo","isReady","$onReadyDeferred","onReady","getAvailableLanguageKeys","globalOnReadyListener","globalOnChangeListener","processAsyncResult","fallbackLanguageId","$translateDefaultInterpolation","$translateSanitization","$locale","$translateInterpolator","$identifier","interpolationParams","interpolatedText","translateDirective","$parse","tAttr","translateValuesExist","translateValues","translateInterpolation","translateValueExist","outerHTML","interpolateRegExp","startSymbol","endSymbol","watcherRegExp","iElement","iAttr","preText","postText","translateNamespace","getTranslateNamespace","initInterpolationParams","$parent","attributeName","observeElementTranslation","_unwatchOld","iElementText","interpolateMatches","watcherMatches","newValue","updateTranslations","observeAttributeTranslation","translateAttr","$observe","firstAttributeChangedEvent","defaultText","observeValueAttribute","attrName","updateTranslation","translateLanguage","applyTranslation","successful","translateKeepContent","empty","append","globallyEnabled","locallyDefined","translateCompile","locallyEnabled","$attr","translateDefault","unbindTranslateLanguage","translateCloakDirective","applyCloak","removeCloak","translateCloak","translateNamespaceDirective","pre","iAttrs","translateLanguageDirective","newTranslateLanguage","translateFilterFactory","translateFilter","interpolation","$translationCache","$cacheFactory","$$CookieWriter","$document","buildCookieString","expires","cookiePath","domain","toUTCString","secure","cookieLength","rawDocument","cookie","calcOptions","$$cookieReader","$$cookieWriter","getObject","getAll","putObject","$cookies","isValidDottedPath","MEMBER_NAME_REGEX","lookupDottedPath","$resourceMinErr","shallowClearAndCopy","$$minErr","PROTOCOL_AND_DOMAIN_REGEX","stripTrailingSlashes","cancellable","actions","method","save","query","delete","encodeUriSegment","encodeUriQuery","pctEncodeSpaces","Route","urlParams","resourceFactory","paramDefaults","extractParams","actionParams","ids","defaultResponseInterceptor","resource","Resource","route","toJSON","$promise","$resolved","action","hasBody","numericTimeout","timeout","debug","a1","a2","a3","a4","timeoutDeferred","numericTimeoutPromise","isInstanceCall","httpConfig","responseInterceptor","interceptor","responseErrorInterceptor","responseError","setUrlParams","noop","$cancelRequest","additionalParamDefaults","actionUrl","encodedVal","protocolAndDomain","isQueryParamValue","paramInfo","urlParam","p1","leadingSlashes","tail"],"mappings":"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","file":"vendors.js","sourcesContent":["/******/ (function(modules) { // webpackBootstrap\n/******/ \t// install a JSONP callback for chunk loading\n/******/ \tvar parentJsonpFunction = window[\"webpackJsonp\"];\n/******/ \twindow[\"webpackJsonp\"] = function webpackJsonpCallback(chunkIds, moreModules) {\n/******/ \t\t// add \"moreModules\" to the modules object,\n/******/ \t\t// then flag all \"chunkIds\" as loaded and fire callback\n/******/ \t\tvar moduleId, chunkId, i = 0, callbacks = [];\n/******/ \t\tfor(;i < chunkIds.length; i++) {\n/******/ \t\t\tchunkId = chunkIds[i];\n/******/ \t\t\tif(installedChunks[chunkId])\n/******/ \t\t\t\tcallbacks.push.apply(callbacks, installedChunks[chunkId]);\n/******/ \t\t\tinstalledChunks[chunkId] = 0;\n/******/ \t\t}\n/******/ \t\tfor(moduleId in moreModules) {\n/******/ \t\t\tmodules[moduleId] = moreModules[moduleId];\n/******/ \t\t}\n/******/ \t\tif(parentJsonpFunction) parentJsonpFunction(chunkIds, moreModules);\n/******/ \t\twhile(callbacks.length)\n/******/ \t\t\tcallbacks.shift().call(null, __webpack_require__);\n/******/ \t\tif(moreModules[0]) {\n/******/ \t\t\tinstalledModules[0] = 0;\n/******/ \t\t\treturn __webpack_require__(0);\n/******/ \t\t}\n/******/ \t};\n/******/\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// object to store loaded and loading chunks\n/******/ \t// \"0\" means \"already loaded\"\n/******/ \t// Array means \"loading\", array contains callbacks\n/******/ \tvar installedChunks = {\n/******/ \t\t2:0\n/******/ \t};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/ \t// This file contains only the entry chunk.\n/******/ \t// The chunk loading function for additional chunks\n/******/ \t__webpack_require__.e = function requireEnsure(chunkId, callback) {\n/******/ \t\t// \"0\" is the signal for \"already loaded\"\n/******/ \t\tif(installedChunks[chunkId] === 0)\n/******/ \t\t\treturn callback.call(null, __webpack_require__);\n/******/\n/******/ \t\t// an array means \"currently loading\".\n/******/ \t\tif(installedChunks[chunkId] !== undefined) {\n/******/ \t\t\tinstalledChunks[chunkId].push(callback);\n/******/ \t\t} else {\n/******/ \t\t\t// start chunk loading\n/******/ \t\t\tinstalledChunks[chunkId] = [callback];\n/******/ \t\t\tvar head = document.getElementsByTagName('head')[0];\n/******/ \t\t\tvar script = document.createElement('script');\n/******/ \t\t\tscript.type = 'text/javascript';\n/******/ \t\t\tscript.charset = 'utf-8';\n/******/ \t\t\tscript.async = true;\n/******/\n/******/ \t\t\tscript.src = __webpack_require__.p + \"\" + ({\"0\":\"app\",\"1\":\"core\"}[chunkId]||chunkId) + \".feature.js\";\n/******/ \t\t\thead.appendChild(script);\n/******/ \t\t}\n/******/ \t};\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tmodule.exports = __webpack_require__(3);\n\n\n/***/ },\n/* 1 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t    value: true\n\t});\n\t\n\tvar _coreCommon = __webpack_require__(2);\n\t\n\tvar _coreCommon2 = _interopRequireDefault(_coreCommon);\n\t\n\tvar _angularUiRouter = __webpack_require__(7);\n\t\n\tvar _angularUiRouter2 = _interopRequireDefault(_angularUiRouter);\n\t\n\tvar _angularTranslate = __webpack_require__(8);\n\t\n\tvar _angularTranslate2 = _interopRequireDefault(_angularTranslate);\n\t\n\tvar _angularCookies = __webpack_require__(9);\n\t\n\tvar _angularCookies2 = _interopRequireDefault(_angularCookies);\n\t\n\tvar _angularResource = __webpack_require__(11);\n\t\n\tvar _angularResource2 = _interopRequireDefault(_angularResource);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\texports.default = angular.module(\"core.base\", [_coreCommon2.default, _angularUiRouter2.default, _angularTranslate2.default, _angularCookies2.default, _angularResource2.default]).name;\n\n/***/ },\n/* 2 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t    value: true\n\t});\n\t\n\tvar _angular = __webpack_require__(3);\n\t\n\tvar _angular2 = _interopRequireDefault(_angular);\n\t\n\tvar _coreCommon = __webpack_require__(4);\n\t\n\tvar _coreCommon2 = _interopRequireDefault(_coreCommon);\n\t\n\tvar _coreCommon3 = __webpack_require__(5);\n\t\n\tvar _coreCommon4 = _interopRequireDefault(_coreCommon3);\n\t\n\tvar _coreCommon5 = __webpack_require__(6);\n\t\n\tvar _coreCommon6 = _interopRequireDefault(_coreCommon5);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\texports.default = _angular2.default.module('core.common', []).directive(_coreCommon2.default).directive(_coreCommon6.default).provider('staticLoader', _coreCommon4.default).name;\n\n/***/ },\n/* 3 */\n/***/ function(module, exports) {\n\n\tmodule.exports = angular;\n\n/***/ },\n/* 4 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t    value: true\n\t});\n\texports.default = svgImage;\n\t\n\tsvgImage.$inject = ['$http'];\n\tfunction svgImage($http) {\n\t    return {\n\t        restrict: 'E',\n\t        link: function link(scope, element) {\n\t            var imgURL = element.attr('src');\n\t            // if you want to use ng-include, then\n\t            // instead of the above line write the bellow:\n\t            // var imgURL = element.attr('ng-include');\n\t            var request = $http.get(imgURL, { 'Content-Type': 'application/xml' });\n\t\n\t            scope.manipulateImgNode = function (data, elem) {\n\t                var $svg = angular.element(data)[4];\n\t                var imgClass = elem.attr('class');\n\t                if (typeof imgClass !== 'undefined') {\n\t                    var classes = imgClass.split(' ');\n\t                    for (var i = 0; i < classes.length; ++i) {\n\t                        $svg.classList.add(classes[i]);\n\t                    }\n\t                }\n\t                $svg.removeAttribute('xmlns:a');\n\t                return $svg;\n\t            };\n\t\n\t            request.success(function (data) {\n\t                element.replaceWith(scope.manipulateImgNode(data, element));\n\t            });\n\t        }\n\t    };\n\t}\n\n/***/ },\n/* 5 */\n/***/ function(module, exports) {\n\n\t\"use strict\";\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t    value: true\n\t});\n\t\n\tvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\t\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\t\n\tvar StaticLoader = function () {\n\t    function StaticLoader() {\n\t        _classCallCheck(this, StaticLoader);\n\t\n\t        this.rootPath = \"\";\n\t        this.cacheMap = {};\n\t    }\n\t\n\t    _createClass(StaticLoader, [{\n\t        key: \"setRootPath\",\n\t        value: function setRootPath(path) {\n\t            this.rootPath = path;\n\t        }\n\t    }, {\n\t        key: \"$get\",\n\t        value: function $get($http) {\n\t            var factory = {};\n\t            var self = this;\n\t            factory.get = function (path, callback) {\n\t                if (rootPath) {\n\t                    path = self.rootPath + path;\n\t                }\n\t                if (self.cacheMap[self.cacheMap]) {\n\t                    return callback(200, self.cacheMap[self.cacheMap]);\n\t                }\n\t                $http.get(path).then(function (res) {\n\t                    if (res.status == 200) {\n\t                        self.cacheMap[path] = res.data;\n\t                    }\n\t                    callback(res.status, res.data);\n\t                });\n\t            };\n\t            return factory;\n\t        }\n\t    }]);\n\t\n\t    return StaticLoader;\n\t}();\n\t\n\texports.default = StaticLoader;\n\n/***/ },\n/* 6 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t    value: true\n\t});\n\texports.default = errSrc;\n\tfunction errSrc() {\n\t    return {\n\t        link: function link(scope, element, attrs) {\n\t            element.bind('error', function () {\n\t                if (attrs.isHide == true) {\n\t                    element.css('display', 'block');\n\t                }\n\t                if (attrs.src != attrs.errSrc) {\n\t                    attrs.$set('src', attrs.errSrc);\n\t                }\n\t            });\n\t        }\n\t    };\n\t}\n\n/***/ },\n/* 7 */\n/***/ function(module, exports) {\n\n\t/**\n\t * State-based routing for AngularJS\n\t * @version v0.3.1\n\t * @link http://angular-ui.github.com/\n\t * @license MIT License, http://www.opensource.org/licenses/MIT\n\t */\n\t\n\t/* commonjs package manager support (eg componentjs) */\n\tif (typeof module !== \"undefined\" && typeof exports !== \"undefined\" && module.exports === exports){\n\t  module.exports = 'ui.router';\n\t}\n\t\n\t(function (window, angular, undefined) {\n\t/*jshint globalstrict:true*/\n\t/*global angular:false*/\n\t'use strict';\n\t\n\tvar isDefined = angular.isDefined,\n\t    isFunction = angular.isFunction,\n\t    isString = angular.isString,\n\t    isObject = angular.isObject,\n\t    isArray = angular.isArray,\n\t    forEach = angular.forEach,\n\t    extend = angular.extend,\n\t    copy = angular.copy,\n\t    toJson = angular.toJson;\n\t\n\tfunction inherit(parent, extra) {\n\t  return extend(new (extend(function() {}, { prototype: parent }))(), extra);\n\t}\n\t\n\tfunction merge(dst) {\n\t  forEach(arguments, function(obj) {\n\t    if (obj !== dst) {\n\t      forEach(obj, function(value, key) {\n\t        if (!dst.hasOwnProperty(key)) dst[key] = value;\n\t      });\n\t    }\n\t  });\n\t  return dst;\n\t}\n\t\n\t/**\n\t * Finds the common ancestor path between two states.\n\t *\n\t * @param {Object} first The first state.\n\t * @param {Object} second The second state.\n\t * @return {Array} Returns an array of state names in descending order, not including the root.\n\t */\n\tfunction ancestors(first, second) {\n\t  var path = [];\n\t\n\t  for (var n in first.path) {\n\t    if (first.path[n] !== second.path[n]) break;\n\t    path.push(first.path[n]);\n\t  }\n\t  return path;\n\t}\n\t\n\t/**\n\t * IE8-safe wrapper for `Object.keys()`.\n\t *\n\t * @param {Object} object A JavaScript object.\n\t * @return {Array} Returns the keys of the object as an array.\n\t */\n\tfunction objectKeys(object) {\n\t  if (Object.keys) {\n\t    return Object.keys(object);\n\t  }\n\t  var result = [];\n\t\n\t  forEach(object, function(val, key) {\n\t    result.push(key);\n\t  });\n\t  return result;\n\t}\n\t\n\t/**\n\t * IE8-safe wrapper for `Array.prototype.indexOf()`.\n\t *\n\t * @param {Array} array A JavaScript array.\n\t * @param {*} value A value to search the array for.\n\t * @return {Number} Returns the array index value of `value`, or `-1` if not present.\n\t */\n\tfunction indexOf(array, value) {\n\t  if (Array.prototype.indexOf) {\n\t    return array.indexOf(value, Number(arguments[2]) || 0);\n\t  }\n\t  var len = array.length >>> 0, from = Number(arguments[2]) || 0;\n\t  from = (from < 0) ? Math.ceil(from) : Math.floor(from);\n\t\n\t  if (from < 0) from += len;\n\t\n\t  for (; from < len; from++) {\n\t    if (from in array && array[from] === value) return from;\n\t  }\n\t  return -1;\n\t}\n\t\n\t/**\n\t * Merges a set of parameters with all parameters inherited between the common parents of the\n\t * current state and a given destination state.\n\t *\n\t * @param {Object} currentParams The value of the current state parameters ($stateParams).\n\t * @param {Object} newParams The set of parameters which will be composited with inherited params.\n\t * @param {Object} $current Internal definition of object representing the current state.\n\t * @param {Object} $to Internal definition of object representing state to transition to.\n\t */\n\tfunction inheritParams(currentParams, newParams, $current, $to) {\n\t  var parents = ancestors($current, $to), parentParams, inherited = {}, inheritList = [];\n\t\n\t  for (var i in parents) {\n\t    if (!parents[i] || !parents[i].params) continue;\n\t    parentParams = objectKeys(parents[i].params);\n\t    if (!parentParams.length) continue;\n\t\n\t    for (var j in parentParams) {\n\t      if (indexOf(inheritList, parentParams[j]) >= 0) continue;\n\t      inheritList.push(parentParams[j]);\n\t      inherited[parentParams[j]] = currentParams[parentParams[j]];\n\t    }\n\t  }\n\t  return extend({}, inherited, newParams);\n\t}\n\t\n\t/**\n\t * Performs a non-strict comparison of the subset of two objects, defined by a list of keys.\n\t *\n\t * @param {Object} a The first object.\n\t * @param {Object} b The second object.\n\t * @param {Array} keys The list of keys within each object to compare. If the list is empty or not specified,\n\t *                     it defaults to the list of keys in `a`.\n\t * @return {Boolean} Returns `true` if the keys match, otherwise `false`.\n\t */\n\tfunction equalForKeys(a, b, keys) {\n\t  if (!keys) {\n\t    keys = [];\n\t    for (var n in a) keys.push(n); // Used instead of Object.keys() for IE8 compatibility\n\t  }\n\t\n\t  for (var i=0; i<keys.length; i++) {\n\t    var k = keys[i];\n\t    if (a[k] != b[k]) return false; // Not '===', values aren't necessarily normalized\n\t  }\n\t  return true;\n\t}\n\t\n\t/**\n\t * Returns the subset of an object, based on a list of keys.\n\t *\n\t * @param {Array} keys\n\t * @param {Object} values\n\t * @return {Boolean} Returns a subset of `values`.\n\t */\n\tfunction filterByKeys(keys, values) {\n\t  var filtered = {};\n\t\n\t  forEach(keys, function (name) {\n\t    filtered[name] = values[name];\n\t  });\n\t  return filtered;\n\t}\n\t\n\t// like _.indexBy\n\t// when you know that your index values will be unique, or you want last-one-in to win\n\tfunction indexBy(array, propName) {\n\t  var result = {};\n\t  forEach(array, function(item) {\n\t    result[item[propName]] = item;\n\t  });\n\t  return result;\n\t}\n\t\n\t// extracted from underscore.js\n\t// Return a copy of the object only containing the whitelisted properties.\n\tfunction pick(obj) {\n\t  var copy = {};\n\t  var keys = Array.prototype.concat.apply(Array.prototype, Array.prototype.slice.call(arguments, 1));\n\t  forEach(keys, function(key) {\n\t    if (key in obj) copy[key] = obj[key];\n\t  });\n\t  return copy;\n\t}\n\t\n\t// extracted from underscore.js\n\t// Return a copy of the object omitting the blacklisted properties.\n\tfunction omit(obj) {\n\t  var copy = {};\n\t  var keys = Array.prototype.concat.apply(Array.prototype, Array.prototype.slice.call(arguments, 1));\n\t  for (var key in obj) {\n\t    if (indexOf(keys, key) == -1) copy[key] = obj[key];\n\t  }\n\t  return copy;\n\t}\n\t\n\tfunction pluck(collection, key) {\n\t  var result = isArray(collection) ? [] : {};\n\t\n\t  forEach(collection, function(val, i) {\n\t    result[i] = isFunction(key) ? key(val) : val[key];\n\t  });\n\t  return result;\n\t}\n\t\n\tfunction filter(collection, callback) {\n\t  var array = isArray(collection);\n\t  var result = array ? [] : {};\n\t  forEach(collection, function(val, i) {\n\t    if (callback(val, i)) {\n\t      result[array ? result.length : i] = val;\n\t    }\n\t  });\n\t  return result;\n\t}\n\t\n\tfunction map(collection, callback) {\n\t  var result = isArray(collection) ? [] : {};\n\t\n\t  forEach(collection, function(val, i) {\n\t    result[i] = callback(val, i);\n\t  });\n\t  return result;\n\t}\n\t\n\t/**\n\t * @ngdoc overview\n\t * @name ui.router.util\n\t *\n\t * @description\n\t * # ui.router.util sub-module\n\t *\n\t * This module is a dependency of other sub-modules. Do not include this module as a dependency\n\t * in your angular app (use {@link ui.router} module instead).\n\t *\n\t */\n\tangular.module('ui.router.util', ['ng']);\n\t\n\t/**\n\t * @ngdoc overview\n\t * @name ui.router.router\n\t * \n\t * @requires ui.router.util\n\t *\n\t * @description\n\t * # ui.router.router sub-module\n\t *\n\t * This module is a dependency of other sub-modules. Do not include this module as a dependency\n\t * in your angular app (use {@link ui.router} module instead).\n\t */\n\tangular.module('ui.router.router', ['ui.router.util']);\n\t\n\t/**\n\t * @ngdoc overview\n\t * @name ui.router.state\n\t * \n\t * @requires ui.router.router\n\t * @requires ui.router.util\n\t *\n\t * @description\n\t * # ui.router.state sub-module\n\t *\n\t * This module is a dependency of the main ui.router module. Do not include this module as a dependency\n\t * in your angular app (use {@link ui.router} module instead).\n\t * \n\t */\n\tangular.module('ui.router.state', ['ui.router.router', 'ui.router.util']);\n\t\n\t/**\n\t * @ngdoc overview\n\t * @name ui.router\n\t *\n\t * @requires ui.router.state\n\t *\n\t * @description\n\t * # ui.router\n\t * \n\t * ## The main module for ui.router \n\t * There are several sub-modules included with the ui.router module, however only this module is needed\n\t * as a dependency within your angular app. The other modules are for organization purposes. \n\t *\n\t * The modules are:\n\t * * ui.router - the main \"umbrella\" module\n\t * * ui.router.router - \n\t * \n\t * *You'll need to include **only** this module as the dependency within your angular app.*\n\t * \n\t * <pre>\n\t * <!doctype html>\n\t * <html ng-app=\"myApp\">\n\t * <head>\n\t *   <script src=\"js/angular.js\"></script>\n\t *   <!-- Include the ui-router script -->\n\t *   <script src=\"js/angular-ui-router.min.js\"></script>\n\t *   <script>\n\t *     // ...and add 'ui.router' as a dependency\n\t *     var myApp = angular.module('myApp', ['ui.router']);\n\t *   </script>\n\t * </head>\n\t * <body>\n\t * </body>\n\t * </html>\n\t * </pre>\n\t */\n\tangular.module('ui.router', ['ui.router.state']);\n\t\n\tangular.module('ui.router.compat', ['ui.router']);\n\t\n\t/**\n\t * @ngdoc object\n\t * @name ui.router.util.$resolve\n\t *\n\t * @requires $q\n\t * @requires $injector\n\t *\n\t * @description\n\t * Manages resolution of (acyclic) graphs of promises.\n\t */\n\t$Resolve.$inject = ['$q', '$injector'];\n\tfunction $Resolve(  $q,    $injector) {\n\t  \n\t  var VISIT_IN_PROGRESS = 1,\n\t      VISIT_DONE = 2,\n\t      NOTHING = {},\n\t      NO_DEPENDENCIES = [],\n\t      NO_LOCALS = NOTHING,\n\t      NO_PARENT = extend($q.when(NOTHING), { $$promises: NOTHING, $$values: NOTHING });\n\t  \n\t\n\t  /**\n\t   * @ngdoc function\n\t   * @name ui.router.util.$resolve#study\n\t   * @methodOf ui.router.util.$resolve\n\t   *\n\t   * @description\n\t   * Studies a set of invocables that are likely to be used multiple times.\n\t   * <pre>\n\t   * $resolve.study(invocables)(locals, parent, self)\n\t   * </pre>\n\t   * is equivalent to\n\t   * <pre>\n\t   * $resolve.resolve(invocables, locals, parent, self)\n\t   * </pre>\n\t   * but the former is more efficient (in fact `resolve` just calls `study` \n\t   * internally).\n\t   *\n\t   * @param {object} invocables Invocable objects\n\t   * @return {function} a function to pass in locals, parent and self\n\t   */\n\t  this.study = function (invocables) {\n\t    if (!isObject(invocables)) throw new Error(\"'invocables' must be an object\");\n\t    var invocableKeys = objectKeys(invocables || {});\n\t    \n\t    // Perform a topological sort of invocables to build an ordered plan\n\t    var plan = [], cycle = [], visited = {};\n\t    function visit(value, key) {\n\t      if (visited[key] === VISIT_DONE) return;\n\t      \n\t      cycle.push(key);\n\t      if (visited[key] === VISIT_IN_PROGRESS) {\n\t        cycle.splice(0, indexOf(cycle, key));\n\t        throw new Error(\"Cyclic dependency: \" + cycle.join(\" -> \"));\n\t      }\n\t      visited[key] = VISIT_IN_PROGRESS;\n\t      \n\t      if (isString(value)) {\n\t        plan.push(key, [ function() { return $injector.get(value); }], NO_DEPENDENCIES);\n\t      } else {\n\t        var params = $injector.annotate(value);\n\t        forEach(params, function (param) {\n\t          if (param !== key && invocables.hasOwnProperty(param)) visit(invocables[param], param);\n\t        });\n\t        plan.push(key, value, params);\n\t      }\n\t      \n\t      cycle.pop();\n\t      visited[key] = VISIT_DONE;\n\t    }\n\t    forEach(invocables, visit);\n\t    invocables = cycle = visited = null; // plan is all that's required\n\t    \n\t    function isResolve(value) {\n\t      return isObject(value) && value.then && value.$$promises;\n\t    }\n\t    \n\t    return function (locals, parent, self) {\n\t      if (isResolve(locals) && self === undefined) {\n\t        self = parent; parent = locals; locals = null;\n\t      }\n\t      if (!locals) locals = NO_LOCALS;\n\t      else if (!isObject(locals)) {\n\t        throw new Error(\"'locals' must be an object\");\n\t      }       \n\t      if (!parent) parent = NO_PARENT;\n\t      else if (!isResolve(parent)) {\n\t        throw new Error(\"'parent' must be a promise returned by $resolve.resolve()\");\n\t      }\n\t      \n\t      // To complete the overall resolution, we have to wait for the parent\n\t      // promise and for the promise for each invokable in our plan.\n\t      var resolution = $q.defer(),\n\t          result = resolution.promise,\n\t          promises = result.$$promises = {},\n\t          values = extend({}, locals),\n\t          wait = 1 + plan.length/3,\n\t          merged = false;\n\t          \n\t      function done() {\n\t        // Merge parent values we haven't got yet and publish our own $$values\n\t        if (!--wait) {\n\t          if (!merged) merge(values, parent.$$values); \n\t          result.$$values = values;\n\t          result.$$promises = result.$$promises || true; // keep for isResolve()\n\t          delete result.$$inheritedValues;\n\t          resolution.resolve(values);\n\t        }\n\t      }\n\t      \n\t      function fail(reason) {\n\t        result.$$failure = reason;\n\t        resolution.reject(reason);\n\t      }\n\t\n\t      // Short-circuit if parent has already failed\n\t      if (isDefined(parent.$$failure)) {\n\t        fail(parent.$$failure);\n\t        return result;\n\t      }\n\t      \n\t      if (parent.$$inheritedValues) {\n\t        merge(values, omit(parent.$$inheritedValues, invocableKeys));\n\t      }\n\t\n\t      // Merge parent values if the parent has already resolved, or merge\n\t      // parent promises and wait if the parent resolve is still in progress.\n\t      extend(promises, parent.$$promises);\n\t      if (parent.$$values) {\n\t        merged = merge(values, omit(parent.$$values, invocableKeys));\n\t        result.$$inheritedValues = omit(parent.$$values, invocableKeys);\n\t        done();\n\t      } else {\n\t        if (parent.$$inheritedValues) {\n\t          result.$$inheritedValues = omit(parent.$$inheritedValues, invocableKeys);\n\t        }        \n\t        parent.then(done, fail);\n\t      }\n\t      \n\t      // Process each invocable in the plan, but ignore any where a local of the same name exists.\n\t      for (var i=0, ii=plan.length; i<ii; i+=3) {\n\t        if (locals.hasOwnProperty(plan[i])) done();\n\t        else invoke(plan[i], plan[i+1], plan[i+2]);\n\t      }\n\t      \n\t      function invoke(key, invocable, params) {\n\t        // Create a deferred for this invocation. Failures will propagate to the resolution as well.\n\t        var invocation = $q.defer(), waitParams = 0;\n\t        function onfailure(reason) {\n\t          invocation.reject(reason);\n\t          fail(reason);\n\t        }\n\t        // Wait for any parameter that we have a promise for (either from parent or from this\n\t        // resolve; in that case study() will have made sure it's ordered before us in the plan).\n\t        forEach(params, function (dep) {\n\t          if (promises.hasOwnProperty(dep) && !locals.hasOwnProperty(dep)) {\n\t            waitParams++;\n\t            promises[dep].then(function (result) {\n\t              values[dep] = result;\n\t              if (!(--waitParams)) proceed();\n\t            }, onfailure);\n\t          }\n\t        });\n\t        if (!waitParams) proceed();\n\t        function proceed() {\n\t          if (isDefined(result.$$failure)) return;\n\t          try {\n\t            invocation.resolve($injector.invoke(invocable, self, values));\n\t            invocation.promise.then(function (result) {\n\t              values[key] = result;\n\t              done();\n\t            }, onfailure);\n\t          } catch (e) {\n\t            onfailure(e);\n\t          }\n\t        }\n\t        // Publish promise synchronously; invocations further down in the plan may depend on it.\n\t        promises[key] = invocation.promise;\n\t      }\n\t      \n\t      return result;\n\t    };\n\t  };\n\t  \n\t  /**\n\t   * @ngdoc function\n\t   * @name ui.router.util.$resolve#resolve\n\t   * @methodOf ui.router.util.$resolve\n\t   *\n\t   * @description\n\t   * Resolves a set of invocables. An invocable is a function to be invoked via \n\t   * `$injector.invoke()`, and can have an arbitrary number of dependencies. \n\t   * An invocable can either return a value directly,\n\t   * or a `$q` promise. If a promise is returned it will be resolved and the \n\t   * resulting value will be used instead. Dependencies of invocables are resolved \n\t   * (in this order of precedence)\n\t   *\n\t   * - from the specified `locals`\n\t   * - from another invocable that is part of this `$resolve` call\n\t   * - from an invocable that is inherited from a `parent` call to `$resolve` \n\t   *   (or recursively\n\t   * - from any ancestor `$resolve` of that parent).\n\t   *\n\t   * The return value of `$resolve` is a promise for an object that contains \n\t   * (in this order of precedence)\n\t   *\n\t   * - any `locals` (if specified)\n\t   * - the resolved return values of all injectables\n\t   * - any values inherited from a `parent` call to `$resolve` (if specified)\n\t   *\n\t   * The promise will resolve after the `parent` promise (if any) and all promises \n\t   * returned by injectables have been resolved. If any invocable \n\t   * (or `$injector.invoke`) throws an exception, or if a promise returned by an \n\t   * invocable is rejected, the `$resolve` promise is immediately rejected with the \n\t   * same error. A rejection of a `parent` promise (if specified) will likewise be \n\t   * propagated immediately. Once the `$resolve` promise has been rejected, no \n\t   * further invocables will be called.\n\t   * \n\t   * Cyclic dependencies between invocables are not permitted and will cause `$resolve`\n\t   * to throw an error. As a special case, an injectable can depend on a parameter \n\t   * with the same name as the injectable, which will be fulfilled from the `parent` \n\t   * injectable of the same name. This allows inherited values to be decorated. \n\t   * Note that in this case any other injectable in the same `$resolve` with the same\n\t   * dependency would see the decorated value, not the inherited value.\n\t   *\n\t   * Note that missing dependencies -- unlike cyclic dependencies -- will cause an \n\t   * (asynchronous) rejection of the `$resolve` promise rather than a (synchronous) \n\t   * exception.\n\t   *\n\t   * Invocables are invoked eagerly as soon as all dependencies are available. \n\t   * This is true even for dependencies inherited from a `parent` call to `$resolve`.\n\t   *\n\t   * As a special case, an invocable can be a string, in which case it is taken to \n\t   * be a service name to be passed to `$injector.get()`. This is supported primarily \n\t   * for backwards-compatibility with the `resolve` property of `$routeProvider` \n\t   * routes.\n\t   *\n\t   * @param {object} invocables functions to invoke or \n\t   * `$injector` services to fetch.\n\t   * @param {object} locals  values to make available to the injectables\n\t   * @param {object} parent  a promise returned by another call to `$resolve`.\n\t   * @param {object} self  the `this` for the invoked methods\n\t   * @return {object} Promise for an object that contains the resolved return value\n\t   * of all invocables, as well as any inherited and local values.\n\t   */\n\t  this.resolve = function (invocables, locals, parent, self) {\n\t    return this.study(invocables)(locals, parent, self);\n\t  };\n\t}\n\t\n\tangular.module('ui.router.util').service('$resolve', $Resolve);\n\t\n\t\n\t/**\n\t * @ngdoc object\n\t * @name ui.router.util.$templateFactory\n\t *\n\t * @requires $http\n\t * @requires $templateCache\n\t * @requires $injector\n\t *\n\t * @description\n\t * Service. Manages loading of templates.\n\t */\n\t$TemplateFactory.$inject = ['$http', '$templateCache', '$injector'];\n\tfunction $TemplateFactory(  $http,   $templateCache,   $injector) {\n\t\n\t  /**\n\t   * @ngdoc function\n\t   * @name ui.router.util.$templateFactory#fromConfig\n\t   * @methodOf ui.router.util.$templateFactory\n\t   *\n\t   * @description\n\t   * Creates a template from a configuration object. \n\t   *\n\t   * @param {object} config Configuration object for which to load a template. \n\t   * The following properties are search in the specified order, and the first one \n\t   * that is defined is used to create the template:\n\t   *\n\t   * @param {string|object} config.template html string template or function to \n\t   * load via {@link ui.router.util.$templateFactory#fromString fromString}.\n\t   * @param {string|object} config.templateUrl url to load or a function returning \n\t   * the url to load via {@link ui.router.util.$templateFactory#fromUrl fromUrl}.\n\t   * @param {Function} config.templateProvider function to invoke via \n\t   * {@link ui.router.util.$templateFactory#fromProvider fromProvider}.\n\t   * @param {object} params  Parameters to pass to the template function.\n\t   * @param {object} locals Locals to pass to `invoke` if the template is loaded \n\t   * via a `templateProvider`. Defaults to `{ params: params }`.\n\t   *\n\t   * @return {string|object}  The template html as a string, or a promise for \n\t   * that string,or `null` if no template is configured.\n\t   */\n\t  this.fromConfig = function (config, params, locals) {\n\t    return (\n\t      isDefined(config.template) ? this.fromString(config.template, params) :\n\t      isDefined(config.templateUrl) ? this.fromUrl(config.templateUrl, params) :\n\t      isDefined(config.templateProvider) ? this.fromProvider(config.templateProvider, params, locals) :\n\t      null\n\t    );\n\t  };\n\t\n\t  /**\n\t   * @ngdoc function\n\t   * @name ui.router.util.$templateFactory#fromString\n\t   * @methodOf ui.router.util.$templateFactory\n\t   *\n\t   * @description\n\t   * Creates a template from a string or a function returning a string.\n\t   *\n\t   * @param {string|object} template html template as a string or function that \n\t   * returns an html template as a string.\n\t   * @param {object} params Parameters to pass to the template function.\n\t   *\n\t   * @return {string|object} The template html as a string, or a promise for that \n\t   * string.\n\t   */\n\t  this.fromString = function (template, params) {\n\t    return isFunction(template) ? template(params) : template;\n\t  };\n\t\n\t  /**\n\t   * @ngdoc function\n\t   * @name ui.router.util.$templateFactory#fromUrl\n\t   * @methodOf ui.router.util.$templateFactory\n\t   * \n\t   * @description\n\t   * Loads a template from the a URL via `$http` and `$templateCache`.\n\t   *\n\t   * @param {string|Function} url url of the template to load, or a function \n\t   * that returns a url.\n\t   * @param {Object} params Parameters to pass to the url function.\n\t   * @return {string|Promise.<string>} The template html as a string, or a promise \n\t   * for that string.\n\t   */\n\t  this.fromUrl = function (url, params) {\n\t    if (isFunction(url)) url = url(params);\n\t    if (url == null) return null;\n\t    else return $http\n\t        .get(url, { cache: $templateCache, headers: { Accept: 'text/html' }})\n\t        .then(function(response) { return response.data; });\n\t  };\n\t\n\t  /**\n\t   * @ngdoc function\n\t   * @name ui.router.util.$templateFactory#fromProvider\n\t   * @methodOf ui.router.util.$templateFactory\n\t   *\n\t   * @description\n\t   * Creates a template by invoking an injectable provider function.\n\t   *\n\t   * @param {Function} provider Function to invoke via `$injector.invoke`\n\t   * @param {Object} params Parameters for the template.\n\t   * @param {Object} locals Locals to pass to `invoke`. Defaults to \n\t   * `{ params: params }`.\n\t   * @return {string|Promise.<string>} The template html as a string, or a promise \n\t   * for that string.\n\t   */\n\t  this.fromProvider = function (provider, params, locals) {\n\t    return $injector.invoke(provider, null, locals || { params: params });\n\t  };\n\t}\n\t\n\tangular.module('ui.router.util').service('$templateFactory', $TemplateFactory);\n\t\n\tvar $$UMFP; // reference to $UrlMatcherFactoryProvider\n\t\n\t/**\n\t * @ngdoc object\n\t * @name ui.router.util.type:UrlMatcher\n\t *\n\t * @description\n\t * Matches URLs against patterns and extracts named parameters from the path or the search\n\t * part of the URL. A URL pattern consists of a path pattern, optionally followed by '?' and a list\n\t * of search parameters. Multiple search parameter names are separated by '&'. Search parameters\n\t * do not influence whether or not a URL is matched, but their values are passed through into\n\t * the matched parameters returned by {@link ui.router.util.type:UrlMatcher#methods_exec exec}.\n\t *\n\t * Path parameter placeholders can be specified using simple colon/catch-all syntax or curly brace\n\t * syntax, which optionally allows a regular expression for the parameter to be specified:\n\t *\n\t * * `':'` name - colon placeholder\n\t * * `'*'` name - catch-all placeholder\n\t * * `'{' name '}'` - curly placeholder\n\t * * `'{' name ':' regexp|type '}'` - curly placeholder with regexp or type name. Should the\n\t *   regexp itself contain curly braces, they must be in matched pairs or escaped with a backslash.\n\t *\n\t * Parameter names may contain only word characters (latin letters, digits, and underscore) and\n\t * must be unique within the pattern (across both path and search parameters). For colon\n\t * placeholders or curly placeholders without an explicit regexp, a path parameter matches any\n\t * number of characters other than '/'. For catch-all placeholders the path parameter matches\n\t * any number of characters.\n\t *\n\t * Examples:\n\t *\n\t * * `'/hello/'` - Matches only if the path is exactly '/hello/'. There is no special treatment for\n\t *   trailing slashes, and patterns have to match the entire path, not just a prefix.\n\t * * `'/user/:id'` - Matches '/user/bob' or '/user/1234!!!' or even '/user/' but not '/user' or\n\t *   '/user/bob/details'. The second path segment will be captured as the parameter 'id'.\n\t * * `'/user/{id}'` - Same as the previous example, but using curly brace syntax.\n\t * * `'/user/{id:[^/]*}'` - Same as the previous example.\n\t * * `'/user/{id:[0-9a-fA-F]{1,8}}'` - Similar to the previous example, but only matches if the id\n\t *   parameter consists of 1 to 8 hex digits.\n\t * * `'/files/{path:.*}'` - Matches any URL starting with '/files/' and captures the rest of the\n\t *   path into the parameter 'path'.\n\t * * `'/files/*path'` - ditto.\n\t * * `'/calendar/{start:date}'` - Matches \"/calendar/2014-11-12\" (because the pattern defined\n\t *   in the built-in  `date` Type matches `2014-11-12`) and provides a Date object in $stateParams.start\n\t *\n\t * @param {string} pattern  The pattern to compile into a matcher.\n\t * @param {Object} config  A configuration object hash:\n\t * @param {Object=} parentMatcher Used to concatenate the pattern/config onto\n\t *   an existing UrlMatcher\n\t *\n\t * * `caseInsensitive` - `true` if URL matching should be case insensitive, otherwise `false`, the default value (for backward compatibility) is `false`.\n\t * * `strict` - `false` if matching against a URL with a trailing slash should be treated as equivalent to a URL without a trailing slash, the default value is `true`.\n\t *\n\t * @property {string} prefix  A static prefix of this pattern. The matcher guarantees that any\n\t *   URL matching this matcher (i.e. any string for which {@link ui.router.util.type:UrlMatcher#methods_exec exec()} returns\n\t *   non-null) will start with this prefix.\n\t *\n\t * @property {string} source  The pattern that was passed into the constructor\n\t *\n\t * @property {string} sourcePath  The path portion of the source property\n\t *\n\t * @property {string} sourceSearch  The search portion of the source property\n\t *\n\t * @property {string} regex  The constructed regex that will be used to match against the url when\n\t *   it is time to determine which url will match.\n\t *\n\t * @returns {Object}  New `UrlMatcher` object\n\t */\n\tfunction UrlMatcher(pattern, config, parentMatcher) {\n\t  config = extend({ params: {} }, isObject(config) ? config : {});\n\t\n\t  // Find all placeholders and create a compiled pattern, using either classic or curly syntax:\n\t  //   '*' name\n\t  //   ':' name\n\t  //   '{' name '}'\n\t  //   '{' name ':' regexp '}'\n\t  // The regular expression is somewhat complicated due to the need to allow curly braces\n\t  // inside the regular expression. The placeholder regexp breaks down as follows:\n\t  //    ([:*])([\\w\\[\\]]+)              - classic placeholder ($1 / $2) (search version has - for snake-case)\n\t  //    \\{([\\w\\[\\]]+)(?:\\:\\s*( ... ))?\\}  - curly brace placeholder ($3) with optional regexp/type ... ($4) (search version has - for snake-case\n\t  //    (?: ... | ... | ... )+         - the regexp consists of any number of atoms, an atom being either\n\t  //    [^{}\\\\]+                       - anything other than curly braces or backslash\n\t  //    \\\\.                            - a backslash escape\n\t  //    \\{(?:[^{}\\\\]+|\\\\.)*\\}          - a matched set of curly braces containing other atoms\n\t  var placeholder       = /([:*])([\\w\\[\\]]+)|\\{([\\w\\[\\]]+)(?:\\:\\s*((?:[^{}\\\\]+|\\\\.|\\{(?:[^{}\\\\]+|\\\\.)*\\})+))?\\}/g,\n\t      searchPlaceholder = /([:]?)([\\w\\[\\].-]+)|\\{([\\w\\[\\].-]+)(?:\\:\\s*((?:[^{}\\\\]+|\\\\.|\\{(?:[^{}\\\\]+|\\\\.)*\\})+))?\\}/g,\n\t      compiled = '^', last = 0, m,\n\t      segments = this.segments = [],\n\t      parentParams = parentMatcher ? parentMatcher.params : {},\n\t      params = this.params = parentMatcher ? parentMatcher.params.$$new() : new $$UMFP.ParamSet(),\n\t      paramNames = [];\n\t\n\t  function addParameter(id, type, config, location) {\n\t    paramNames.push(id);\n\t    if (parentParams[id]) return parentParams[id];\n\t    if (!/^\\w+([-.]+\\w+)*(?:\\[\\])?$/.test(id)) throw new Error(\"Invalid parameter name '\" + id + \"' in pattern '\" + pattern + \"'\");\n\t    if (params[id]) throw new Error(\"Duplicate parameter name '\" + id + \"' in pattern '\" + pattern + \"'\");\n\t    params[id] = new $$UMFP.Param(id, type, config, location);\n\t    return params[id];\n\t  }\n\t\n\t  function quoteRegExp(string, pattern, squash, optional) {\n\t    var surroundPattern = ['',''], result = string.replace(/[\\\\\\[\\]\\^$*+?.()|{}]/g, \"\\\\$&\");\n\t    if (!pattern) return result;\n\t    switch(squash) {\n\t      case false: surroundPattern = ['(', ')' + (optional ? \"?\" : \"\")]; break;\n\t      case true:\n\t        result = result.replace(/\\/$/, '');\n\t        surroundPattern = ['(?:\\/(', ')|\\/)?'];\n\t      break;\n\t      default:    surroundPattern = ['(' + squash + \"|\", ')?']; break;\n\t    }\n\t    return result + surroundPattern[0] + pattern + surroundPattern[1];\n\t  }\n\t\n\t  this.source = pattern;\n\t\n\t  // Split into static segments separated by path parameter placeholders.\n\t  // The number of segments is always 1 more than the number of parameters.\n\t  function matchDetails(m, isSearch) {\n\t    var id, regexp, segment, type, cfg, arrayMode;\n\t    id          = m[2] || m[3]; // IE[78] returns '' for unmatched groups instead of null\n\t    cfg         = config.params[id];\n\t    segment     = pattern.substring(last, m.index);\n\t    regexp      = isSearch ? m[4] : m[4] || (m[1] == '*' ? '.*' : null);\n\t\n\t    if (regexp) {\n\t      type      = $$UMFP.type(regexp) || inherit($$UMFP.type(\"string\"), { pattern: new RegExp(regexp, config.caseInsensitive ? 'i' : undefined) });\n\t    }\n\t\n\t    return {\n\t      id: id, regexp: regexp, segment: segment, type: type, cfg: cfg\n\t    };\n\t  }\n\t\n\t  var p, param, segment;\n\t  while ((m = placeholder.exec(pattern))) {\n\t    p = matchDetails(m, false);\n\t    if (p.segment.indexOf('?') >= 0) break; // we're into the search part\n\t\n\t    param = addParameter(p.id, p.type, p.cfg, \"path\");\n\t    compiled += quoteRegExp(p.segment, param.type.pattern.source, param.squash, param.isOptional);\n\t    segments.push(p.segment);\n\t    last = placeholder.lastIndex;\n\t  }\n\t  segment = pattern.substring(last);\n\t\n\t  // Find any search parameter names and remove them from the last segment\n\t  var i = segment.indexOf('?');\n\t\n\t  if (i >= 0) {\n\t    var search = this.sourceSearch = segment.substring(i);\n\t    segment = segment.substring(0, i);\n\t    this.sourcePath = pattern.substring(0, last + i);\n\t\n\t    if (search.length > 0) {\n\t      last = 0;\n\t      while ((m = searchPlaceholder.exec(search))) {\n\t        p = matchDetails(m, true);\n\t        param = addParameter(p.id, p.type, p.cfg, \"search\");\n\t        last = placeholder.lastIndex;\n\t        // check if ?&\n\t      }\n\t    }\n\t  } else {\n\t    this.sourcePath = pattern;\n\t    this.sourceSearch = '';\n\t  }\n\t\n\t  compiled += quoteRegExp(segment) + (config.strict === false ? '\\/?' : '') + '$';\n\t  segments.push(segment);\n\t\n\t  this.regexp = new RegExp(compiled, config.caseInsensitive ? 'i' : undefined);\n\t  this.prefix = segments[0];\n\t  this.$$paramNames = paramNames;\n\t}\n\t\n\t/**\n\t * @ngdoc function\n\t * @name ui.router.util.type:UrlMatcher#concat\n\t * @methodOf ui.router.util.type:UrlMatcher\n\t *\n\t * @description\n\t * Returns a new matcher for a pattern constructed by appending the path part and adding the\n\t * search parameters of the specified pattern to this pattern. The current pattern is not\n\t * modified. This can be understood as creating a pattern for URLs that are relative to (or\n\t * suffixes of) the current pattern.\n\t *\n\t * @example\n\t * The following two matchers are equivalent:\n\t * <pre>\n\t * new UrlMatcher('/user/{id}?q').concat('/details?date');\n\t * new UrlMatcher('/user/{id}/details?q&date');\n\t * </pre>\n\t *\n\t * @param {string} pattern  The pattern to append.\n\t * @param {Object} config  An object hash of the configuration for the matcher.\n\t * @returns {UrlMatcher}  A matcher for the concatenated pattern.\n\t */\n\tUrlMatcher.prototype.concat = function (pattern, config) {\n\t  // Because order of search parameters is irrelevant, we can add our own search\n\t  // parameters to the end of the new pattern. Parse the new pattern by itself\n\t  // and then join the bits together, but it's much easier to do this on a string level.\n\t  var defaultConfig = {\n\t    caseInsensitive: $$UMFP.caseInsensitive(),\n\t    strict: $$UMFP.strictMode(),\n\t    squash: $$UMFP.defaultSquashPolicy()\n\t  };\n\t  return new UrlMatcher(this.sourcePath + pattern + this.sourceSearch, extend(defaultConfig, config), this);\n\t};\n\t\n\tUrlMatcher.prototype.toString = function () {\n\t  return this.source;\n\t};\n\t\n\t/**\n\t * @ngdoc function\n\t * @name ui.router.util.type:UrlMatcher#exec\n\t * @methodOf ui.router.util.type:UrlMatcher\n\t *\n\t * @description\n\t * Tests the specified path against this matcher, and returns an object containing the captured\n\t * parameter values, or null if the path does not match. The returned object contains the values\n\t * of any search parameters that are mentioned in the pattern, but their value may be null if\n\t * they are not present in `searchParams`. This means that search parameters are always treated\n\t * as optional.\n\t *\n\t * @example\n\t * <pre>\n\t * new UrlMatcher('/user/{id}?q&r').exec('/user/bob', {\n\t *   x: '1', q: 'hello'\n\t * });\n\t * // returns { id: 'bob', q: 'hello', r: null }\n\t * </pre>\n\t *\n\t * @param {string} path  The URL path to match, e.g. `$location.path()`.\n\t * @param {Object} searchParams  URL search parameters, e.g. `$location.search()`.\n\t * @returns {Object}  The captured parameter values.\n\t */\n\tUrlMatcher.prototype.exec = function (path, searchParams) {\n\t  var m = this.regexp.exec(path);\n\t  if (!m) return null;\n\t  searchParams = searchParams || {};\n\t\n\t  var paramNames = this.parameters(), nTotal = paramNames.length,\n\t    nPath = this.segments.length - 1,\n\t    values = {}, i, j, cfg, paramName;\n\t\n\t  if (nPath !== m.length - 1) throw new Error(\"Unbalanced capture group in route '\" + this.source + \"'\");\n\t\n\t  function decodePathArray(string) {\n\t    function reverseString(str) { return str.split(\"\").reverse().join(\"\"); }\n\t    function unquoteDashes(str) { return str.replace(/\\\\-/g, \"-\"); }\n\t\n\t    var split = reverseString(string).split(/-(?!\\\\)/);\n\t    var allReversed = map(split, reverseString);\n\t    return map(allReversed, unquoteDashes).reverse();\n\t  }\n\t\n\t  var param, paramVal;\n\t  for (i = 0; i < nPath; i++) {\n\t    paramName = paramNames[i];\n\t    param = this.params[paramName];\n\t    paramVal = m[i+1];\n\t    // if the param value matches a pre-replace pair, replace the value before decoding.\n\t    for (j = 0; j < param.replace.length; j++) {\n\t      if (param.replace[j].from === paramVal) paramVal = param.replace[j].to;\n\t    }\n\t    if (paramVal && param.array === true) paramVal = decodePathArray(paramVal);\n\t    if (isDefined(paramVal)) paramVal = param.type.decode(paramVal);\n\t    values[paramName] = param.value(paramVal);\n\t  }\n\t  for (/**/; i < nTotal; i++) {\n\t    paramName = paramNames[i];\n\t    values[paramName] = this.params[paramName].value(searchParams[paramName]);\n\t    param = this.params[paramName];\n\t    paramVal = searchParams[paramName];\n\t    for (j = 0; j < param.replace.length; j++) {\n\t      if (param.replace[j].from === paramVal) paramVal = param.replace[j].to;\n\t    }\n\t    if (isDefined(paramVal)) paramVal = param.type.decode(paramVal);\n\t    values[paramName] = param.value(paramVal);\n\t  }\n\t\n\t  return values;\n\t};\n\t\n\t/**\n\t * @ngdoc function\n\t * @name ui.router.util.type:UrlMatcher#parameters\n\t * @methodOf ui.router.util.type:UrlMatcher\n\t *\n\t * @description\n\t * Returns the names of all path and search parameters of this pattern in an unspecified order.\n\t *\n\t * @returns {Array.<string>}  An array of parameter names. Must be treated as read-only. If the\n\t *    pattern has no parameters, an empty array is returned.\n\t */\n\tUrlMatcher.prototype.parameters = function (param) {\n\t  if (!isDefined(param)) return this.$$paramNames;\n\t  return this.params[param] || null;\n\t};\n\t\n\t/**\n\t * @ngdoc function\n\t * @name ui.router.util.type:UrlMatcher#validates\n\t * @methodOf ui.router.util.type:UrlMatcher\n\t *\n\t * @description\n\t * Checks an object hash of parameters to validate their correctness according to the parameter\n\t * types of this `UrlMatcher`.\n\t *\n\t * @param {Object} params The object hash of parameters to validate.\n\t * @returns {boolean} Returns `true` if `params` validates, otherwise `false`.\n\t */\n\tUrlMatcher.prototype.validates = function (params) {\n\t  return this.params.$$validates(params);\n\t};\n\t\n\t/**\n\t * @ngdoc function\n\t * @name ui.router.util.type:UrlMatcher#format\n\t * @methodOf ui.router.util.type:UrlMatcher\n\t *\n\t * @description\n\t * Creates a URL that matches this pattern by substituting the specified values\n\t * for the path and search parameters. Null values for path parameters are\n\t * treated as empty strings.\n\t *\n\t * @example\n\t * <pre>\n\t * new UrlMatcher('/user/{id}?q').format({ id:'bob', q:'yes' });\n\t * // returns '/user/bob?q=yes'\n\t * </pre>\n\t *\n\t * @param {Object} values  the values to substitute for the parameters in this pattern.\n\t * @returns {string}  the formatted URL (path and optionally search part).\n\t */\n\tUrlMatcher.prototype.format = function (values) {\n\t  values = values || {};\n\t  var segments = this.segments, params = this.parameters(), paramset = this.params;\n\t  if (!this.validates(values)) return null;\n\t\n\t  var i, search = false, nPath = segments.length - 1, nTotal = params.length, result = segments[0];\n\t\n\t  function encodeDashes(str) { // Replace dashes with encoded \"\\-\"\n\t    return encodeURIComponent(str).replace(/-/g, function(c) { return '%5C%' + c.charCodeAt(0).toString(16).toUpperCase(); });\n\t  }\n\t\n\t  for (i = 0; i < nTotal; i++) {\n\t    var isPathParam = i < nPath;\n\t    var name = params[i], param = paramset[name], value = param.value(values[name]);\n\t    var isDefaultValue = param.isOptional && param.type.equals(param.value(), value);\n\t    var squash = isDefaultValue ? param.squash : false;\n\t    var encoded = param.type.encode(value);\n\t\n\t    if (isPathParam) {\n\t      var nextSegment = segments[i + 1];\n\t      var isFinalPathParam = i + 1 === nPath;\n\t\n\t      if (squash === false) {\n\t        if (encoded != null) {\n\t          if (isArray(encoded)) {\n\t            result += map(encoded, encodeDashes).join(\"-\");\n\t          } else {\n\t            result += encodeURIComponent(encoded);\n\t          }\n\t        }\n\t        result += nextSegment;\n\t      } else if (squash === true) {\n\t        var capture = result.match(/\\/$/) ? /\\/?(.*)/ : /(.*)/;\n\t        result += nextSegment.match(capture)[1];\n\t      } else if (isString(squash)) {\n\t        result += squash + nextSegment;\n\t      }\n\t\n\t      if (isFinalPathParam && param.squash === true && result.slice(-1) === '/') result = result.slice(0, -1);\n\t    } else {\n\t      if (encoded == null || (isDefaultValue && squash !== false)) continue;\n\t      if (!isArray(encoded)) encoded = [ encoded ];\n\t      if (encoded.length === 0) continue;\n\t      encoded = map(encoded, encodeURIComponent).join('&' + name + '=');\n\t      result += (search ? '&' : '?') + (name + '=' + encoded);\n\t      search = true;\n\t    }\n\t  }\n\t\n\t  return result;\n\t};\n\t\n\t/**\n\t * @ngdoc object\n\t * @name ui.router.util.type:Type\n\t *\n\t * @description\n\t * Implements an interface to define custom parameter types that can be decoded from and encoded to\n\t * string parameters matched in a URL. Used by {@link ui.router.util.type:UrlMatcher `UrlMatcher`}\n\t * objects when matching or formatting URLs, or comparing or validating parameter values.\n\t *\n\t * See {@link ui.router.util.$urlMatcherFactory#methods_type `$urlMatcherFactory#type()`} for more\n\t * information on registering custom types.\n\t *\n\t * @param {Object} config  A configuration object which contains the custom type definition.  The object's\n\t *        properties will override the default methods and/or pattern in `Type`'s public interface.\n\t * @example\n\t * <pre>\n\t * {\n\t *   decode: function(val) { return parseInt(val, 10); },\n\t *   encode: function(val) { return val && val.toString(); },\n\t *   equals: function(a, b) { return this.is(a) && a === b; },\n\t *   is: function(val) { return angular.isNumber(val) isFinite(val) && val % 1 === 0; },\n\t *   pattern: /\\d+/\n\t * }\n\t * </pre>\n\t *\n\t * @property {RegExp} pattern The regular expression pattern used to match values of this type when\n\t *           coming from a substring of a URL.\n\t *\n\t * @returns {Object}  Returns a new `Type` object.\n\t */\n\tfunction Type(config) {\n\t  extend(this, config);\n\t}\n\t\n\t/**\n\t * @ngdoc function\n\t * @name ui.router.util.type:Type#is\n\t * @methodOf ui.router.util.type:Type\n\t *\n\t * @description\n\t * Detects whether a value is of a particular type. Accepts a native (decoded) value\n\t * and determines whether it matches the current `Type` object.\n\t *\n\t * @param {*} val  The value to check.\n\t * @param {string} key  Optional. If the type check is happening in the context of a specific\n\t *        {@link ui.router.util.type:UrlMatcher `UrlMatcher`} object, this is the name of the\n\t *        parameter in which `val` is stored. Can be used for meta-programming of `Type` objects.\n\t * @returns {Boolean}  Returns `true` if the value matches the type, otherwise `false`.\n\t */\n\tType.prototype.is = function(val, key) {\n\t  return true;\n\t};\n\t\n\t/**\n\t * @ngdoc function\n\t * @name ui.router.util.type:Type#encode\n\t * @methodOf ui.router.util.type:Type\n\t *\n\t * @description\n\t * Encodes a custom/native type value to a string that can be embedded in a URL. Note that the\n\t * return value does *not* need to be URL-safe (i.e. passed through `encodeURIComponent()`), it\n\t * only needs to be a representation of `val` that has been coerced to a string.\n\t *\n\t * @param {*} val  The value to encode.\n\t * @param {string} key  The name of the parameter in which `val` is stored. Can be used for\n\t *        meta-programming of `Type` objects.\n\t * @returns {string}  Returns a string representation of `val` that can be encoded in a URL.\n\t */\n\tType.prototype.encode = function(val, key) {\n\t  return val;\n\t};\n\t\n\t/**\n\t * @ngdoc function\n\t * @name ui.router.util.type:Type#decode\n\t * @methodOf ui.router.util.type:Type\n\t *\n\t * @description\n\t * Converts a parameter value (from URL string or transition param) to a custom/native value.\n\t *\n\t * @param {string} val  The URL parameter value to decode.\n\t * @param {string} key  The name of the parameter in which `val` is stored. Can be used for\n\t *        meta-programming of `Type` objects.\n\t * @returns {*}  Returns a custom representation of the URL parameter value.\n\t */\n\tType.prototype.decode = function(val, key) {\n\t  return val;\n\t};\n\t\n\t/**\n\t * @ngdoc function\n\t * @name ui.router.util.type:Type#equals\n\t * @methodOf ui.router.util.type:Type\n\t *\n\t * @description\n\t * Determines whether two decoded values are equivalent.\n\t *\n\t * @param {*} a  A value to compare against.\n\t * @param {*} b  A value to compare against.\n\t * @returns {Boolean}  Returns `true` if the values are equivalent/equal, otherwise `false`.\n\t */\n\tType.prototype.equals = function(a, b) {\n\t  return a == b;\n\t};\n\t\n\tType.prototype.$subPattern = function() {\n\t  var sub = this.pattern.toString();\n\t  return sub.substr(1, sub.length - 2);\n\t};\n\t\n\tType.prototype.pattern = /.*/;\n\t\n\tType.prototype.toString = function() { return \"{Type:\" + this.name + \"}\"; };\n\t\n\t/** Given an encoded string, or a decoded object, returns a decoded object */\n\tType.prototype.$normalize = function(val) {\n\t  return this.is(val) ? val : this.decode(val);\n\t};\n\t\n\t/*\n\t * Wraps an existing custom Type as an array of Type, depending on 'mode'.\n\t * e.g.:\n\t * - urlmatcher pattern \"/path?{queryParam[]:int}\"\n\t * - url: \"/path?queryParam=1&queryParam=2\n\t * - $stateParams.queryParam will be [1, 2]\n\t * if `mode` is \"auto\", then\n\t * - url: \"/path?queryParam=1 will create $stateParams.queryParam: 1\n\t * - url: \"/path?queryParam=1&queryParam=2 will create $stateParams.queryParam: [1, 2]\n\t */\n\tType.prototype.$asArray = function(mode, isSearch) {\n\t  if (!mode) return this;\n\t  if (mode === \"auto\" && !isSearch) throw new Error(\"'auto' array mode is for query parameters only\");\n\t\n\t  function ArrayType(type, mode) {\n\t    function bindTo(type, callbackName) {\n\t      return function() {\n\t        return type[callbackName].apply(type, arguments);\n\t      };\n\t    }\n\t\n\t    // Wrap non-array value as array\n\t    function arrayWrap(val) { return isArray(val) ? val : (isDefined(val) ? [ val ] : []); }\n\t    // Unwrap array value for \"auto\" mode. Return undefined for empty array.\n\t    function arrayUnwrap(val) {\n\t      switch(val.length) {\n\t        case 0: return undefined;\n\t        case 1: return mode === \"auto\" ? val[0] : val;\n\t        default: return val;\n\t      }\n\t    }\n\t    function falsey(val) { return !val; }\n\t\n\t    // Wraps type (.is/.encode/.decode) functions to operate on each value of an array\n\t    function arrayHandler(callback, allTruthyMode) {\n\t      return function handleArray(val) {\n\t        if (isArray(val) && val.length === 0) return val;\n\t        val = arrayWrap(val);\n\t        var result = map(val, callback);\n\t        if (allTruthyMode === true)\n\t          return filter(result, falsey).length === 0;\n\t        return arrayUnwrap(result);\n\t      };\n\t    }\n\t\n\t    // Wraps type (.equals) functions to operate on each value of an array\n\t    function arrayEqualsHandler(callback) {\n\t      return function handleArray(val1, val2) {\n\t        var left = arrayWrap(val1), right = arrayWrap(val2);\n\t        if (left.length !== right.length) return false;\n\t        for (var i = 0; i < left.length; i++) {\n\t          if (!callback(left[i], right[i])) return false;\n\t        }\n\t        return true;\n\t      };\n\t    }\n\t\n\t    this.encode = arrayHandler(bindTo(type, 'encode'));\n\t    this.decode = arrayHandler(bindTo(type, 'decode'));\n\t    this.is     = arrayHandler(bindTo(type, 'is'), true);\n\t    this.equals = arrayEqualsHandler(bindTo(type, 'equals'));\n\t    this.pattern = type.pattern;\n\t    this.$normalize = arrayHandler(bindTo(type, '$normalize'));\n\t    this.name = type.name;\n\t    this.$arrayMode = mode;\n\t  }\n\t\n\t  return new ArrayType(this, mode);\n\t};\n\t\n\t\n\t\n\t/**\n\t * @ngdoc object\n\t * @name ui.router.util.$urlMatcherFactory\n\t *\n\t * @description\n\t * Factory for {@link ui.router.util.type:UrlMatcher `UrlMatcher`} instances. The factory\n\t * is also available to providers under the name `$urlMatcherFactoryProvider`.\n\t */\n\tfunction $UrlMatcherFactory() {\n\t  $$UMFP = this;\n\t\n\t  var isCaseInsensitive = false, isStrictMode = true, defaultSquashPolicy = false;\n\t\n\t  // Use tildes to pre-encode slashes.\n\t  // If the slashes are simply URLEncoded, the browser can choose to pre-decode them,\n\t  // and bidirectional encoding/decoding fails.\n\t  // Tilde was chosen because it's not a RFC 3986 section 2.2 Reserved Character\n\t  function valToString(val) { return val != null ? val.toString().replace(/~/g, \"~~\").replace(/\\//g, \"~2F\") : val; }\n\t  function valFromString(val) { return val != null ? val.toString().replace(/~2F/g, \"/\").replace(/~~/g, \"~\") : val; }\n\t\n\t  var $types = {}, enqueue = true, typeQueue = [], injector, defaultTypes = {\n\t    \"string\": {\n\t      encode: valToString,\n\t      decode: valFromString,\n\t      // TODO: in 1.0, make string .is() return false if value is undefined/null by default.\n\t      // In 0.2.x, string params are optional by default for backwards compat\n\t      is: function(val) { return val == null || !isDefined(val) || typeof val === \"string\"; },\n\t      pattern: /[^/]*/\n\t    },\n\t    \"int\": {\n\t      encode: valToString,\n\t      decode: function(val) { return parseInt(val, 10); },\n\t      is: function(val) { return isDefined(val) && this.decode(val.toString()) === val; },\n\t      pattern: /\\d+/\n\t    },\n\t    \"bool\": {\n\t      encode: function(val) { return val ? 1 : 0; },\n\t      decode: function(val) { return parseInt(val, 10) !== 0; },\n\t      is: function(val) { return val === true || val === false; },\n\t      pattern: /0|1/\n\t    },\n\t    \"date\": {\n\t      encode: function (val) {\n\t        if (!this.is(val))\n\t          return undefined;\n\t        return [ val.getFullYear(),\n\t          ('0' + (val.getMonth() + 1)).slice(-2),\n\t          ('0' + val.getDate()).slice(-2)\n\t        ].join(\"-\");\n\t      },\n\t      decode: function (val) {\n\t        if (this.is(val)) return val;\n\t        var match = this.capture.exec(val);\n\t        return match ? new Date(match[1], match[2] - 1, match[3]) : undefined;\n\t      },\n\t      is: function(val) { return val instanceof Date && !isNaN(val.valueOf()); },\n\t      equals: function (a, b) { return this.is(a) && this.is(b) && a.toISOString() === b.toISOString(); },\n\t      pattern: /[0-9]{4}-(?:0[1-9]|1[0-2])-(?:0[1-9]|[1-2][0-9]|3[0-1])/,\n\t      capture: /([0-9]{4})-(0[1-9]|1[0-2])-(0[1-9]|[1-2][0-9]|3[0-1])/\n\t    },\n\t    \"json\": {\n\t      encode: angular.toJson,\n\t      decode: angular.fromJson,\n\t      is: angular.isObject,\n\t      equals: angular.equals,\n\t      pattern: /[^/]*/\n\t    },\n\t    \"any\": { // does not encode/decode\n\t      encode: angular.identity,\n\t      decode: angular.identity,\n\t      equals: angular.equals,\n\t      pattern: /.*/\n\t    }\n\t  };\n\t\n\t  function getDefaultConfig() {\n\t    return {\n\t      strict: isStrictMode,\n\t      caseInsensitive: isCaseInsensitive\n\t    };\n\t  }\n\t\n\t  function isInjectable(value) {\n\t    return (isFunction(value) || (isArray(value) && isFunction(value[value.length - 1])));\n\t  }\n\t\n\t  /**\n\t   * [Internal] Get the default value of a parameter, which may be an injectable function.\n\t   */\n\t  $UrlMatcherFactory.$$getDefaultValue = function(config) {\n\t    if (!isInjectable(config.value)) return config.value;\n\t    if (!injector) throw new Error(\"Injectable functions cannot be called at configuration time\");\n\t    return injector.invoke(config.value);\n\t  };\n\t\n\t  /**\n\t   * @ngdoc function\n\t   * @name ui.router.util.$urlMatcherFactory#caseInsensitive\n\t   * @methodOf ui.router.util.$urlMatcherFactory\n\t   *\n\t   * @description\n\t   * Defines whether URL matching should be case sensitive (the default behavior), or not.\n\t   *\n\t   * @param {boolean} value `false` to match URL in a case sensitive manner; otherwise `true`;\n\t   * @returns {boolean} the current value of caseInsensitive\n\t   */\n\t  this.caseInsensitive = function(value) {\n\t    if (isDefined(value))\n\t      isCaseInsensitive = value;\n\t    return isCaseInsensitive;\n\t  };\n\t\n\t  /**\n\t   * @ngdoc function\n\t   * @name ui.router.util.$urlMatcherFactory#strictMode\n\t   * @methodOf ui.router.util.$urlMatcherFactory\n\t   *\n\t   * @description\n\t   * Defines whether URLs should match trailing slashes, or not (the default behavior).\n\t   *\n\t   * @param {boolean=} value `false` to match trailing slashes in URLs, otherwise `true`.\n\t   * @returns {boolean} the current value of strictMode\n\t   */\n\t  this.strictMode = function(value) {\n\t    if (isDefined(value))\n\t      isStrictMode = value;\n\t    return isStrictMode;\n\t  };\n\t\n\t  /**\n\t   * @ngdoc function\n\t   * @name ui.router.util.$urlMatcherFactory#defaultSquashPolicy\n\t   * @methodOf ui.router.util.$urlMatcherFactory\n\t   *\n\t   * @description\n\t   * Sets the default behavior when generating or matching URLs with default parameter values.\n\t   *\n\t   * @param {string} value A string that defines the default parameter URL squashing behavior.\n\t   *    `nosquash`: When generating an href with a default parameter value, do not squash the parameter value from the URL\n\t   *    `slash`: When generating an href with a default parameter value, squash (remove) the parameter value, and, if the\n\t   *             parameter is surrounded by slashes, squash (remove) one slash from the URL\n\t   *    any other string, e.g. \"~\": When generating an href with a default parameter value, squash (remove)\n\t   *             the parameter value from the URL and replace it with this string.\n\t   */\n\t  this.defaultSquashPolicy = function(value) {\n\t    if (!isDefined(value)) return defaultSquashPolicy;\n\t    if (value !== true && value !== false && !isString(value))\n\t      throw new Error(\"Invalid squash policy: \" + value + \". Valid policies: false, true, arbitrary-string\");\n\t    defaultSquashPolicy = value;\n\t    return value;\n\t  };\n\t\n\t  /**\n\t   * @ngdoc function\n\t   * @name ui.router.util.$urlMatcherFactory#compile\n\t   * @methodOf ui.router.util.$urlMatcherFactory\n\t   *\n\t   * @description\n\t   * Creates a {@link ui.router.util.type:UrlMatcher `UrlMatcher`} for the specified pattern.\n\t   *\n\t   * @param {string} pattern  The URL pattern.\n\t   * @param {Object} config  The config object hash.\n\t   * @returns {UrlMatcher}  The UrlMatcher.\n\t   */\n\t  this.compile = function (pattern, config) {\n\t    return new UrlMatcher(pattern, extend(getDefaultConfig(), config));\n\t  };\n\t\n\t  /**\n\t   * @ngdoc function\n\t   * @name ui.router.util.$urlMatcherFactory#isMatcher\n\t   * @methodOf ui.router.util.$urlMatcherFactory\n\t   *\n\t   * @description\n\t   * Returns true if the specified object is a `UrlMatcher`, or false otherwise.\n\t   *\n\t   * @param {Object} object  The object to perform the type check against.\n\t   * @returns {Boolean}  Returns `true` if the object matches the `UrlMatcher` interface, by\n\t   *          implementing all the same methods.\n\t   */\n\t  this.isMatcher = function (o) {\n\t    if (!isObject(o)) return false;\n\t    var result = true;\n\t\n\t    forEach(UrlMatcher.prototype, function(val, name) {\n\t      if (isFunction(val)) {\n\t        result = result && (isDefined(o[name]) && isFunction(o[name]));\n\t      }\n\t    });\n\t    return result;\n\t  };\n\t\n\t  /**\n\t   * @ngdoc function\n\t   * @name ui.router.util.$urlMatcherFactory#type\n\t   * @methodOf ui.router.util.$urlMatcherFactory\n\t   *\n\t   * @description\n\t   * Registers a custom {@link ui.router.util.type:Type `Type`} object that can be used to\n\t   * generate URLs with typed parameters.\n\t   *\n\t   * @param {string} name  The type name.\n\t   * @param {Object|Function} definition   The type definition. See\n\t   *        {@link ui.router.util.type:Type `Type`} for information on the values accepted.\n\t   * @param {Object|Function} definitionFn (optional) A function that is injected before the app\n\t   *        runtime starts.  The result of this function is merged into the existing `definition`.\n\t   *        See {@link ui.router.util.type:Type `Type`} for information on the values accepted.\n\t   *\n\t   * @returns {Object}  Returns `$urlMatcherFactoryProvider`.\n\t   *\n\t   * @example\n\t   * This is a simple example of a custom type that encodes and decodes items from an\n\t   * array, using the array index as the URL-encoded value:\n\t   *\n\t   * <pre>\n\t   * var list = ['John', 'Paul', 'George', 'Ringo'];\n\t   *\n\t   * $urlMatcherFactoryProvider.type('listItem', {\n\t   *   encode: function(item) {\n\t   *     // Represent the list item in the URL using its corresponding index\n\t   *     return list.indexOf(item);\n\t   *   },\n\t   *   decode: function(item) {\n\t   *     // Look up the list item by index\n\t   *     return list[parseInt(item, 10)];\n\t   *   },\n\t   *   is: function(item) {\n\t   *     // Ensure the item is valid by checking to see that it appears\n\t   *     // in the list\n\t   *     return list.indexOf(item) > -1;\n\t   *   }\n\t   * });\n\t   *\n\t   * $stateProvider.state('list', {\n\t   *   url: \"/list/{item:listItem}\",\n\t   *   controller: function($scope, $stateParams) {\n\t   *     console.log($stateParams.item);\n\t   *   }\n\t   * });\n\t   *\n\t   * // ...\n\t   *\n\t   * // Changes URL to '/list/3', logs \"Ringo\" to the console\n\t   * $state.go('list', { item: \"Ringo\" });\n\t   * </pre>\n\t   *\n\t   * This is a more complex example of a type that relies on dependency injection to\n\t   * interact with services, and uses the parameter name from the URL to infer how to\n\t   * handle encoding and decoding parameter values:\n\t   *\n\t   * <pre>\n\t   * // Defines a custom type that gets a value from a service,\n\t   * // where each service gets different types of values from\n\t   * // a backend API:\n\t   * $urlMatcherFactoryProvider.type('dbObject', {}, function(Users, Posts) {\n\t   *\n\t   *   // Matches up services to URL parameter names\n\t   *   var services = {\n\t   *     user: Users,\n\t   *     post: Posts\n\t   *   };\n\t   *\n\t   *   return {\n\t   *     encode: function(object) {\n\t   *       // Represent the object in the URL using its unique ID\n\t   *       return object.id;\n\t   *     },\n\t   *     decode: function(value, key) {\n\t   *       // Look up the object by ID, using the parameter\n\t   *       // name (key) to call the correct service\n\t   *       return services[key].findById(value);\n\t   *     },\n\t   *     is: function(object, key) {\n\t   *       // Check that object is a valid dbObject\n\t   *       return angular.isObject(object) && object.id && services[key];\n\t   *     }\n\t   *     equals: function(a, b) {\n\t   *       // Check the equality of decoded objects by comparing\n\t   *       // their unique IDs\n\t   *       return a.id === b.id;\n\t   *     }\n\t   *   };\n\t   * });\n\t   *\n\t   * // In a config() block, you can then attach URLs with\n\t   * // type-annotated parameters:\n\t   * $stateProvider.state('users', {\n\t   *   url: \"/users\",\n\t   *   // ...\n\t   * }).state('users.item', {\n\t   *   url: \"/{user:dbObject}\",\n\t   *   controller: function($scope, $stateParams) {\n\t   *     // $stateParams.user will now be an object returned from\n\t   *     // the Users service\n\t   *   },\n\t   *   // ...\n\t   * });\n\t   * </pre>\n\t   */\n\t  this.type = function (name, definition, definitionFn) {\n\t    if (!isDefined(definition)) return $types[name];\n\t    if ($types.hasOwnProperty(name)) throw new Error(\"A type named '\" + name + \"' has already been defined.\");\n\t\n\t    $types[name] = new Type(extend({ name: name }, definition));\n\t    if (definitionFn) {\n\t      typeQueue.push({ name: name, def: definitionFn });\n\t      if (!enqueue) flushTypeQueue();\n\t    }\n\t    return this;\n\t  };\n\t\n\t  // `flushTypeQueue()` waits until `$urlMatcherFactory` is injected before invoking the queued `definitionFn`s\n\t  function flushTypeQueue() {\n\t    while(typeQueue.length) {\n\t      var type = typeQueue.shift();\n\t      if (type.pattern) throw new Error(\"You cannot override a type's .pattern at runtime.\");\n\t      angular.extend($types[type.name], injector.invoke(type.def));\n\t    }\n\t  }\n\t\n\t  // Register default types. Store them in the prototype of $types.\n\t  forEach(defaultTypes, function(type, name) { $types[name] = new Type(extend({name: name}, type)); });\n\t  $types = inherit($types, {});\n\t\n\t  /* No need to document $get, since it returns this */\n\t  this.$get = ['$injector', function ($injector) {\n\t    injector = $injector;\n\t    enqueue = false;\n\t    flushTypeQueue();\n\t\n\t    forEach(defaultTypes, function(type, name) {\n\t      if (!$types[name]) $types[name] = new Type(type);\n\t    });\n\t    return this;\n\t  }];\n\t\n\t  this.Param = function Param(id, type, config, location) {\n\t    var self = this;\n\t    config = unwrapShorthand(config);\n\t    type = getType(config, type, location);\n\t    var arrayMode = getArrayMode();\n\t    type = arrayMode ? type.$asArray(arrayMode, location === \"search\") : type;\n\t    if (type.name === \"string\" && !arrayMode && location === \"path\" && config.value === undefined)\n\t      config.value = \"\"; // for 0.2.x; in 0.3.0+ do not automatically default to \"\"\n\t    var isOptional = config.value !== undefined;\n\t    var squash = getSquashPolicy(config, isOptional);\n\t    var replace = getReplace(config, arrayMode, isOptional, squash);\n\t\n\t    function unwrapShorthand(config) {\n\t      var keys = isObject(config) ? objectKeys(config) : [];\n\t      var isShorthand = indexOf(keys, \"value\") === -1 && indexOf(keys, \"type\") === -1 &&\n\t                        indexOf(keys, \"squash\") === -1 && indexOf(keys, \"array\") === -1;\n\t      if (isShorthand) config = { value: config };\n\t      config.$$fn = isInjectable(config.value) ? config.value : function () { return config.value; };\n\t      return config;\n\t    }\n\t\n\t    function getType(config, urlType, location) {\n\t      if (config.type && urlType) throw new Error(\"Param '\"+id+\"' has two type configurations.\");\n\t      if (urlType) return urlType;\n\t      if (!config.type) return (location === \"config\" ? $types.any : $types.string);\n\t\n\t      if (angular.isString(config.type))\n\t        return $types[config.type];\n\t      if (config.type instanceof Type)\n\t        return config.type;\n\t      return new Type(config.type);\n\t    }\n\t\n\t    // array config: param name (param[]) overrides default settings.  explicit config overrides param name.\n\t    function getArrayMode() {\n\t      var arrayDefaults = { array: (location === \"search\" ? \"auto\" : false) };\n\t      var arrayParamNomenclature = id.match(/\\[\\]$/) ? { array: true } : {};\n\t      return extend(arrayDefaults, arrayParamNomenclature, config).array;\n\t    }\n\t\n\t    /**\n\t     * returns false, true, or the squash value to indicate the \"default parameter url squash policy\".\n\t     */\n\t    function getSquashPolicy(config, isOptional) {\n\t      var squash = config.squash;\n\t      if (!isOptional || squash === false) return false;\n\t      if (!isDefined(squash) || squash == null) return defaultSquashPolicy;\n\t      if (squash === true || isString(squash)) return squash;\n\t      throw new Error(\"Invalid squash policy: '\" + squash + \"'. Valid policies: false, true, or arbitrary string\");\n\t    }\n\t\n\t    function getReplace(config, arrayMode, isOptional, squash) {\n\t      var replace, configuredKeys, defaultPolicy = [\n\t        { from: \"\",   to: (isOptional || arrayMode ? undefined : \"\") },\n\t        { from: null, to: (isOptional || arrayMode ? undefined : \"\") }\n\t      ];\n\t      replace = isArray(config.replace) ? config.replace : [];\n\t      if (isString(squash))\n\t        replace.push({ from: squash, to: undefined });\n\t      configuredKeys = map(replace, function(item) { return item.from; } );\n\t      return filter(defaultPolicy, function(item) { return indexOf(configuredKeys, item.from) === -1; }).concat(replace);\n\t    }\n\t\n\t    /**\n\t     * [Internal] Get the default value of a parameter, which may be an injectable function.\n\t     */\n\t    function $$getDefaultValue() {\n\t      if (!injector) throw new Error(\"Injectable functions cannot be called at configuration time\");\n\t      var defaultValue = injector.invoke(config.$$fn);\n\t      if (defaultValue !== null && defaultValue !== undefined && !self.type.is(defaultValue))\n\t        throw new Error(\"Default value (\" + defaultValue + \") for parameter '\" + self.id + \"' is not an instance of Type (\" + self.type.name + \")\");\n\t      return defaultValue;\n\t    }\n\t\n\t    /**\n\t     * [Internal] Gets the decoded representation of a value if the value is defined, otherwise, returns the\n\t     * default value, which may be the result of an injectable function.\n\t     */\n\t    function $value(value) {\n\t      function hasReplaceVal(val) { return function(obj) { return obj.from === val; }; }\n\t      function $replace(value) {\n\t        var replacement = map(filter(self.replace, hasReplaceVal(value)), function(obj) { return obj.to; });\n\t        return replacement.length ? replacement[0] : value;\n\t      }\n\t      value = $replace(value);\n\t      return !isDefined(value) ? $$getDefaultValue() : self.type.$normalize(value);\n\t    }\n\t\n\t    function toString() { return \"{Param:\" + id + \" \" + type + \" squash: '\" + squash + \"' optional: \" + isOptional + \"}\"; }\n\t\n\t    extend(this, {\n\t      id: id,\n\t      type: type,\n\t      location: location,\n\t      array: arrayMode,\n\t      squash: squash,\n\t      replace: replace,\n\t      isOptional: isOptional,\n\t      value: $value,\n\t      dynamic: undefined,\n\t      config: config,\n\t      toString: toString\n\t    });\n\t  };\n\t\n\t  function ParamSet(params) {\n\t    extend(this, params || {});\n\t  }\n\t\n\t  ParamSet.prototype = {\n\t    $$new: function() {\n\t      return inherit(this, extend(new ParamSet(), { $$parent: this}));\n\t    },\n\t    $$keys: function () {\n\t      var keys = [], chain = [], parent = this,\n\t        ignore = objectKeys(ParamSet.prototype);\n\t      while (parent) { chain.push(parent); parent = parent.$$parent; }\n\t      chain.reverse();\n\t      forEach(chain, function(paramset) {\n\t        forEach(objectKeys(paramset), function(key) {\n\t            if (indexOf(keys, key) === -1 && indexOf(ignore, key) === -1) keys.push(key);\n\t        });\n\t      });\n\t      return keys;\n\t    },\n\t    $$values: function(paramValues) {\n\t      var values = {}, self = this;\n\t      forEach(self.$$keys(), function(key) {\n\t        values[key] = self[key].value(paramValues && paramValues[key]);\n\t      });\n\t      return values;\n\t    },\n\t    $$equals: function(paramValues1, paramValues2) {\n\t      var equal = true, self = this;\n\t      forEach(self.$$keys(), function(key) {\n\t        var left = paramValues1 && paramValues1[key], right = paramValues2 && paramValues2[key];\n\t        if (!self[key].type.equals(left, right)) equal = false;\n\t      });\n\t      return equal;\n\t    },\n\t    $$validates: function $$validate(paramValues) {\n\t      var keys = this.$$keys(), i, param, rawVal, normalized, encoded;\n\t      for (i = 0; i < keys.length; i++) {\n\t        param = this[keys[i]];\n\t        rawVal = paramValues[keys[i]];\n\t        if ((rawVal === undefined || rawVal === null) && param.isOptional)\n\t          break; // There was no parameter value, but the param is optional\n\t        normalized = param.type.$normalize(rawVal);\n\t        if (!param.type.is(normalized))\n\t          return false; // The value was not of the correct Type, and could not be decoded to the correct Type\n\t        encoded = param.type.encode(normalized);\n\t        if (angular.isString(encoded) && !param.type.pattern.exec(encoded))\n\t          return false; // The value was of the correct type, but when encoded, did not match the Type's regexp\n\t      }\n\t      return true;\n\t    },\n\t    $$parent: undefined\n\t  };\n\t\n\t  this.ParamSet = ParamSet;\n\t}\n\t\n\t// Register as a provider so it's available to other providers\n\tangular.module('ui.router.util').provider('$urlMatcherFactory', $UrlMatcherFactory);\n\tangular.module('ui.router.util').run(['$urlMatcherFactory', function($urlMatcherFactory) { }]);\n\t\n\t/**\n\t * @ngdoc object\n\t * @name ui.router.router.$urlRouterProvider\n\t *\n\t * @requires ui.router.util.$urlMatcherFactoryProvider\n\t * @requires $locationProvider\n\t *\n\t * @description\n\t * `$urlRouterProvider` has the responsibility of watching `$location`. \n\t * When `$location` changes it runs through a list of rules one by one until a \n\t * match is found. `$urlRouterProvider` is used behind the scenes anytime you specify \n\t * a url in a state configuration. All urls are compiled into a UrlMatcher object.\n\t *\n\t * There are several methods on `$urlRouterProvider` that make it useful to use directly\n\t * in your module config.\n\t */\n\t$UrlRouterProvider.$inject = ['$locationProvider', '$urlMatcherFactoryProvider'];\n\tfunction $UrlRouterProvider(   $locationProvider,   $urlMatcherFactory) {\n\t  var rules = [], otherwise = null, interceptDeferred = false, listener;\n\t\n\t  // Returns a string that is a prefix of all strings matching the RegExp\n\t  function regExpPrefix(re) {\n\t    var prefix = /^\\^((?:\\\\[^a-zA-Z0-9]|[^\\\\\\[\\]\\^$*+?.()|{}]+)*)/.exec(re.source);\n\t    return (prefix != null) ? prefix[1].replace(/\\\\(.)/g, \"$1\") : '';\n\t  }\n\t\n\t  // Interpolates matched values into a String.replace()-style pattern\n\t  function interpolate(pattern, match) {\n\t    return pattern.replace(/\\$(\\$|\\d{1,2})/, function (m, what) {\n\t      return match[what === '$' ? 0 : Number(what)];\n\t    });\n\t  }\n\t\n\t  /**\n\t   * @ngdoc function\n\t   * @name ui.router.router.$urlRouterProvider#rule\n\t   * @methodOf ui.router.router.$urlRouterProvider\n\t   *\n\t   * @description\n\t   * Defines rules that are used by `$urlRouterProvider` to find matches for\n\t   * specific URLs.\n\t   *\n\t   * @example\n\t   * <pre>\n\t   * var app = angular.module('app', ['ui.router.router']);\n\t   *\n\t   * app.config(function ($urlRouterProvider) {\n\t   *   // Here's an example of how you might allow case insensitive urls\n\t   *   $urlRouterProvider.rule(function ($injector, $location) {\n\t   *     var path = $location.path(),\n\t   *         normalized = path.toLowerCase();\n\t   *\n\t   *     if (path !== normalized) {\n\t   *       return normalized;\n\t   *     }\n\t   *   });\n\t   * });\n\t   * </pre>\n\t   *\n\t   * @param {function} rule Handler function that takes `$injector` and `$location`\n\t   * services as arguments. You can use them to return a valid path as a string.\n\t   *\n\t   * @return {object} `$urlRouterProvider` - `$urlRouterProvider` instance\n\t   */\n\t  this.rule = function (rule) {\n\t    if (!isFunction(rule)) throw new Error(\"'rule' must be a function\");\n\t    rules.push(rule);\n\t    return this;\n\t  };\n\t\n\t  /**\n\t   * @ngdoc object\n\t   * @name ui.router.router.$urlRouterProvider#otherwise\n\t   * @methodOf ui.router.router.$urlRouterProvider\n\t   *\n\t   * @description\n\t   * Defines a path that is used when an invalid route is requested.\n\t   *\n\t   * @example\n\t   * <pre>\n\t   * var app = angular.module('app', ['ui.router.router']);\n\t   *\n\t   * app.config(function ($urlRouterProvider) {\n\t   *   // if the path doesn't match any of the urls you configured\n\t   *   // otherwise will take care of routing the user to the\n\t   *   // specified url\n\t   *   $urlRouterProvider.otherwise('/index');\n\t   *\n\t   *   // Example of using function rule as param\n\t   *   $urlRouterProvider.otherwise(function ($injector, $location) {\n\t   *     return '/a/valid/url';\n\t   *   });\n\t   * });\n\t   * </pre>\n\t   *\n\t   * @param {string|function} rule The url path you want to redirect to or a function \n\t   * rule that returns the url path. The function version is passed two params: \n\t   * `$injector` and `$location` services, and must return a url string.\n\t   *\n\t   * @return {object} `$urlRouterProvider` - `$urlRouterProvider` instance\n\t   */\n\t  this.otherwise = function (rule) {\n\t    if (isString(rule)) {\n\t      var redirect = rule;\n\t      rule = function () { return redirect; };\n\t    }\n\t    else if (!isFunction(rule)) throw new Error(\"'rule' must be a function\");\n\t    otherwise = rule;\n\t    return this;\n\t  };\n\t\n\t\n\t  function handleIfMatch($injector, handler, match) {\n\t    if (!match) return false;\n\t    var result = $injector.invoke(handler, handler, { $match: match });\n\t    return isDefined(result) ? result : true;\n\t  }\n\t\n\t  /**\n\t   * @ngdoc function\n\t   * @name ui.router.router.$urlRouterProvider#when\n\t   * @methodOf ui.router.router.$urlRouterProvider\n\t   *\n\t   * @description\n\t   * Registers a handler for a given url matching. \n\t   * \n\t   * If the handler is a string, it is\n\t   * treated as a redirect, and is interpolated according to the syntax of match\n\t   * (i.e. like `String.replace()` for `RegExp`, or like a `UrlMatcher` pattern otherwise).\n\t   *\n\t   * If the handler is a function, it is injectable. It gets invoked if `$location`\n\t   * matches. You have the option of inject the match object as `$match`.\n\t   *\n\t   * The handler can return\n\t   *\n\t   * - **falsy** to indicate that the rule didn't match after all, then `$urlRouter`\n\t   *   will continue trying to find another one that matches.\n\t   * - **string** which is treated as a redirect and passed to `$location.url()`\n\t   * - **void** or any **truthy** value tells `$urlRouter` that the url was handled.\n\t   *\n\t   * @example\n\t   * <pre>\n\t   * var app = angular.module('app', ['ui.router.router']);\n\t   *\n\t   * app.config(function ($urlRouterProvider) {\n\t   *   $urlRouterProvider.when($state.url, function ($match, $stateParams) {\n\t   *     if ($state.$current.navigable !== state ||\n\t   *         !equalForKeys($match, $stateParams) {\n\t   *      $state.transitionTo(state, $match, false);\n\t   *     }\n\t   *   });\n\t   * });\n\t   * </pre>\n\t   *\n\t   * @param {string|object} what The incoming path that you want to redirect.\n\t   * @param {string|function} handler The path you want to redirect your user to.\n\t   */\n\t  this.when = function (what, handler) {\n\t    var redirect, handlerIsString = isString(handler);\n\t    if (isString(what)) what = $urlMatcherFactory.compile(what);\n\t\n\t    if (!handlerIsString && !isFunction(handler) && !isArray(handler))\n\t      throw new Error(\"invalid 'handler' in when()\");\n\t\n\t    var strategies = {\n\t      matcher: function (what, handler) {\n\t        if (handlerIsString) {\n\t          redirect = $urlMatcherFactory.compile(handler);\n\t          handler = ['$match', function ($match) { return redirect.format($match); }];\n\t        }\n\t        return extend(function ($injector, $location) {\n\t          return handleIfMatch($injector, handler, what.exec($location.path(), $location.search()));\n\t        }, {\n\t          prefix: isString(what.prefix) ? what.prefix : ''\n\t        });\n\t      },\n\t      regex: function (what, handler) {\n\t        if (what.global || what.sticky) throw new Error(\"when() RegExp must not be global or sticky\");\n\t\n\t        if (handlerIsString) {\n\t          redirect = handler;\n\t          handler = ['$match', function ($match) { return interpolate(redirect, $match); }];\n\t        }\n\t        return extend(function ($injector, $location) {\n\t          return handleIfMatch($injector, handler, what.exec($location.path()));\n\t        }, {\n\t          prefix: regExpPrefix(what)\n\t        });\n\t      }\n\t    };\n\t\n\t    var check = { matcher: $urlMatcherFactory.isMatcher(what), regex: what instanceof RegExp };\n\t\n\t    for (var n in check) {\n\t      if (check[n]) return this.rule(strategies[n](what, handler));\n\t    }\n\t\n\t    throw new Error(\"invalid 'what' in when()\");\n\t  };\n\t\n\t  /**\n\t   * @ngdoc function\n\t   * @name ui.router.router.$urlRouterProvider#deferIntercept\n\t   * @methodOf ui.router.router.$urlRouterProvider\n\t   *\n\t   * @description\n\t   * Disables (or enables) deferring location change interception.\n\t   *\n\t   * If you wish to customize the behavior of syncing the URL (for example, if you wish to\n\t   * defer a transition but maintain the current URL), call this method at configuration time.\n\t   * Then, at run time, call `$urlRouter.listen()` after you have configured your own\n\t   * `$locationChangeSuccess` event handler.\n\t   *\n\t   * @example\n\t   * <pre>\n\t   * var app = angular.module('app', ['ui.router.router']);\n\t   *\n\t   * app.config(function ($urlRouterProvider) {\n\t   *\n\t   *   // Prevent $urlRouter from automatically intercepting URL changes;\n\t   *   // this allows you to configure custom behavior in between\n\t   *   // location changes and route synchronization:\n\t   *   $urlRouterProvider.deferIntercept();\n\t   *\n\t   * }).run(function ($rootScope, $urlRouter, UserService) {\n\t   *\n\t   *   $rootScope.$on('$locationChangeSuccess', function(e) {\n\t   *     // UserService is an example service for managing user state\n\t   *     if (UserService.isLoggedIn()) return;\n\t   *\n\t   *     // Prevent $urlRouter's default handler from firing\n\t   *     e.preventDefault();\n\t   *\n\t   *     UserService.handleLogin().then(function() {\n\t   *       // Once the user has logged in, sync the current URL\n\t   *       // to the router:\n\t   *       $urlRouter.sync();\n\t   *     });\n\t   *   });\n\t   *\n\t   *   // Configures $urlRouter's listener *after* your custom listener\n\t   *   $urlRouter.listen();\n\t   * });\n\t   * </pre>\n\t   *\n\t   * @param {boolean} defer Indicates whether to defer location change interception. Passing\n\t            no parameter is equivalent to `true`.\n\t   */\n\t  this.deferIntercept = function (defer) {\n\t    if (defer === undefined) defer = true;\n\t    interceptDeferred = defer;\n\t  };\n\t\n\t  /**\n\t   * @ngdoc object\n\t   * @name ui.router.router.$urlRouter\n\t   *\n\t   * @requires $location\n\t   * @requires $rootScope\n\t   * @requires $injector\n\t   * @requires $browser\n\t   *\n\t   * @description\n\t   *\n\t   */\n\t  this.$get = $get;\n\t  $get.$inject = ['$location', '$rootScope', '$injector', '$browser', '$sniffer'];\n\t  function $get(   $location,   $rootScope,   $injector,   $browser,   $sniffer) {\n\t\n\t    var baseHref = $browser.baseHref(), location = $location.url(), lastPushedUrl;\n\t\n\t    function appendBasePath(url, isHtml5, absolute) {\n\t      if (baseHref === '/') return url;\n\t      if (isHtml5) return baseHref.slice(0, -1) + url;\n\t      if (absolute) return baseHref.slice(1) + url;\n\t      return url;\n\t    }\n\t\n\t    // TODO: Optimize groups of rules with non-empty prefix into some sort of decision tree\n\t    function update(evt) {\n\t      if (evt && evt.defaultPrevented) return;\n\t      var ignoreUpdate = lastPushedUrl && $location.url() === lastPushedUrl;\n\t      lastPushedUrl = undefined;\n\t      // TODO: Re-implement this in 1.0 for https://github.com/angular-ui/ui-router/issues/1573\n\t      //if (ignoreUpdate) return true;\n\t\n\t      function check(rule) {\n\t        var handled = rule($injector, $location);\n\t\n\t        if (!handled) return false;\n\t        if (isString(handled)) $location.replace().url(handled);\n\t        return true;\n\t      }\n\t      var n = rules.length, i;\n\t\n\t      for (i = 0; i < n; i++) {\n\t        if (check(rules[i])) return;\n\t      }\n\t      // always check otherwise last to allow dynamic updates to the set of rules\n\t      if (otherwise) check(otherwise);\n\t    }\n\t\n\t    function listen() {\n\t      listener = listener || $rootScope.$on('$locationChangeSuccess', update);\n\t      return listener;\n\t    }\n\t\n\t    if (!interceptDeferred) listen();\n\t\n\t    return {\n\t      /**\n\t       * @ngdoc function\n\t       * @name ui.router.router.$urlRouter#sync\n\t       * @methodOf ui.router.router.$urlRouter\n\t       *\n\t       * @description\n\t       * Triggers an update; the same update that happens when the address bar url changes, aka `$locationChangeSuccess`.\n\t       * This method is useful when you need to use `preventDefault()` on the `$locationChangeSuccess` event,\n\t       * perform some custom logic (route protection, auth, config, redirection, etc) and then finally proceed\n\t       * with the transition by calling `$urlRouter.sync()`.\n\t       *\n\t       * @example\n\t       * <pre>\n\t       * angular.module('app', ['ui.router'])\n\t       *   .run(function($rootScope, $urlRouter) {\n\t       *     $rootScope.$on('$locationChangeSuccess', function(evt) {\n\t       *       // Halt state change from even starting\n\t       *       evt.preventDefault();\n\t       *       // Perform custom logic\n\t       *       var meetsRequirement = ...\n\t       *       // Continue with the update and state transition if logic allows\n\t       *       if (meetsRequirement) $urlRouter.sync();\n\t       *     });\n\t       * });\n\t       * </pre>\n\t       */\n\t      sync: function() {\n\t        update();\n\t      },\n\t\n\t      listen: function() {\n\t        return listen();\n\t      },\n\t\n\t      update: function(read) {\n\t        if (read) {\n\t          location = $location.url();\n\t          return;\n\t        }\n\t        if ($location.url() === location) return;\n\t\n\t        $location.url(location);\n\t        $location.replace();\n\t      },\n\t\n\t      push: function(urlMatcher, params, options) {\n\t         var url = urlMatcher.format(params || {});\n\t\n\t        // Handle the special hash param, if needed\n\t        if (url !== null && params && params['#']) {\n\t            url += '#' + params['#'];\n\t        }\n\t\n\t        $location.url(url);\n\t        lastPushedUrl = options && options.$$avoidResync ? $location.url() : undefined;\n\t        if (options && options.replace) $location.replace();\n\t      },\n\t\n\t      /**\n\t       * @ngdoc function\n\t       * @name ui.router.router.$urlRouter#href\n\t       * @methodOf ui.router.router.$urlRouter\n\t       *\n\t       * @description\n\t       * A URL generation method that returns the compiled URL for a given\n\t       * {@link ui.router.util.type:UrlMatcher `UrlMatcher`}, populated with the provided parameters.\n\t       *\n\t       * @example\n\t       * <pre>\n\t       * $bob = $urlRouter.href(new UrlMatcher(\"/about/:person\"), {\n\t       *   person: \"bob\"\n\t       * });\n\t       * // $bob == \"/about/bob\";\n\t       * </pre>\n\t       *\n\t       * @param {UrlMatcher} urlMatcher The `UrlMatcher` object which is used as the template of the URL to generate.\n\t       * @param {object=} params An object of parameter values to fill the matcher's required parameters.\n\t       * @param {object=} options Options object. The options are:\n\t       *\n\t       * - **`absolute`** - {boolean=false},  If true will generate an absolute url, e.g. \"http://www.example.com/fullurl\".\n\t       *\n\t       * @returns {string} Returns the fully compiled URL, or `null` if `params` fail validation against `urlMatcher`\n\t       */\n\t      href: function(urlMatcher, params, options) {\n\t        if (!urlMatcher.validates(params)) return null;\n\t\n\t        var isHtml5 = $locationProvider.html5Mode();\n\t        if (angular.isObject(isHtml5)) {\n\t          isHtml5 = isHtml5.enabled;\n\t        }\n\t\n\t        isHtml5 = isHtml5 && $sniffer.history;\n\t        \n\t        var url = urlMatcher.format(params);\n\t        options = options || {};\n\t\n\t        if (!isHtml5 && url !== null) {\n\t          url = \"#\" + $locationProvider.hashPrefix() + url;\n\t        }\n\t\n\t        // Handle special hash param, if needed\n\t        if (url !== null && params && params['#']) {\n\t          url += '#' + params['#'];\n\t        }\n\t\n\t        url = appendBasePath(url, isHtml5, options.absolute);\n\t\n\t        if (!options.absolute || !url) {\n\t          return url;\n\t        }\n\t\n\t        var slash = (!isHtml5 && url ? '/' : ''), port = $location.port();\n\t        port = (port === 80 || port === 443 ? '' : ':' + port);\n\t\n\t        return [$location.protocol(), '://', $location.host(), port, slash, url].join('');\n\t      }\n\t    };\n\t  }\n\t}\n\t\n\tangular.module('ui.router.router').provider('$urlRouter', $UrlRouterProvider);\n\t\n\t/**\n\t * @ngdoc object\n\t * @name ui.router.state.$stateProvider\n\t *\n\t * @requires ui.router.router.$urlRouterProvider\n\t * @requires ui.router.util.$urlMatcherFactoryProvider\n\t *\n\t * @description\n\t * The new `$stateProvider` works similar to Angular's v1 router, but it focuses purely\n\t * on state.\n\t *\n\t * A state corresponds to a \"place\" in the application in terms of the overall UI and\n\t * navigation. A state describes (via the controller / template / view properties) what\n\t * the UI looks like and does at that place.\n\t *\n\t * States often have things in common, and the primary way of factoring out these\n\t * commonalities in this model is via the state hierarchy, i.e. parent/child states aka\n\t * nested states.\n\t *\n\t * The `$stateProvider` provides interfaces to declare these states for your app.\n\t */\n\t$StateProvider.$inject = ['$urlRouterProvider', '$urlMatcherFactoryProvider'];\n\tfunction $StateProvider(   $urlRouterProvider,   $urlMatcherFactory) {\n\t\n\t  var root, states = {}, $state, queue = {}, abstractKey = 'abstract';\n\t\n\t  // Builds state properties from definition passed to registerState()\n\t  var stateBuilder = {\n\t\n\t    // Derive parent state from a hierarchical name only if 'parent' is not explicitly defined.\n\t    // state.children = [];\n\t    // if (parent) parent.children.push(state);\n\t    parent: function(state) {\n\t      if (isDefined(state.parent) && state.parent) return findState(state.parent);\n\t      // regex matches any valid composite state name\n\t      // would match \"contact.list\" but not \"contacts\"\n\t      var compositeName = /^(.+)\\.[^.]+$/.exec(state.name);\n\t      return compositeName ? findState(compositeName[1]) : root;\n\t    },\n\t\n\t    // inherit 'data' from parent and override by own values (if any)\n\t    data: function(state) {\n\t      if (state.parent && state.parent.data) {\n\t        state.data = state.self.data = inherit(state.parent.data, state.data);\n\t      }\n\t      return state.data;\n\t    },\n\t\n\t    // Build a URLMatcher if necessary, either via a relative or absolute URL\n\t    url: function(state) {\n\t      var url = state.url, config = { params: state.params || {} };\n\t\n\t      if (isString(url)) {\n\t        if (url.charAt(0) == '^') return $urlMatcherFactory.compile(url.substring(1), config);\n\t        return (state.parent.navigable || root).url.concat(url, config);\n\t      }\n\t\n\t      if (!url || $urlMatcherFactory.isMatcher(url)) return url;\n\t      throw new Error(\"Invalid url '\" + url + \"' in state '\" + state + \"'\");\n\t    },\n\t\n\t    // Keep track of the closest ancestor state that has a URL (i.e. is navigable)\n\t    navigable: function(state) {\n\t      return state.url ? state : (state.parent ? state.parent.navigable : null);\n\t    },\n\t\n\t    // Own parameters for this state. state.url.params is already built at this point. Create and add non-url params\n\t    ownParams: function(state) {\n\t      var params = state.url && state.url.params || new $$UMFP.ParamSet();\n\t      forEach(state.params || {}, function(config, id) {\n\t        if (!params[id]) params[id] = new $$UMFP.Param(id, null, config, \"config\");\n\t      });\n\t      return params;\n\t    },\n\t\n\t    // Derive parameters for this state and ensure they're a super-set of parent's parameters\n\t    params: function(state) {\n\t      var ownParams = pick(state.ownParams, state.ownParams.$$keys());\n\t      return state.parent && state.parent.params ? extend(state.parent.params.$$new(), ownParams) : new $$UMFP.ParamSet();\n\t    },\n\t\n\t    // If there is no explicit multi-view configuration, make one up so we don't have\n\t    // to handle both cases in the view directive later. Note that having an explicit\n\t    // 'views' property will mean the default unnamed view properties are ignored. This\n\t    // is also a good time to resolve view names to absolute names, so everything is a\n\t    // straight lookup at link time.\n\t    views: function(state) {\n\t      var views = {};\n\t\n\t      forEach(isDefined(state.views) ? state.views : { '': state }, function (view, name) {\n\t        if (name.indexOf('@') < 0) name += '@' + state.parent.name;\n\t        view.resolveAs = view.resolveAs || state.resolveAs || '$resolve';\n\t        views[name] = view;\n\t      });\n\t      return views;\n\t    },\n\t\n\t    // Keep a full path from the root down to this state as this is needed for state activation.\n\t    path: function(state) {\n\t      return state.parent ? state.parent.path.concat(state) : []; // exclude root from path\n\t    },\n\t\n\t    // Speed up $state.contains() as it's used a lot\n\t    includes: function(state) {\n\t      var includes = state.parent ? extend({}, state.parent.includes) : {};\n\t      includes[state.name] = true;\n\t      return includes;\n\t    },\n\t\n\t    $delegates: {}\n\t  };\n\t\n\t  function isRelative(stateName) {\n\t    return stateName.indexOf(\".\") === 0 || stateName.indexOf(\"^\") === 0;\n\t  }\n\t\n\t  function findState(stateOrName, base) {\n\t    if (!stateOrName) return undefined;\n\t\n\t    var isStr = isString(stateOrName),\n\t        name  = isStr ? stateOrName : stateOrName.name,\n\t        path  = isRelative(name);\n\t\n\t    if (path) {\n\t      if (!base) throw new Error(\"No reference point given for path '\"  + name + \"'\");\n\t      base = findState(base);\n\t      \n\t      var rel = name.split(\".\"), i = 0, pathLength = rel.length, current = base;\n\t\n\t      for (; i < pathLength; i++) {\n\t        if (rel[i] === \"\" && i === 0) {\n\t          current = base;\n\t          continue;\n\t        }\n\t        if (rel[i] === \"^\") {\n\t          if (!current.parent) throw new Error(\"Path '\" + name + \"' not valid for state '\" + base.name + \"'\");\n\t          current = current.parent;\n\t          continue;\n\t        }\n\t        break;\n\t      }\n\t      rel = rel.slice(i).join(\".\");\n\t      name = current.name + (current.name && rel ? \".\" : \"\") + rel;\n\t    }\n\t    var state = states[name];\n\t\n\t    if (state && (isStr || (!isStr && (state === stateOrName || state.self === stateOrName)))) {\n\t      return state;\n\t    }\n\t    return undefined;\n\t  }\n\t\n\t  function queueState(parentName, state) {\n\t    if (!queue[parentName]) {\n\t      queue[parentName] = [];\n\t    }\n\t    queue[parentName].push(state);\n\t  }\n\t\n\t  function flushQueuedChildren(parentName) {\n\t    var queued = queue[parentName] || [];\n\t    while(queued.length) {\n\t      registerState(queued.shift());\n\t    }\n\t  }\n\t\n\t  function registerState(state) {\n\t    // Wrap a new object around the state so we can store our private details easily.\n\t    state = inherit(state, {\n\t      self: state,\n\t      resolve: state.resolve || {},\n\t      toString: function() { return this.name; }\n\t    });\n\t\n\t    var name = state.name;\n\t    if (!isString(name) || name.indexOf('@') >= 0) throw new Error(\"State must have a valid name\");\n\t    if (states.hasOwnProperty(name)) throw new Error(\"State '\" + name + \"' is already defined\");\n\t\n\t    // Get parent name\n\t    var parentName = (name.indexOf('.') !== -1) ? name.substring(0, name.lastIndexOf('.'))\n\t        : (isString(state.parent)) ? state.parent\n\t        : (isObject(state.parent) && isString(state.parent.name)) ? state.parent.name\n\t        : '';\n\t\n\t    // If parent is not registered yet, add state to queue and register later\n\t    if (parentName && !states[parentName]) {\n\t      return queueState(parentName, state.self);\n\t    }\n\t\n\t    for (var key in stateBuilder) {\n\t      if (isFunction(stateBuilder[key])) state[key] = stateBuilder[key](state, stateBuilder.$delegates[key]);\n\t    }\n\t    states[name] = state;\n\t\n\t    // Register the state in the global state list and with $urlRouter if necessary.\n\t    if (!state[abstractKey] && state.url) {\n\t      $urlRouterProvider.when(state.url, ['$match', '$stateParams', function ($match, $stateParams) {\n\t        if ($state.$current.navigable != state || !equalForKeys($match, $stateParams)) {\n\t          $state.transitionTo(state, $match, { inherit: true, location: false });\n\t        }\n\t      }]);\n\t    }\n\t\n\t    // Register any queued children\n\t    flushQueuedChildren(name);\n\t\n\t    return state;\n\t  }\n\t\n\t  // Checks text to see if it looks like a glob.\n\t  function isGlob (text) {\n\t    return text.indexOf('*') > -1;\n\t  }\n\t\n\t  // Returns true if glob matches current $state name.\n\t  function doesStateMatchGlob (glob) {\n\t    var globSegments = glob.split('.'),\n\t        segments = $state.$current.name.split('.');\n\t\n\t    //match single stars\n\t    for (var i = 0, l = globSegments.length; i < l; i++) {\n\t      if (globSegments[i] === '*') {\n\t        segments[i] = '*';\n\t      }\n\t    }\n\t\n\t    //match greedy starts\n\t    if (globSegments[0] === '**') {\n\t       segments = segments.slice(indexOf(segments, globSegments[1]));\n\t       segments.unshift('**');\n\t    }\n\t    //match greedy ends\n\t    if (globSegments[globSegments.length - 1] === '**') {\n\t       segments.splice(indexOf(segments, globSegments[globSegments.length - 2]) + 1, Number.MAX_VALUE);\n\t       segments.push('**');\n\t    }\n\t\n\t    if (globSegments.length != segments.length) {\n\t      return false;\n\t    }\n\t\n\t    return segments.join('') === globSegments.join('');\n\t  }\n\t\n\t\n\t  // Implicit root state that is always active\n\t  root = registerState({\n\t    name: '',\n\t    url: '^',\n\t    views: null,\n\t    'abstract': true\n\t  });\n\t  root.navigable = null;\n\t\n\t\n\t  /**\n\t   * @ngdoc function\n\t   * @name ui.router.state.$stateProvider#decorator\n\t   * @methodOf ui.router.state.$stateProvider\n\t   *\n\t   * @description\n\t   * Allows you to extend (carefully) or override (at your own peril) the \n\t   * `stateBuilder` object used internally by `$stateProvider`. This can be used \n\t   * to add custom functionality to ui-router, for example inferring templateUrl \n\t   * based on the state name.\n\t   *\n\t   * When passing only a name, it returns the current (original or decorated) builder\n\t   * function that matches `name`.\n\t   *\n\t   * The builder functions that can be decorated are listed below. Though not all\n\t   * necessarily have a good use case for decoration, that is up to you to decide.\n\t   *\n\t   * In addition, users can attach custom decorators, which will generate new \n\t   * properties within the state's internal definition. There is currently no clear \n\t   * use-case for this beyond accessing internal states (i.e. $state.$current), \n\t   * however, expect this to become increasingly relevant as we introduce additional \n\t   * meta-programming features.\n\t   *\n\t   * **Warning**: Decorators should not be interdependent because the order of \n\t   * execution of the builder functions in non-deterministic. Builder functions \n\t   * should only be dependent on the state definition object and super function.\n\t   *\n\t   *\n\t   * Existing builder functions and current return values:\n\t   *\n\t   * - **parent** `{object}` - returns the parent state object.\n\t   * - **data** `{object}` - returns state data, including any inherited data that is not\n\t   *   overridden by own values (if any).\n\t   * - **url** `{object}` - returns a {@link ui.router.util.type:UrlMatcher UrlMatcher}\n\t   *   or `null`.\n\t   * - **navigable** `{object}` - returns closest ancestor state that has a URL (aka is \n\t   *   navigable).\n\t   * - **params** `{object}` - returns an array of state params that are ensured to \n\t   *   be a super-set of parent's params.\n\t   * - **views** `{object}` - returns a views object where each key is an absolute view \n\t   *   name (i.e. \"viewName@stateName\") and each value is the config object \n\t   *   (template, controller) for the view. Even when you don't use the views object \n\t   *   explicitly on a state config, one is still created for you internally.\n\t   *   So by decorating this builder function you have access to decorating template \n\t   *   and controller properties.\n\t   * - **ownParams** `{object}` - returns an array of params that belong to the state, \n\t   *   not including any params defined by ancestor states.\n\t   * - **path** `{string}` - returns the full path from the root down to this state. \n\t   *   Needed for state activation.\n\t   * - **includes** `{object}` - returns an object that includes every state that \n\t   *   would pass a `$state.includes()` test.\n\t   *\n\t   * @example\n\t   * <pre>\n\t   * // Override the internal 'views' builder with a function that takes the state\n\t   * // definition, and a reference to the internal function being overridden:\n\t   * $stateProvider.decorator('views', function (state, parent) {\n\t   *   var result = {},\n\t   *       views = parent(state);\n\t   *\n\t   *   angular.forEach(views, function (config, name) {\n\t   *     var autoName = (state.name + '.' + name).replace('.', '/');\n\t   *     config.templateUrl = config.templateUrl || '/partials/' + autoName + '.html';\n\t   *     result[name] = config;\n\t   *   });\n\t   *   return result;\n\t   * });\n\t   *\n\t   * $stateProvider.state('home', {\n\t   *   views: {\n\t   *     'contact.list': { controller: 'ListController' },\n\t   *     'contact.item': { controller: 'ItemController' }\n\t   *   }\n\t   * });\n\t   *\n\t   * // ...\n\t   *\n\t   * $state.go('home');\n\t   * // Auto-populates list and item views with /partials/home/contact/list.html,\n\t   * // and /partials/home/contact/item.html, respectively.\n\t   * </pre>\n\t   *\n\t   * @param {string} name The name of the builder function to decorate. \n\t   * @param {object} func A function that is responsible for decorating the original \n\t   * builder function. The function receives two parameters:\n\t   *\n\t   *   - `{object}` - state - The state config object.\n\t   *   - `{object}` - super - The original builder function.\n\t   *\n\t   * @return {object} $stateProvider - $stateProvider instance\n\t   */\n\t  this.decorator = decorator;\n\t  function decorator(name, func) {\n\t    /*jshint validthis: true */\n\t    if (isString(name) && !isDefined(func)) {\n\t      return stateBuilder[name];\n\t    }\n\t    if (!isFunction(func) || !isString(name)) {\n\t      return this;\n\t    }\n\t    if (stateBuilder[name] && !stateBuilder.$delegates[name]) {\n\t      stateBuilder.$delegates[name] = stateBuilder[name];\n\t    }\n\t    stateBuilder[name] = func;\n\t    return this;\n\t  }\n\t\n\t  /**\n\t   * @ngdoc function\n\t   * @name ui.router.state.$stateProvider#state\n\t   * @methodOf ui.router.state.$stateProvider\n\t   *\n\t   * @description\n\t   * Registers a state configuration under a given state name. The stateConfig object\n\t   * has the following acceptable properties.\n\t   *\n\t   * @param {string} name A unique state name, e.g. \"home\", \"about\", \"contacts\".\n\t   * To create a parent/child state use a dot, e.g. \"about.sales\", \"home.newest\".\n\t   * @param {object} stateConfig State configuration object.\n\t   * @param {string|function=} stateConfig.template\n\t   * <a id='template'></a>\n\t   *   html template as a string or a function that returns\n\t   *   an html template as a string which should be used by the uiView directives. This property \n\t   *   takes precedence over templateUrl.\n\t   *   \n\t   *   If `template` is a function, it will be called with the following parameters:\n\t   *\n\t   *   - {array.&lt;object&gt;} - state parameters extracted from the current $location.path() by\n\t   *     applying the current state\n\t   *\n\t   * <pre>template:\n\t   *   \"<h1>inline template definition</h1>\" +\n\t   *   \"<div ui-view></div>\"</pre>\n\t   * <pre>template: function(params) {\n\t   *       return \"<h1>generated template</h1>\"; }</pre>\n\t   * </div>\n\t   *\n\t   * @param {string|function=} stateConfig.templateUrl\n\t   * <a id='templateUrl'></a>\n\t   *\n\t   *   path or function that returns a path to an html\n\t   *   template that should be used by uiView.\n\t   *   \n\t   *   If `templateUrl` is a function, it will be called with the following parameters:\n\t   *\n\t   *   - {array.&lt;object&gt;} - state parameters extracted from the current $location.path() by \n\t   *     applying the current state\n\t   *\n\t   * <pre>templateUrl: \"home.html\"</pre>\n\t   * <pre>templateUrl: function(params) {\n\t   *     return myTemplates[params.pageId]; }</pre>\n\t   *\n\t   * @param {function=} stateConfig.templateProvider\n\t   * <a id='templateProvider'></a>\n\t   *    Provider function that returns HTML content string.\n\t   * <pre> templateProvider:\n\t   *       function(MyTemplateService, params) {\n\t   *         return MyTemplateService.getTemplate(params.pageId);\n\t   *       }</pre>\n\t   *\n\t   * @param {string|function=} stateConfig.controller\n\t   * <a id='controller'></a>\n\t   *\n\t   *  Controller fn that should be associated with newly\n\t   *   related scope or the name of a registered controller if passed as a string.\n\t   *   Optionally, the ControllerAs may be declared here.\n\t   * <pre>controller: \"MyRegisteredController\"</pre>\n\t   * <pre>controller:\n\t   *     \"MyRegisteredController as fooCtrl\"}</pre>\n\t   * <pre>controller: function($scope, MyService) {\n\t   *     $scope.data = MyService.getData(); }</pre>\n\t   *\n\t   * @param {function=} stateConfig.controllerProvider\n\t   * <a id='controllerProvider'></a>\n\t   *\n\t   * Injectable provider function that returns the actual controller or string.\n\t   * <pre>controllerProvider:\n\t   *   function(MyResolveData) {\n\t   *     if (MyResolveData.foo)\n\t   *       return \"FooCtrl\"\n\t   *     else if (MyResolveData.bar)\n\t   *       return \"BarCtrl\";\n\t   *     else return function($scope) {\n\t   *       $scope.baz = \"Qux\";\n\t   *     }\n\t   *   }</pre>\n\t   *\n\t   * @param {string=} stateConfig.controllerAs\n\t   * <a id='controllerAs'></a>\n\t   * \n\t   * A controller alias name. If present the controller will be\n\t   *   published to scope under the controllerAs name.\n\t   * <pre>controllerAs: \"myCtrl\"</pre>\n\t   *\n\t   * @param {string|object=} stateConfig.parent\n\t   * <a id='parent'></a>\n\t   * Optionally specifies the parent state of this state.\n\t   *\n\t   * <pre>parent: 'parentState'</pre>\n\t   * <pre>parent: parentState // JS variable</pre>\n\t   *\n\t   * @param {object=} stateConfig.resolve\n\t   * <a id='resolve'></a>\n\t   *\n\t   * An optional map&lt;string, function&gt; of dependencies which\n\t   *   should be injected into the controller. If any of these dependencies are promises, \n\t   *   the router will wait for them all to be resolved before the controller is instantiated.\n\t   *   If all the promises are resolved successfully, the $stateChangeSuccess event is fired\n\t   *   and the values of the resolved promises are injected into any controllers that reference them.\n\t   *   If any  of the promises are rejected the $stateChangeError event is fired.\n\t   *\n\t   *   The map object is:\n\t   *   \n\t   *   - key - {string}: name of dependency to be injected into controller\n\t   *   - factory - {string|function}: If string then it is alias for service. Otherwise if function, \n\t   *     it is injected and return value it treated as dependency. If result is a promise, it is \n\t   *     resolved before its value is injected into controller.\n\t   *\n\t   * <pre>resolve: {\n\t   *     myResolve1:\n\t   *       function($http, $stateParams) {\n\t   *         return $http.get(\"/api/foos/\"+stateParams.fooID);\n\t   *       }\n\t   *     }</pre>\n\t   *\n\t   * @param {string=} stateConfig.url\n\t   * <a id='url'></a>\n\t   *\n\t   *   A url fragment with optional parameters. When a state is navigated or\n\t   *   transitioned to, the `$stateParams` service will be populated with any \n\t   *   parameters that were passed.\n\t   *\n\t   *   (See {@link ui.router.util.type:UrlMatcher UrlMatcher} `UrlMatcher`} for\n\t   *   more details on acceptable patterns )\n\t   *\n\t   * examples:\n\t   * <pre>url: \"/home\"\n\t   * url: \"/users/:userid\"\n\t   * url: \"/books/{bookid:[a-zA-Z_-]}\"\n\t   * url: \"/books/{categoryid:int}\"\n\t   * url: \"/books/{publishername:string}/{categoryid:int}\"\n\t   * url: \"/messages?before&after\"\n\t   * url: \"/messages?{before:date}&{after:date}\"\n\t   * url: \"/messages/:mailboxid?{before:date}&{after:date}\"\n\t   * </pre>\n\t   *\n\t   * @param {object=} stateConfig.views\n\t   * <a id='views'></a>\n\t   * an optional map&lt;string, object&gt; which defined multiple views, or targets views\n\t   * manually/explicitly.\n\t   *\n\t   * Examples:\n\t   *\n\t   * Targets three named `ui-view`s in the parent state's template\n\t   * <pre>views: {\n\t   *     header: {\n\t   *       controller: \"headerCtrl\",\n\t   *       templateUrl: \"header.html\"\n\t   *     }, body: {\n\t   *       controller: \"bodyCtrl\",\n\t   *       templateUrl: \"body.html\"\n\t   *     }, footer: {\n\t   *       controller: \"footCtrl\",\n\t   *       templateUrl: \"footer.html\"\n\t   *     }\n\t   *   }</pre>\n\t   *\n\t   * Targets named `ui-view=\"header\"` from grandparent state 'top''s template, and named `ui-view=\"body\" from parent state's template.\n\t   * <pre>views: {\n\t   *     'header@top': {\n\t   *       controller: \"msgHeaderCtrl\",\n\t   *       templateUrl: \"msgHeader.html\"\n\t   *     }, 'body': {\n\t   *       controller: \"messagesCtrl\",\n\t   *       templateUrl: \"messages.html\"\n\t   *     }\n\t   *   }</pre>\n\t   *\n\t   * @param {boolean=} [stateConfig.abstract=false]\n\t   * <a id='abstract'></a>\n\t   * An abstract state will never be directly activated,\n\t   *   but can provide inherited properties to its common children states.\n\t   * <pre>abstract: true</pre>\n\t   *\n\t   * @param {function=} stateConfig.onEnter\n\t   * <a id='onEnter'></a>\n\t   *\n\t   * Callback function for when a state is entered. Good way\n\t   *   to trigger an action or dispatch an event, such as opening a dialog.\n\t   * If minifying your scripts, make sure to explicitly annotate this function,\n\t   * because it won't be automatically annotated by your build tools.\n\t   *\n\t   * <pre>onEnter: function(MyService, $stateParams) {\n\t   *     MyService.foo($stateParams.myParam);\n\t   * }</pre>\n\t   *\n\t   * @param {function=} stateConfig.onExit\n\t   * <a id='onExit'></a>\n\t   *\n\t   * Callback function for when a state is exited. Good way to\n\t   *   trigger an action or dispatch an event, such as opening a dialog.\n\t   * If minifying your scripts, make sure to explicitly annotate this function,\n\t   * because it won't be automatically annotated by your build tools.\n\t   *\n\t   * <pre>onExit: function(MyService, $stateParams) {\n\t   *     MyService.cleanup($stateParams.myParam);\n\t   * }</pre>\n\t   *\n\t   * @param {boolean=} [stateConfig.reloadOnSearch=true]\n\t   * <a id='reloadOnSearch'></a>\n\t   *\n\t   * If `false`, will not retrigger the same state\n\t   *   just because a search/query parameter has changed (via $location.search() or $location.hash()). \n\t   *   Useful for when you'd like to modify $location.search() without triggering a reload.\n\t   * <pre>reloadOnSearch: false</pre>\n\t   *\n\t   * @param {object=} stateConfig.data\n\t   * <a id='data'></a>\n\t   *\n\t   * Arbitrary data object, useful for custom configuration.  The parent state's `data` is\n\t   *   prototypally inherited.  In other words, adding a data property to a state adds it to\n\t   *   the entire subtree via prototypal inheritance.\n\t   *\n\t   * <pre>data: {\n\t   *     requiredRole: 'foo'\n\t   * } </pre>\n\t   *\n\t   * @param {object=} stateConfig.params\n\t   * <a id='params'></a>\n\t   *\n\t   * A map which optionally configures parameters declared in the `url`, or\n\t   *   defines additional non-url parameters.  For each parameter being\n\t   *   configured, add a configuration object keyed to the name of the parameter.\n\t   *\n\t   *   Each parameter configuration object may contain the following properties:\n\t   *\n\t   *   - ** value ** - {object|function=}: specifies the default value for this\n\t   *     parameter.  This implicitly sets this parameter as optional.\n\t   *\n\t   *     When UI-Router routes to a state and no value is\n\t   *     specified for this parameter in the URL or transition, the\n\t   *     default value will be used instead.  If `value` is a function,\n\t   *     it will be injected and invoked, and the return value used.\n\t   *\n\t   *     *Note*: `undefined` is treated as \"no default value\" while `null`\n\t   *     is treated as \"the default value is `null`\".\n\t   *\n\t   *     *Shorthand*: If you only need to configure the default value of the\n\t   *     parameter, you may use a shorthand syntax.   In the **`params`**\n\t   *     map, instead mapping the param name to a full parameter configuration\n\t   *     object, simply set map it to the default parameter value, e.g.:\n\t   *\n\t   * <pre>// define a parameter's default value\n\t   * params: {\n\t   *     param1: { value: \"defaultValue\" }\n\t   * }\n\t   * // shorthand default values\n\t   * params: {\n\t   *     param1: \"defaultValue\",\n\t   *     param2: \"param2Default\"\n\t   * }</pre>\n\t   *\n\t   *   - ** array ** - {boolean=}: *(default: false)* If true, the param value will be\n\t   *     treated as an array of values.  If you specified a Type, the value will be\n\t   *     treated as an array of the specified Type.  Note: query parameter values\n\t   *     default to a special `\"auto\"` mode.\n\t   *\n\t   *     For query parameters in `\"auto\"` mode, if multiple  values for a single parameter\n\t   *     are present in the URL (e.g.: `/foo?bar=1&bar=2&bar=3`) then the values\n\t   *     are mapped to an array (e.g.: `{ foo: [ '1', '2', '3' ] }`).  However, if\n\t   *     only one value is present (e.g.: `/foo?bar=1`) then the value is treated as single\n\t   *     value (e.g.: `{ foo: '1' }`).\n\t   *\n\t   * <pre>params: {\n\t   *     param1: { array: true }\n\t   * }</pre>\n\t   *\n\t   *   - ** squash ** - {bool|string=}: `squash` configures how a default parameter value is represented in the URL when\n\t   *     the current parameter value is the same as the default value. If `squash` is not set, it uses the\n\t   *     configured default squash policy.\n\t   *     (See {@link ui.router.util.$urlMatcherFactory#methods_defaultSquashPolicy `defaultSquashPolicy()`})\n\t   *\n\t   *   There are three squash settings:\n\t   *\n\t   *     - false: The parameter's default value is not squashed.  It is encoded and included in the URL\n\t   *     - true: The parameter's default value is omitted from the URL.  If the parameter is preceeded and followed\n\t   *       by slashes in the state's `url` declaration, then one of those slashes are omitted.\n\t   *       This can allow for cleaner looking URLs.\n\t   *     - `\"<arbitrary string>\"`: The parameter's default value is replaced with an arbitrary placeholder of  your choice.\n\t   *\n\t   * <pre>params: {\n\t   *     param1: {\n\t   *       value: \"defaultId\",\n\t   *       squash: true\n\t   * } }\n\t   * // squash \"defaultValue\" to \"~\"\n\t   * params: {\n\t   *     param1: {\n\t   *       value: \"defaultValue\",\n\t   *       squash: \"~\"\n\t   * } }\n\t   * </pre>\n\t   *\n\t   *\n\t   * @example\n\t   * <pre>\n\t   * // Some state name examples\n\t   *\n\t   * // stateName can be a single top-level name (must be unique).\n\t   * $stateProvider.state(\"home\", {});\n\t   *\n\t   * // Or it can be a nested state name. This state is a child of the\n\t   * // above \"home\" state.\n\t   * $stateProvider.state(\"home.newest\", {});\n\t   *\n\t   * // Nest states as deeply as needed.\n\t   * $stateProvider.state(\"home.newest.abc.xyz.inception\", {});\n\t   *\n\t   * // state() returns $stateProvider, so you can chain state declarations.\n\t   * $stateProvider\n\t   *   .state(\"home\", {})\n\t   *   .state(\"about\", {})\n\t   *   .state(\"contacts\", {});\n\t   * </pre>\n\t   *\n\t   */\n\t  this.state = state;\n\t  function state(name, definition) {\n\t    /*jshint validthis: true */\n\t    if (isObject(name)) definition = name;\n\t    else definition.name = name;\n\t    registerState(definition);\n\t    return this;\n\t  }\n\t\n\t  /**\n\t   * @ngdoc object\n\t   * @name ui.router.state.$state\n\t   *\n\t   * @requires $rootScope\n\t   * @requires $q\n\t   * @requires ui.router.state.$view\n\t   * @requires $injector\n\t   * @requires ui.router.util.$resolve\n\t   * @requires ui.router.state.$stateParams\n\t   * @requires ui.router.router.$urlRouter\n\t   *\n\t   * @property {object} params A param object, e.g. {sectionId: section.id)}, that \n\t   * you'd like to test against the current active state.\n\t   * @property {object} current A reference to the state's config object. However \n\t   * you passed it in. Useful for accessing custom data.\n\t   * @property {object} transition Currently pending transition. A promise that'll \n\t   * resolve or reject.\n\t   *\n\t   * @description\n\t   * `$state` service is responsible for representing states as well as transitioning\n\t   * between them. It also provides interfaces to ask for current state or even states\n\t   * you're coming from.\n\t   */\n\t  this.$get = $get;\n\t  $get.$inject = ['$rootScope', '$q', '$view', '$injector', '$resolve', '$stateParams', '$urlRouter', '$location', '$urlMatcherFactory'];\n\t  function $get(   $rootScope,   $q,   $view,   $injector,   $resolve,   $stateParams,   $urlRouter,   $location,   $urlMatcherFactory) {\n\t\n\t    var TransitionSuperseded = $q.reject(new Error('transition superseded'));\n\t    var TransitionPrevented = $q.reject(new Error('transition prevented'));\n\t    var TransitionAborted = $q.reject(new Error('transition aborted'));\n\t    var TransitionFailed = $q.reject(new Error('transition failed'));\n\t\n\t    // Handles the case where a state which is the target of a transition is not found, and the user\n\t    // can optionally retry or defer the transition\n\t    function handleRedirect(redirect, state, params, options) {\n\t      /**\n\t       * @ngdoc event\n\t       * @name ui.router.state.$state#$stateNotFound\n\t       * @eventOf ui.router.state.$state\n\t       * @eventType broadcast on root scope\n\t       * @description\n\t       * Fired when a requested state **cannot be found** using the provided state name during transition.\n\t       * The event is broadcast allowing any handlers a single chance to deal with the error (usually by\n\t       * lazy-loading the unfound state). A special `unfoundState` object is passed to the listener handler,\n\t       * you can see its three properties in the example. You can use `event.preventDefault()` to abort the\n\t       * transition and the promise returned from `go` will be rejected with a `'transition aborted'` value.\n\t       *\n\t       * @param {Object} event Event object.\n\t       * @param {Object} unfoundState Unfound State information. Contains: `to, toParams, options` properties.\n\t       * @param {State} fromState Current state object.\n\t       * @param {Object} fromParams Current state params.\n\t       *\n\t       * @example\n\t       *\n\t       * <pre>\n\t       * // somewhere, assume lazy.state has not been defined\n\t       * $state.go(\"lazy.state\", {a:1, b:2}, {inherit:false});\n\t       *\n\t       * // somewhere else\n\t       * $scope.$on('$stateNotFound',\n\t       * function(event, unfoundState, fromState, fromParams){\n\t       *     console.log(unfoundState.to); // \"lazy.state\"\n\t       *     console.log(unfoundState.toParams); // {a:1, b:2}\n\t       *     console.log(unfoundState.options); // {inherit:false} + default options\n\t       * })\n\t       * </pre>\n\t       */\n\t      var evt = $rootScope.$broadcast('$stateNotFound', redirect, state, params);\n\t\n\t      if (evt.defaultPrevented) {\n\t        $urlRouter.update();\n\t        return TransitionAborted;\n\t      }\n\t\n\t      if (!evt.retry) {\n\t        return null;\n\t      }\n\t\n\t      // Allow the handler to return a promise to defer state lookup retry\n\t      if (options.$retry) {\n\t        $urlRouter.update();\n\t        return TransitionFailed;\n\t      }\n\t      var retryTransition = $state.transition = $q.when(evt.retry);\n\t\n\t      retryTransition.then(function() {\n\t        if (retryTransition !== $state.transition) return TransitionSuperseded;\n\t        redirect.options.$retry = true;\n\t        return $state.transitionTo(redirect.to, redirect.toParams, redirect.options);\n\t      }, function() {\n\t        return TransitionAborted;\n\t      });\n\t      $urlRouter.update();\n\t\n\t      return retryTransition;\n\t    }\n\t\n\t    root.locals = { resolve: null, globals: { $stateParams: {} } };\n\t\n\t    $state = {\n\t      params: {},\n\t      current: root.self,\n\t      $current: root,\n\t      transition: null\n\t    };\n\t\n\t    /**\n\t     * @ngdoc function\n\t     * @name ui.router.state.$state#reload\n\t     * @methodOf ui.router.state.$state\n\t     *\n\t     * @description\n\t     * A method that force reloads the current state. All resolves are re-resolved,\n\t     * controllers reinstantiated, and events re-fired.\n\t     *\n\t     * @example\n\t     * <pre>\n\t     * var app angular.module('app', ['ui.router']);\n\t     *\n\t     * app.controller('ctrl', function ($scope, $state) {\n\t     *   $scope.reload = function(){\n\t     *     $state.reload();\n\t     *   }\n\t     * });\n\t     * </pre>\n\t     *\n\t     * `reload()` is just an alias for:\n\t     * <pre>\n\t     * $state.transitionTo($state.current, $stateParams, { \n\t     *   reload: true, inherit: false, notify: true\n\t     * });\n\t     * </pre>\n\t     *\n\t     * @param {string=|object=} state - A state name or a state object, which is the root of the resolves to be re-resolved.\n\t     * @example\n\t     * <pre>\n\t     * //assuming app application consists of 3 states: 'contacts', 'contacts.detail', 'contacts.detail.item' \n\t     * //and current state is 'contacts.detail.item'\n\t     * var app angular.module('app', ['ui.router']);\n\t     *\n\t     * app.controller('ctrl', function ($scope, $state) {\n\t     *   $scope.reload = function(){\n\t     *     //will reload 'contact.detail' and 'contact.detail.item' states\n\t     *     $state.reload('contact.detail');\n\t     *   }\n\t     * });\n\t     * </pre>\n\t     *\n\t     * `reload()` is just an alias for:\n\t     * <pre>\n\t     * $state.transitionTo($state.current, $stateParams, { \n\t     *   reload: true, inherit: false, notify: true\n\t     * });\n\t     * </pre>\n\t\n\t     * @returns {promise} A promise representing the state of the new transition. See\n\t     * {@link ui.router.state.$state#methods_go $state.go}.\n\t     */\n\t    $state.reload = function reload(state) {\n\t      return $state.transitionTo($state.current, $stateParams, { reload: state || true, inherit: false, notify: true});\n\t    };\n\t\n\t    /**\n\t     * @ngdoc function\n\t     * @name ui.router.state.$state#go\n\t     * @methodOf ui.router.state.$state\n\t     *\n\t     * @description\n\t     * Convenience method for transitioning to a new state. `$state.go` calls \n\t     * `$state.transitionTo` internally but automatically sets options to \n\t     * `{ location: true, inherit: true, relative: $state.$current, notify: true }`. \n\t     * This allows you to easily use an absolute or relative to path and specify \n\t     * only the parameters you'd like to update (while letting unspecified parameters \n\t     * inherit from the currently active ancestor states).\n\t     *\n\t     * @example\n\t     * <pre>\n\t     * var app = angular.module('app', ['ui.router']);\n\t     *\n\t     * app.controller('ctrl', function ($scope, $state) {\n\t     *   $scope.changeState = function () {\n\t     *     $state.go('contact.detail');\n\t     *   };\n\t     * });\n\t     * </pre>\n\t     * <img src='../ngdoc_assets/StateGoExamples.png'/>\n\t     *\n\t     * @param {string} to Absolute state name or relative state path. Some examples:\n\t     *\n\t     * - `$state.go('contact.detail')` - will go to the `contact.detail` state\n\t     * - `$state.go('^')` - will go to a parent state\n\t     * - `$state.go('^.sibling')` - will go to a sibling state\n\t     * - `$state.go('.child.grandchild')` - will go to grandchild state\n\t     *\n\t     * @param {object=} params A map of the parameters that will be sent to the state, \n\t     * will populate $stateParams. Any parameters that are not specified will be inherited from currently \n\t     * defined parameters. Only parameters specified in the state definition can be overridden, new \n\t     * parameters will be ignored. This allows, for example, going to a sibling state that shares parameters\n\t     * specified in a parent state. Parameter inheritance only works between common ancestor states, I.e.\n\t     * transitioning to a sibling will get you the parameters for all parents, transitioning to a child\n\t     * will get you all current parameters, etc.\n\t     * @param {object=} options Options object. The options are:\n\t     *\n\t     * - **`location`** - {boolean=true|string=} - If `true` will update the url in the location bar, if `false`\n\t     *    will not. If string, must be `\"replace\"`, which will update url and also replace last history record.\n\t     * - **`inherit`** - {boolean=true}, If `true` will inherit url parameters from current url.\n\t     * - **`relative`** - {object=$state.$current}, When transitioning with relative path (e.g '^'), \n\t     *    defines which state to be relative from.\n\t     * - **`notify`** - {boolean=true}, If `true` will broadcast $stateChangeStart and $stateChangeSuccess events.\n\t     * - **`reload`** (v0.2.5) - {boolean=false|string|object}, If `true` will force transition even if no state or params\n\t     *    have changed.  It will reload the resolves and views of the current state and parent states.\n\t     *    If `reload` is a string (or state object), the state object is fetched (by name, or object reference); and \\\n\t     *    the transition reloads the resolves and views for that matched state, and all its children states.\n\t     *\n\t     * @returns {promise} A promise representing the state of the new transition.\n\t     *\n\t     * Possible success values:\n\t     *\n\t     * - $state.current\n\t     *\n\t     * <br/>Possible rejection values:\n\t     *\n\t     * - 'transition superseded' - when a newer transition has been started after this one\n\t     * - 'transition prevented' - when `event.preventDefault()` has been called in a `$stateChangeStart` listener\n\t     * - 'transition aborted' - when `event.preventDefault()` has been called in a `$stateNotFound` listener or\n\t     *   when a `$stateNotFound` `event.retry` promise errors.\n\t     * - 'transition failed' - when a state has been unsuccessfully found after 2 tries.\n\t     * - *resolve error* - when an error has occurred with a `resolve`\n\t     *\n\t     */\n\t    $state.go = function go(to, params, options) {\n\t      return $state.transitionTo(to, params, extend({ inherit: true, relative: $state.$current }, options));\n\t    };\n\t\n\t    /**\n\t     * @ngdoc function\n\t     * @name ui.router.state.$state#transitionTo\n\t     * @methodOf ui.router.state.$state\n\t     *\n\t     * @description\n\t     * Low-level method for transitioning to a new state. {@link ui.router.state.$state#methods_go $state.go}\n\t     * uses `transitionTo` internally. `$state.go` is recommended in most situations.\n\t     *\n\t     * @example\n\t     * <pre>\n\t     * var app = angular.module('app', ['ui.router']);\n\t     *\n\t     * app.controller('ctrl', function ($scope, $state) {\n\t     *   $scope.changeState = function () {\n\t     *     $state.transitionTo('contact.detail');\n\t     *   };\n\t     * });\n\t     * </pre>\n\t     *\n\t     * @param {string} to State name.\n\t     * @param {object=} toParams A map of the parameters that will be sent to the state,\n\t     * will populate $stateParams.\n\t     * @param {object=} options Options object. The options are:\n\t     *\n\t     * - **`location`** - {boolean=true|string=} - If `true` will update the url in the location bar, if `false`\n\t     *    will not. If string, must be `\"replace\"`, which will update url and also replace last history record.\n\t     * - **`inherit`** - {boolean=false}, If `true` will inherit url parameters from current url.\n\t     * - **`relative`** - {object=}, When transitioning with relative path (e.g '^'), \n\t     *    defines which state to be relative from.\n\t     * - **`notify`** - {boolean=true}, If `true` will broadcast $stateChangeStart and $stateChangeSuccess events.\n\t     * - **`reload`** (v0.2.5) - {boolean=false|string=|object=}, If `true` will force transition even if the state or params \n\t     *    have not changed, aka a reload of the same state. It differs from reloadOnSearch because you'd\n\t     *    use this when you want to force a reload when *everything* is the same, including search params.\n\t     *    if String, then will reload the state with the name given in reload, and any children.\n\t     *    if Object, then a stateObj is expected, will reload the state found in stateObj, and any children.\n\t     *\n\t     * @returns {promise} A promise representing the state of the new transition. See\n\t     * {@link ui.router.state.$state#methods_go $state.go}.\n\t     */\n\t    $state.transitionTo = function transitionTo(to, toParams, options) {\n\t      toParams = toParams || {};\n\t      options = extend({\n\t        location: true, inherit: false, relative: null, notify: true, reload: false, $retry: false\n\t      }, options || {});\n\t\n\t      var from = $state.$current, fromParams = $state.params, fromPath = from.path;\n\t      var evt, toState = findState(to, options.relative);\n\t\n\t      // Store the hash param for later (since it will be stripped out by various methods)\n\t      var hash = toParams['#'];\n\t\n\t      if (!isDefined(toState)) {\n\t        var redirect = { to: to, toParams: toParams, options: options };\n\t        var redirectResult = handleRedirect(redirect, from.self, fromParams, options);\n\t\n\t        if (redirectResult) {\n\t          return redirectResult;\n\t        }\n\t\n\t        // Always retry once if the $stateNotFound was not prevented\n\t        // (handles either redirect changed or state lazy-definition)\n\t        to = redirect.to;\n\t        toParams = redirect.toParams;\n\t        options = redirect.options;\n\t        toState = findState(to, options.relative);\n\t\n\t        if (!isDefined(toState)) {\n\t          if (!options.relative) throw new Error(\"No such state '\" + to + \"'\");\n\t          throw new Error(\"Could not resolve '\" + to + \"' from state '\" + options.relative + \"'\");\n\t        }\n\t      }\n\t      if (toState[abstractKey]) throw new Error(\"Cannot transition to abstract state '\" + to + \"'\");\n\t      if (options.inherit) toParams = inheritParams($stateParams, toParams || {}, $state.$current, toState);\n\t      if (!toState.params.$$validates(toParams)) return TransitionFailed;\n\t\n\t      toParams = toState.params.$$values(toParams);\n\t      to = toState;\n\t\n\t      var toPath = to.path;\n\t\n\t      // Starting from the root of the path, keep all levels that haven't changed\n\t      var keep = 0, state = toPath[keep], locals = root.locals, toLocals = [];\n\t\n\t      if (!options.reload) {\n\t        while (state && state === fromPath[keep] && state.ownParams.$$equals(toParams, fromParams)) {\n\t          locals = toLocals[keep] = state.locals;\n\t          keep++;\n\t          state = toPath[keep];\n\t        }\n\t      } else if (isString(options.reload) || isObject(options.reload)) {\n\t        if (isObject(options.reload) && !options.reload.name) {\n\t          throw new Error('Invalid reload state object');\n\t        }\n\t        \n\t        var reloadState = options.reload === true ? fromPath[0] : findState(options.reload);\n\t        if (options.reload && !reloadState) {\n\t          throw new Error(\"No such reload state '\" + (isString(options.reload) ? options.reload : options.reload.name) + \"'\");\n\t        }\n\t\n\t        while (state && state === fromPath[keep] && state !== reloadState) {\n\t          locals = toLocals[keep] = state.locals;\n\t          keep++;\n\t          state = toPath[keep];\n\t        }\n\t      }\n\t\n\t      // If we're going to the same state and all locals are kept, we've got nothing to do.\n\t      // But clear 'transition', as we still want to cancel any other pending transitions.\n\t      // TODO: We may not want to bump 'transition' if we're called from a location change\n\t      // that we've initiated ourselves, because we might accidentally abort a legitimate\n\t      // transition initiated from code?\n\t      if (shouldSkipReload(to, toParams, from, fromParams, locals, options)) {\n\t        if (hash) toParams['#'] = hash;\n\t        $state.params = toParams;\n\t        copy($state.params, $stateParams);\n\t        copy(filterByKeys(to.params.$$keys(), $stateParams), to.locals.globals.$stateParams);\n\t        if (options.location && to.navigable && to.navigable.url) {\n\t          $urlRouter.push(to.navigable.url, toParams, {\n\t            $$avoidResync: true, replace: options.location === 'replace'\n\t          });\n\t          $urlRouter.update(true);\n\t        }\n\t        $state.transition = null;\n\t        return $q.when($state.current);\n\t      }\n\t\n\t      // Filter parameters before we pass them to event handlers etc.\n\t      toParams = filterByKeys(to.params.$$keys(), toParams || {});\n\t      \n\t      // Re-add the saved hash before we start returning things or broadcasting $stateChangeStart\n\t      if (hash) toParams['#'] = hash;\n\t      \n\t      // Broadcast start event and cancel the transition if requested\n\t      if (options.notify) {\n\t        /**\n\t         * @ngdoc event\n\t         * @name ui.router.state.$state#$stateChangeStart\n\t         * @eventOf ui.router.state.$state\n\t         * @eventType broadcast on root scope\n\t         * @description\n\t         * Fired when the state transition **begins**. You can use `event.preventDefault()`\n\t         * to prevent the transition from happening and then the transition promise will be\n\t         * rejected with a `'transition prevented'` value.\n\t         *\n\t         * @param {Object} event Event object.\n\t         * @param {State} toState The state being transitioned to.\n\t         * @param {Object} toParams The params supplied to the `toState`.\n\t         * @param {State} fromState The current state, pre-transition.\n\t         * @param {Object} fromParams The params supplied to the `fromState`.\n\t         *\n\t         * @example\n\t         *\n\t         * <pre>\n\t         * $rootScope.$on('$stateChangeStart',\n\t         * function(event, toState, toParams, fromState, fromParams){\n\t         *     event.preventDefault();\n\t         *     // transitionTo() promise will be rejected with\n\t         *     // a 'transition prevented' error\n\t         * })\n\t         * </pre>\n\t         */\n\t        if ($rootScope.$broadcast('$stateChangeStart', to.self, toParams, from.self, fromParams, options).defaultPrevented) {\n\t          $rootScope.$broadcast('$stateChangeCancel', to.self, toParams, from.self, fromParams);\n\t          //Don't update and resync url if there's been a new transition started. see issue #2238, #600\n\t          if ($state.transition == null) $urlRouter.update();\n\t          return TransitionPrevented;\n\t        }\n\t      }\n\t\n\t      // Resolve locals for the remaining states, but don't update any global state just\n\t      // yet -- if anything fails to resolve the current state needs to remain untouched.\n\t      // We also set up an inheritance chain for the locals here. This allows the view directive\n\t      // to quickly look up the correct definition for each view in the current state. Even\n\t      // though we create the locals object itself outside resolveState(), it is initially\n\t      // empty and gets filled asynchronously. We need to keep track of the promise for the\n\t      // (fully resolved) current locals, and pass this down the chain.\n\t      var resolved = $q.when(locals);\n\t\n\t      for (var l = keep; l < toPath.length; l++, state = toPath[l]) {\n\t        locals = toLocals[l] = inherit(locals);\n\t        resolved = resolveState(state, toParams, state === to, resolved, locals, options);\n\t      }\n\t\n\t      // Once everything is resolved, we are ready to perform the actual transition\n\t      // and return a promise for the new state. We also keep track of what the\n\t      // current promise is, so that we can detect overlapping transitions and\n\t      // keep only the outcome of the last transition.\n\t      var transition = $state.transition = resolved.then(function () {\n\t        var l, entering, exiting;\n\t\n\t        if ($state.transition !== transition) return TransitionSuperseded;\n\t\n\t        // Exit 'from' states not kept\n\t        for (l = fromPath.length - 1; l >= keep; l--) {\n\t          exiting = fromPath[l];\n\t          if (exiting.self.onExit) {\n\t            $injector.invoke(exiting.self.onExit, exiting.self, exiting.locals.globals);\n\t          }\n\t          exiting.locals = null;\n\t        }\n\t\n\t        // Enter 'to' states not kept\n\t        for (l = keep; l < toPath.length; l++) {\n\t          entering = toPath[l];\n\t          entering.locals = toLocals[l];\n\t          if (entering.self.onEnter) {\n\t            $injector.invoke(entering.self.onEnter, entering.self, entering.locals.globals);\n\t          }\n\t        }\n\t\n\t        // Run it again, to catch any transitions in callbacks\n\t        if ($state.transition !== transition) return TransitionSuperseded;\n\t\n\t        // Update globals in $state\n\t        $state.$current = to;\n\t        $state.current = to.self;\n\t        $state.params = toParams;\n\t        copy($state.params, $stateParams);\n\t        $state.transition = null;\n\t\n\t        if (options.location && to.navigable) {\n\t          $urlRouter.push(to.navigable.url, to.navigable.locals.globals.$stateParams, {\n\t            $$avoidResync: true, replace: options.location === 'replace'\n\t          });\n\t        }\n\t\n\t        if (options.notify) {\n\t        /**\n\t         * @ngdoc event\n\t         * @name ui.router.state.$state#$stateChangeSuccess\n\t         * @eventOf ui.router.state.$state\n\t         * @eventType broadcast on root scope\n\t         * @description\n\t         * Fired once the state transition is **complete**.\n\t         *\n\t         * @param {Object} event Event object.\n\t         * @param {State} toState The state being transitioned to.\n\t         * @param {Object} toParams The params supplied to the `toState`.\n\t         * @param {State} fromState The current state, pre-transition.\n\t         * @param {Object} fromParams The params supplied to the `fromState`.\n\t         */\n\t          $rootScope.$broadcast('$stateChangeSuccess', to.self, toParams, from.self, fromParams);\n\t        }\n\t        $urlRouter.update(true);\n\t\n\t        return $state.current;\n\t      }).then(null, function (error) {\n\t        if ($state.transition !== transition) return TransitionSuperseded;\n\t\n\t        $state.transition = null;\n\t        /**\n\t         * @ngdoc event\n\t         * @name ui.router.state.$state#$stateChangeError\n\t         * @eventOf ui.router.state.$state\n\t         * @eventType broadcast on root scope\n\t         * @description\n\t         * Fired when an **error occurs** during transition. It's important to note that if you\n\t         * have any errors in your resolve functions (javascript errors, non-existent services, etc)\n\t         * they will not throw traditionally. You must listen for this $stateChangeError event to\n\t         * catch **ALL** errors.\n\t         *\n\t         * @param {Object} event Event object.\n\t         * @param {State} toState The state being transitioned to.\n\t         * @param {Object} toParams The params supplied to the `toState`.\n\t         * @param {State} fromState The current state, pre-transition.\n\t         * @param {Object} fromParams The params supplied to the `fromState`.\n\t         * @param {Error} error The resolve error object.\n\t         */\n\t        evt = $rootScope.$broadcast('$stateChangeError', to.self, toParams, from.self, fromParams, error);\n\t\n\t        if (!evt.defaultPrevented) {\n\t            $urlRouter.update();\n\t        }\n\t\n\t        return $q.reject(error);\n\t      });\n\t\n\t      return transition;\n\t    };\n\t\n\t    /**\n\t     * @ngdoc function\n\t     * @name ui.router.state.$state#is\n\t     * @methodOf ui.router.state.$state\n\t     *\n\t     * @description\n\t     * Similar to {@link ui.router.state.$state#methods_includes $state.includes},\n\t     * but only checks for the full state name. If params is supplied then it will be\n\t     * tested for strict equality against the current active params object, so all params\n\t     * must match with none missing and no extras.\n\t     *\n\t     * @example\n\t     * <pre>\n\t     * $state.$current.name = 'contacts.details.item';\n\t     *\n\t     * // absolute name\n\t     * $state.is('contact.details.item'); // returns true\n\t     * $state.is(contactDetailItemStateObject); // returns true\n\t     *\n\t     * // relative name (. and ^), typically from a template\n\t     * // E.g. from the 'contacts.details' template\n\t     * <div ng-class=\"{highlighted: $state.is('.item')}\">Item</div>\n\t     * </pre>\n\t     *\n\t     * @param {string|object} stateOrName The state name (absolute or relative) or state object you'd like to check.\n\t     * @param {object=} params A param object, e.g. `{sectionId: section.id}`, that you'd like\n\t     * to test against the current active state.\n\t     * @param {object=} options An options object.  The options are:\n\t     *\n\t     * - **`relative`** - {string|object} -  If `stateOrName` is a relative state name and `options.relative` is set, .is will\n\t     * test relative to `options.relative` state (or name).\n\t     *\n\t     * @returns {boolean} Returns true if it is the state.\n\t     */\n\t    $state.is = function is(stateOrName, params, options) {\n\t      options = extend({ relative: $state.$current }, options || {});\n\t      var state = findState(stateOrName, options.relative);\n\t\n\t      if (!isDefined(state)) { return undefined; }\n\t      if ($state.$current !== state) { return false; }\n\t      return params ? equalForKeys(state.params.$$values(params), $stateParams) : true;\n\t    };\n\t\n\t    /**\n\t     * @ngdoc function\n\t     * @name ui.router.state.$state#includes\n\t     * @methodOf ui.router.state.$state\n\t     *\n\t     * @description\n\t     * A method to determine if the current active state is equal to or is the child of the\n\t     * state stateName. If any params are passed then they will be tested for a match as well.\n\t     * Not all the parameters need to be passed, just the ones you'd like to test for equality.\n\t     *\n\t     * @example\n\t     * Partial and relative names\n\t     * <pre>\n\t     * $state.$current.name = 'contacts.details.item';\n\t     *\n\t     * // Using partial names\n\t     * $state.includes(\"contacts\"); // returns true\n\t     * $state.includes(\"contacts.details\"); // returns true\n\t     * $state.includes(\"contacts.details.item\"); // returns true\n\t     * $state.includes(\"contacts.list\"); // returns false\n\t     * $state.includes(\"about\"); // returns false\n\t     *\n\t     * // Using relative names (. and ^), typically from a template\n\t     * // E.g. from the 'contacts.details' template\n\t     * <div ng-class=\"{highlighted: $state.includes('.item')}\">Item</div>\n\t     * </pre>\n\t     *\n\t     * Basic globbing patterns\n\t     * <pre>\n\t     * $state.$current.name = 'contacts.details.item.url';\n\t     *\n\t     * $state.includes(\"*.details.*.*\"); // returns true\n\t     * $state.includes(\"*.details.**\"); // returns true\n\t     * $state.includes(\"**.item.**\"); // returns true\n\t     * $state.includes(\"*.details.item.url\"); // returns true\n\t     * $state.includes(\"*.details.*.url\"); // returns true\n\t     * $state.includes(\"*.details.*\"); // returns false\n\t     * $state.includes(\"item.**\"); // returns false\n\t     * </pre>\n\t     *\n\t     * @param {string} stateOrName A partial name, relative name, or glob pattern\n\t     * to be searched for within the current state name.\n\t     * @param {object=} params A param object, e.g. `{sectionId: section.id}`,\n\t     * that you'd like to test against the current active state.\n\t     * @param {object=} options An options object.  The options are:\n\t     *\n\t     * - **`relative`** - {string|object=} -  If `stateOrName` is a relative state reference and `options.relative` is set,\n\t     * .includes will test relative to `options.relative` state (or name).\n\t     *\n\t     * @returns {boolean} Returns true if it does include the state\n\t     */\n\t    $state.includes = function includes(stateOrName, params, options) {\n\t      options = extend({ relative: $state.$current }, options || {});\n\t      if (isString(stateOrName) && isGlob(stateOrName)) {\n\t        if (!doesStateMatchGlob(stateOrName)) {\n\t          return false;\n\t        }\n\t        stateOrName = $state.$current.name;\n\t      }\n\t\n\t      var state = findState(stateOrName, options.relative);\n\t      if (!isDefined(state)) { return undefined; }\n\t      if (!isDefined($state.$current.includes[state.name])) { return false; }\n\t      return params ? equalForKeys(state.params.$$values(params), $stateParams, objectKeys(params)) : true;\n\t    };\n\t\n\t\n\t    /**\n\t     * @ngdoc function\n\t     * @name ui.router.state.$state#href\n\t     * @methodOf ui.router.state.$state\n\t     *\n\t     * @description\n\t     * A url generation method that returns the compiled url for the given state populated with the given params.\n\t     *\n\t     * @example\n\t     * <pre>\n\t     * expect($state.href(\"about.person\", { person: \"bob\" })).toEqual(\"/about/bob\");\n\t     * </pre>\n\t     *\n\t     * @param {string|object} stateOrName The state name or state object you'd like to generate a url from.\n\t     * @param {object=} params An object of parameter values to fill the state's required parameters.\n\t     * @param {object=} options Options object. The options are:\n\t     *\n\t     * - **`lossy`** - {boolean=true} -  If true, and if there is no url associated with the state provided in the\n\t     *    first parameter, then the constructed href url will be built from the first navigable ancestor (aka\n\t     *    ancestor with a valid url).\n\t     * - **`inherit`** - {boolean=true}, If `true` will inherit url parameters from current url.\n\t     * - **`relative`** - {object=$state.$current}, When transitioning with relative path (e.g '^'), \n\t     *    defines which state to be relative from.\n\t     * - **`absolute`** - {boolean=false},  If true will generate an absolute url, e.g. \"http://www.example.com/fullurl\".\n\t     * \n\t     * @returns {string} compiled state url\n\t     */\n\t    $state.href = function href(stateOrName, params, options) {\n\t      options = extend({\n\t        lossy:    true,\n\t        inherit:  true,\n\t        absolute: false,\n\t        relative: $state.$current\n\t      }, options || {});\n\t\n\t      var state = findState(stateOrName, options.relative);\n\t\n\t      if (!isDefined(state)) return null;\n\t      if (options.inherit) params = inheritParams($stateParams, params || {}, $state.$current, state);\n\t      \n\t      var nav = (state && options.lossy) ? state.navigable : state;\n\t\n\t      if (!nav || nav.url === undefined || nav.url === null) {\n\t        return null;\n\t      }\n\t      return $urlRouter.href(nav.url, filterByKeys(state.params.$$keys().concat('#'), params || {}), {\n\t        absolute: options.absolute\n\t      });\n\t    };\n\t\n\t    /**\n\t     * @ngdoc function\n\t     * @name ui.router.state.$state#get\n\t     * @methodOf ui.router.state.$state\n\t     *\n\t     * @description\n\t     * Returns the state configuration object for any specific state or all states.\n\t     *\n\t     * @param {string|object=} stateOrName (absolute or relative) If provided, will only get the config for\n\t     * the requested state. If not provided, returns an array of ALL state configs.\n\t     * @param {string|object=} context When stateOrName is a relative state reference, the state will be retrieved relative to context.\n\t     * @returns {Object|Array} State configuration object or array of all objects.\n\t     */\n\t    $state.get = function (stateOrName, context) {\n\t      if (arguments.length === 0) return map(objectKeys(states), function(name) { return states[name].self; });\n\t      var state = findState(stateOrName, context || $state.$current);\n\t      return (state && state.self) ? state.self : null;\n\t    };\n\t\n\t    function resolveState(state, params, paramsAreFiltered, inherited, dst, options) {\n\t      // Make a restricted $stateParams with only the parameters that apply to this state if\n\t      // necessary. In addition to being available to the controller and onEnter/onExit callbacks,\n\t      // we also need $stateParams to be available for any $injector calls we make during the\n\t      // dependency resolution process.\n\t      var $stateParams = (paramsAreFiltered) ? params : filterByKeys(state.params.$$keys(), params);\n\t      var locals = { $stateParams: $stateParams };\n\t\n\t      // Resolve 'global' dependencies for the state, i.e. those not specific to a view.\n\t      // We're also including $stateParams in this; that way the parameters are restricted\n\t      // to the set that should be visible to the state, and are independent of when we update\n\t      // the global $state and $stateParams values.\n\t      dst.resolve = $resolve.resolve(state.resolve, locals, dst.resolve, state);\n\t      var promises = [dst.resolve.then(function (globals) {\n\t        dst.globals = globals;\n\t      })];\n\t      if (inherited) promises.push(inherited);\n\t\n\t      function resolveViews() {\n\t        var viewsPromises = [];\n\t\n\t        // Resolve template and dependencies for all views.\n\t        forEach(state.views, function (view, name) {\n\t          var injectables = (view.resolve && view.resolve !== state.resolve ? view.resolve : {});\n\t          injectables.$template = [ function () {\n\t            return $view.load(name, { view: view, locals: dst.globals, params: $stateParams, notify: options.notify }) || '';\n\t          }];\n\t\n\t          viewsPromises.push($resolve.resolve(injectables, dst.globals, dst.resolve, state).then(function (result) {\n\t            // References to the controller (only instantiated at link time)\n\t            if (isFunction(view.controllerProvider) || isArray(view.controllerProvider)) {\n\t              var injectLocals = angular.extend({}, injectables, dst.globals);\n\t              result.$$controller = $injector.invoke(view.controllerProvider, null, injectLocals);\n\t            } else {\n\t              result.$$controller = view.controller;\n\t            }\n\t            // Provide access to the state itself for internal use\n\t            result.$$state = state;\n\t            result.$$controllerAs = view.controllerAs;\n\t            result.$$resolveAs = view.resolveAs;\n\t            dst[name] = result;\n\t          }));\n\t        });\n\t\n\t        return $q.all(viewsPromises).then(function(){\n\t          return dst.globals;\n\t        });\n\t      }\n\t\n\t      // Wait for all the promises and then return the activation object\n\t      return $q.all(promises).then(resolveViews).then(function (values) {\n\t        return dst;\n\t      });\n\t    }\n\t\n\t    return $state;\n\t  }\n\t\n\t  function shouldSkipReload(to, toParams, from, fromParams, locals, options) {\n\t    // Return true if there are no differences in non-search (path/object) params, false if there are differences\n\t    function nonSearchParamsEqual(fromAndToState, fromParams, toParams) {\n\t      // Identify whether all the parameters that differ between `fromParams` and `toParams` were search params.\n\t      function notSearchParam(key) {\n\t        return fromAndToState.params[key].location != \"search\";\n\t      }\n\t      var nonQueryParamKeys = fromAndToState.params.$$keys().filter(notSearchParam);\n\t      var nonQueryParams = pick.apply({}, [fromAndToState.params].concat(nonQueryParamKeys));\n\t      var nonQueryParamSet = new $$UMFP.ParamSet(nonQueryParams);\n\t      return nonQueryParamSet.$$equals(fromParams, toParams);\n\t    }\n\t\n\t    // If reload was not explicitly requested\n\t    // and we're transitioning to the same state we're already in\n\t    // and    the locals didn't change\n\t    //     or they changed in a way that doesn't merit reloading\n\t    //        (reloadOnParams:false, or reloadOnSearch.false and only search params changed)\n\t    // Then return true.\n\t    if (!options.reload && to === from &&\n\t      (locals === from.locals || (to.self.reloadOnSearch === false && nonSearchParamsEqual(from, fromParams, toParams)))) {\n\t      return true;\n\t    }\n\t  }\n\t}\n\t\n\tangular.module('ui.router.state')\n\t  .factory('$stateParams', function () { return {}; })\n\t  .constant(\"$state.runtime\", { autoinject: true })\n\t  .provider('$state', $StateProvider)\n\t  // Inject $state to initialize when entering runtime. #2574\n\t  .run(['$injector', function ($injector) {\n\t    // Allow tests (stateSpec.js) to turn this off by defining this constant\n\t    if ($injector.get(\"$state.runtime\").autoinject) {\n\t      $injector.get('$state');\n\t    }\n\t  }]);\n\t\n\t\n\t$ViewProvider.$inject = [];\n\tfunction $ViewProvider() {\n\t\n\t  this.$get = $get;\n\t  /**\n\t   * @ngdoc object\n\t   * @name ui.router.state.$view\n\t   *\n\t   * @requires ui.router.util.$templateFactory\n\t   * @requires $rootScope\n\t   *\n\t   * @description\n\t   *\n\t   */\n\t  $get.$inject = ['$rootScope', '$templateFactory'];\n\t  function $get(   $rootScope,   $templateFactory) {\n\t    return {\n\t      // $view.load('full.viewName', { template: ..., controller: ..., resolve: ..., async: false, params: ... })\n\t      /**\n\t       * @ngdoc function\n\t       * @name ui.router.state.$view#load\n\t       * @methodOf ui.router.state.$view\n\t       *\n\t       * @description\n\t       *\n\t       * @param {string} name name\n\t       * @param {object} options option object.\n\t       */\n\t      load: function load(name, options) {\n\t        var result, defaults = {\n\t          template: null, controller: null, view: null, locals: null, notify: true, async: true, params: {}\n\t        };\n\t        options = extend(defaults, options);\n\t\n\t        if (options.view) {\n\t          result = $templateFactory.fromConfig(options.view, options.params, options.locals);\n\t        }\n\t        return result;\n\t      }\n\t    };\n\t  }\n\t}\n\t\n\tangular.module('ui.router.state').provider('$view', $ViewProvider);\n\t\n\t/**\n\t * @ngdoc object\n\t * @name ui.router.state.$uiViewScrollProvider\n\t *\n\t * @description\n\t * Provider that returns the {@link ui.router.state.$uiViewScroll} service function.\n\t */\n\tfunction $ViewScrollProvider() {\n\t\n\t  var useAnchorScroll = false;\n\t\n\t  /**\n\t   * @ngdoc function\n\t   * @name ui.router.state.$uiViewScrollProvider#useAnchorScroll\n\t   * @methodOf ui.router.state.$uiViewScrollProvider\n\t   *\n\t   * @description\n\t   * Reverts back to using the core [`$anchorScroll`](http://docs.angularjs.org/api/ng.$anchorScroll) service for\n\t   * scrolling based on the url anchor.\n\t   */\n\t  this.useAnchorScroll = function () {\n\t    useAnchorScroll = true;\n\t  };\n\t\n\t  /**\n\t   * @ngdoc object\n\t   * @name ui.router.state.$uiViewScroll\n\t   *\n\t   * @requires $anchorScroll\n\t   * @requires $timeout\n\t   *\n\t   * @description\n\t   * When called with a jqLite element, it scrolls the element into view (after a\n\t   * `$timeout` so the DOM has time to refresh).\n\t   *\n\t   * If you prefer to rely on `$anchorScroll` to scroll the view to the anchor,\n\t   * this can be enabled by calling {@link ui.router.state.$uiViewScrollProvider#methods_useAnchorScroll `$uiViewScrollProvider.useAnchorScroll()`}.\n\t   */\n\t  this.$get = ['$anchorScroll', '$timeout', function ($anchorScroll, $timeout) {\n\t    if (useAnchorScroll) {\n\t      return $anchorScroll;\n\t    }\n\t\n\t    return function ($element) {\n\t      return $timeout(function () {\n\t        $element[0].scrollIntoView();\n\t      }, 0, false);\n\t    };\n\t  }];\n\t}\n\t\n\tangular.module('ui.router.state').provider('$uiViewScroll', $ViewScrollProvider);\n\t\n\t/**\n\t * @ngdoc directive\n\t * @name ui.router.state.directive:ui-view\n\t *\n\t * @requires ui.router.state.$state\n\t * @requires $compile\n\t * @requires $controller\n\t * @requires $injector\n\t * @requires ui.router.state.$uiViewScroll\n\t * @requires $document\n\t *\n\t * @restrict ECA\n\t *\n\t * @description\n\t * The ui-view directive tells $state where to place your templates.\n\t *\n\t * @param {string=} name A view name. The name should be unique amongst the other views in the\n\t * same state. You can have views of the same name that live in different states.\n\t *\n\t * @param {string=} autoscroll It allows you to set the scroll behavior of the browser window\n\t * when a view is populated. By default, $anchorScroll is overridden by ui-router's custom scroll\n\t * service, {@link ui.router.state.$uiViewScroll}. This custom service let's you\n\t * scroll ui-view elements into view when they are populated during a state activation.\n\t *\n\t * *Note: To revert back to old [`$anchorScroll`](http://docs.angularjs.org/api/ng.$anchorScroll)\n\t * functionality, call `$uiViewScrollProvider.useAnchorScroll()`.*\n\t *\n\t * @param {string=} onload Expression to evaluate whenever the view updates.\n\t *\n\t * @example\n\t * A view can be unnamed or named.\n\t * <pre>\n\t * <!-- Unnamed -->\n\t * <div ui-view></div>\n\t *\n\t * <!-- Named -->\n\t * <div ui-view=\"viewName\"></div>\n\t * </pre>\n\t *\n\t * You can only have one unnamed view within any template (or root html). If you are only using a\n\t * single view and it is unnamed then you can populate it like so:\n\t * <pre>\n\t * <div ui-view></div>\n\t * $stateProvider.state(\"home\", {\n\t *   template: \"<h1>HELLO!</h1>\"\n\t * })\n\t * </pre>\n\t *\n\t * The above is a convenient shortcut equivalent to specifying your view explicitly with the {@link ui.router.state.$stateProvider#methods_state `views`}\n\t * config property, by name, in this case an empty name:\n\t * <pre>\n\t * $stateProvider.state(\"home\", {\n\t *   views: {\n\t *     \"\": {\n\t *       template: \"<h1>HELLO!</h1>\"\n\t *     }\n\t *   }    \n\t * })\n\t * </pre>\n\t *\n\t * But typically you'll only use the views property if you name your view or have more than one view\n\t * in the same template. There's not really a compelling reason to name a view if its the only one,\n\t * but you could if you wanted, like so:\n\t * <pre>\n\t * <div ui-view=\"main\"></div>\n\t * </pre>\n\t * <pre>\n\t * $stateProvider.state(\"home\", {\n\t *   views: {\n\t *     \"main\": {\n\t *       template: \"<h1>HELLO!</h1>\"\n\t *     }\n\t *   }    \n\t * })\n\t * </pre>\n\t *\n\t * Really though, you'll use views to set up multiple views:\n\t * <pre>\n\t * <div ui-view></div>\n\t * <div ui-view=\"chart\"></div>\n\t * <div ui-view=\"data\"></div>\n\t * </pre>\n\t *\n\t * <pre>\n\t * $stateProvider.state(\"home\", {\n\t *   views: {\n\t *     \"\": {\n\t *       template: \"<h1>HELLO!</h1>\"\n\t *     },\n\t *     \"chart\": {\n\t *       template: \"<chart_thing/>\"\n\t *     },\n\t *     \"data\": {\n\t *       template: \"<data_thing/>\"\n\t *     }\n\t *   }    \n\t * })\n\t * </pre>\n\t *\n\t * Examples for `autoscroll`:\n\t *\n\t * <pre>\n\t * <!-- If autoscroll present with no expression,\n\t *      then scroll ui-view into view -->\n\t * <ui-view autoscroll/>\n\t *\n\t * <!-- If autoscroll present with valid expression,\n\t *      then scroll ui-view into view if expression evaluates to true -->\n\t * <ui-view autoscroll='true'/>\n\t * <ui-view autoscroll='false'/>\n\t * <ui-view autoscroll='scopeVariable'/>\n\t * </pre>\n\t *\n\t * Resolve data:\n\t *\n\t * The resolved data from the state's `resolve` block is placed on the scope as `$resolve` (this\n\t * can be customized using [[ViewDeclaration.resolveAs]]).  This can be then accessed from the template.\n\t *\n\t * Note that when `controllerAs` is being used, `$resolve` is set on the controller instance *after* the\n\t * controller is instantiated.  The `$onInit()` hook can be used to perform initialization code which\n\t * depends on `$resolve` data.\n\t *\n\t * Example usage of $resolve in a view template\n\t * <pre>\n\t * $stateProvider.state('home', {\n\t *   template: '<my-component user=\"$resolve.user\"></my-component>',\n\t *   resolve: {\n\t *     user: function(UserService) { return UserService.fetchUser(); }\n\t *   }\n\t * });\n\t * </pre>\n\t */\n\t$ViewDirective.$inject = ['$state', '$injector', '$uiViewScroll', '$interpolate', '$q'];\n\tfunction $ViewDirective(   $state,   $injector,   $uiViewScroll,   $interpolate,   $q) {\n\t\n\t  function getService() {\n\t    return ($injector.has) ? function(service) {\n\t      return $injector.has(service) ? $injector.get(service) : null;\n\t    } : function(service) {\n\t      try {\n\t        return $injector.get(service);\n\t      } catch (e) {\n\t        return null;\n\t      }\n\t    };\n\t  }\n\t\n\t  var service = getService(),\n\t      $animator = service('$animator'),\n\t      $animate = service('$animate');\n\t\n\t  // Returns a set of DOM manipulation functions based on which Angular version\n\t  // it should use\n\t  function getRenderer(attrs, scope) {\n\t    var statics = function() {\n\t      return {\n\t        enter: function (element, target, cb) { target.after(element); cb(); },\n\t        leave: function (element, cb) { element.remove(); cb(); }\n\t      };\n\t    };\n\t\n\t    if ($animate) {\n\t      return {\n\t        enter: function(element, target, cb) {\n\t          if (angular.version.minor > 2) {\n\t            $animate.enter(element, null, target).then(cb);\n\t          } else {\n\t            $animate.enter(element, null, target, cb);\n\t          }\n\t        },\n\t        leave: function(element, cb) {\n\t          if (angular.version.minor > 2) {\n\t            $animate.leave(element).then(cb);\n\t          } else {\n\t            $animate.leave(element, cb);\n\t          }\n\t        }\n\t      };\n\t    }\n\t\n\t    if ($animator) {\n\t      var animate = $animator && $animator(scope, attrs);\n\t\n\t      return {\n\t        enter: function(element, target, cb) {animate.enter(element, null, target); cb(); },\n\t        leave: function(element, cb) { animate.leave(element); cb(); }\n\t      };\n\t    }\n\t\n\t    return statics();\n\t  }\n\t\n\t  var directive = {\n\t    restrict: 'ECA',\n\t    terminal: true,\n\t    priority: 400,\n\t    transclude: 'element',\n\t    compile: function (tElement, tAttrs, $transclude) {\n\t      return function (scope, $element, attrs) {\n\t        var previousEl, currentEl, currentScope, latestLocals,\n\t            onloadExp     = attrs.onload || '',\n\t            autoScrollExp = attrs.autoscroll,\n\t            renderer      = getRenderer(attrs, scope),\n\t            inherited     = $element.inheritedData('$uiView');\n\t\n\t        scope.$on('$stateChangeSuccess', function() {\n\t          updateView(false);\n\t        });\n\t\n\t        updateView(true);\n\t\n\t        function cleanupLastView() {\n\t          if (previousEl) {\n\t            previousEl.remove();\n\t            previousEl = null;\n\t          }\n\t\n\t          if (currentScope) {\n\t            currentScope.$destroy();\n\t            currentScope = null;\n\t          }\n\t\n\t          if (currentEl) {\n\t            var $uiViewData = currentEl.data('$uiViewAnim');\n\t            renderer.leave(currentEl, function() {\n\t              $uiViewData.$$animLeave.resolve();\n\t              previousEl = null;\n\t            });\n\t\n\t            previousEl = currentEl;\n\t            currentEl = null;\n\t          }\n\t        }\n\t\n\t        function updateView(firstTime) {\n\t          var newScope,\n\t              name            = getUiViewName(scope, attrs, $element, $interpolate),\n\t              previousLocals  = name && $state.$current && $state.$current.locals[name];\n\t\n\t          if (!firstTime && previousLocals === latestLocals) return; // nothing to do\n\t          newScope = scope.$new();\n\t          latestLocals = $state.$current.locals[name];\n\t\n\t          /**\n\t           * @ngdoc event\n\t           * @name ui.router.state.directive:ui-view#$viewContentLoading\n\t           * @eventOf ui.router.state.directive:ui-view\n\t           * @eventType emits on ui-view directive scope\n\t           * @description\n\t           *\n\t           * Fired once the view **begins loading**, *before* the DOM is rendered.\n\t           *\n\t           * @param {Object} event Event object.\n\t           * @param {string} viewName Name of the view.\n\t           */\n\t          newScope.$emit('$viewContentLoading', name);\n\t\n\t          var clone = $transclude(newScope, function(clone) {\n\t            var animEnter = $q.defer(), animLeave = $q.defer();\n\t            var viewAnimData = {\n\t              $animEnter: animEnter.promise,\n\t              $animLeave: animLeave.promise,\n\t              $$animLeave: animLeave\n\t            };\n\t\n\t            clone.data('$uiViewAnim', viewAnimData);\n\t            renderer.enter(clone, $element, function onUiViewEnter() {\n\t              animEnter.resolve();\n\t              if(currentScope) {\n\t                currentScope.$emit('$viewContentAnimationEnded');\n\t              }\n\t\n\t              if (angular.isDefined(autoScrollExp) && !autoScrollExp || scope.$eval(autoScrollExp)) {\n\t                $uiViewScroll(clone);\n\t              }\n\t            });\n\t            cleanupLastView();\n\t          });\n\t\n\t          currentEl = clone;\n\t          currentScope = newScope;\n\t          /**\n\t           * @ngdoc event\n\t           * @name ui.router.state.directive:ui-view#$viewContentLoaded\n\t           * @eventOf ui.router.state.directive:ui-view\n\t           * @eventType emits on ui-view directive scope\n\t           * @description\n\t           * Fired once the view is **loaded**, *after* the DOM is rendered.\n\t           *\n\t           * @param {Object} event Event object.\n\t           * @param {string} viewName Name of the view.\n\t           */\n\t          currentScope.$emit('$viewContentLoaded', name);\n\t          currentScope.$eval(onloadExp);\n\t        }\n\t      };\n\t    }\n\t  };\n\t\n\t  return directive;\n\t}\n\t\n\t$ViewDirectiveFill.$inject = ['$compile', '$controller', '$state', '$interpolate'];\n\tfunction $ViewDirectiveFill (  $compile,   $controller,   $state,   $interpolate) {\n\t  return {\n\t    restrict: 'ECA',\n\t    priority: -400,\n\t    compile: function (tElement) {\n\t      var initial = tElement.html();\n\t      return function (scope, $element, attrs) {\n\t        var current = $state.$current,\n\t            name = getUiViewName(scope, attrs, $element, $interpolate),\n\t            locals  = current && current.locals[name];\n\t\n\t        if (! locals) {\n\t          return;\n\t        }\n\t\n\t        $element.data('$uiView', { name: name, state: locals.$$state });\n\t        $element.html(locals.$template ? locals.$template : initial);\n\t\n\t        var resolveData = angular.extend({}, locals);\n\t        scope[locals.$$resolveAs] = resolveData;\n\t\n\t        var link = $compile($element.contents());\n\t\n\t        if (locals.$$controller) {\n\t          locals.$scope = scope;\n\t          locals.$element = $element;\n\t          var controller = $controller(locals.$$controller, locals);\n\t          if (locals.$$controllerAs) {\n\t            scope[locals.$$controllerAs] = controller;\n\t            scope[locals.$$controllerAs][locals.$$resolveAs] = resolveData;\n\t          }\n\t          if (isFunction(controller.$onInit)) controller.$onInit();\n\t          $element.data('$ngControllerController', controller);\n\t          $element.children().data('$ngControllerController', controller);\n\t        }\n\t\n\t        link(scope);\n\t      };\n\t    }\n\t  };\n\t}\n\t\n\t/**\n\t * Shared ui-view code for both directives:\n\t * Given scope, element, and its attributes, return the view's name\n\t */\n\tfunction getUiViewName(scope, attrs, element, $interpolate) {\n\t  var name = $interpolate(attrs.uiView || attrs.name || '')(scope);\n\t  var uiViewCreatedBy = element.inheritedData('$uiView');\n\t  return name.indexOf('@') >= 0 ?  name :  (name + '@' + (uiViewCreatedBy ? uiViewCreatedBy.state.name : ''));\n\t}\n\t\n\tangular.module('ui.router.state').directive('uiView', $ViewDirective);\n\tangular.module('ui.router.state').directive('uiView', $ViewDirectiveFill);\n\t\n\tfunction parseStateRef(ref, current) {\n\t  var preparsed = ref.match(/^\\s*({[^}]*})\\s*$/), parsed;\n\t  if (preparsed) ref = current + '(' + preparsed[1] + ')';\n\t  parsed = ref.replace(/\\n/g, \" \").match(/^([^(]+?)\\s*(\\((.*)\\))?$/);\n\t  if (!parsed || parsed.length !== 4) throw new Error(\"Invalid state ref '\" + ref + \"'\");\n\t  return { state: parsed[1], paramExpr: parsed[3] || null };\n\t}\n\t\n\tfunction stateContext(el) {\n\t  var stateData = el.parent().inheritedData('$uiView');\n\t\n\t  if (stateData && stateData.state && stateData.state.name) {\n\t    return stateData.state;\n\t  }\n\t}\n\t\n\tfunction getTypeInfo(el) {\n\t  // SVGAElement does not use the href attribute, but rather the 'xlinkHref' attribute.\n\t  var isSvg = Object.prototype.toString.call(el.prop('href')) === '[object SVGAnimatedString]';\n\t  var isForm = el[0].nodeName === \"FORM\";\n\t\n\t  return {\n\t    attr: isForm ? \"action\" : (isSvg ? 'xlink:href' : 'href'),\n\t    isAnchor: el.prop(\"tagName\").toUpperCase() === \"A\",\n\t    clickable: !isForm\n\t  };\n\t}\n\t\n\tfunction clickHook(el, $state, $timeout, type, current) {\n\t  return function(e) {\n\t    var button = e.which || e.button, target = current();\n\t\n\t    if (!(button > 1 || e.ctrlKey || e.metaKey || e.shiftKey || el.attr('target'))) {\n\t      // HACK: This is to allow ng-clicks to be processed before the transition is initiated:\n\t      var transition = $timeout(function() {\n\t        $state.go(target.state, target.params, target.options);\n\t      });\n\t      e.preventDefault();\n\t\n\t      // if the state has no URL, ignore one preventDefault from the <a> directive.\n\t      var ignorePreventDefaultCount = type.isAnchor && !target.href ? 1: 0;\n\t\n\t      e.preventDefault = function() {\n\t        if (ignorePreventDefaultCount-- <= 0) $timeout.cancel(transition);\n\t      };\n\t    }\n\t  };\n\t}\n\t\n\tfunction defaultOpts(el, $state) {\n\t  return { relative: stateContext(el) || $state.$current, inherit: true };\n\t}\n\t\n\t/**\n\t * @ngdoc directive\n\t * @name ui.router.state.directive:ui-sref\n\t *\n\t * @requires ui.router.state.$state\n\t * @requires $timeout\n\t *\n\t * @restrict A\n\t *\n\t * @description\n\t * A directive that binds a link (`<a>` tag) to a state. If the state has an associated\n\t * URL, the directive will automatically generate & update the `href` attribute via\n\t * the {@link ui.router.state.$state#methods_href $state.href()} method. Clicking\n\t * the link will trigger a state transition with optional parameters.\n\t *\n\t * Also middle-clicking, right-clicking, and ctrl-clicking on the link will be\n\t * handled natively by the browser.\n\t *\n\t * You can also use relative state paths within ui-sref, just like the relative\n\t * paths passed to `$state.go()`. You just need to be aware that the path is relative\n\t * to the state that the link lives in, in other words the state that loaded the\n\t * template containing the link.\n\t *\n\t * You can specify options to pass to {@link ui.router.state.$state#methods_go $state.go()}\n\t * using the `ui-sref-opts` attribute. Options are restricted to `location`, `inherit`,\n\t * and `reload`.\n\t *\n\t * @example\n\t * Here's an example of how you'd use ui-sref and how it would compile. If you have the\n\t * following template:\n\t * <pre>\n\t * <a ui-sref=\"home\">Home</a> | <a ui-sref=\"about\">About</a> | <a ui-sref=\"{page: 2}\">Next page</a>\n\t *\n\t * <ul>\n\t *     <li ng-repeat=\"contact in contacts\">\n\t *         <a ui-sref=\"contacts.detail({ id: contact.id })\">{{ contact.name }}</a>\n\t *     </li>\n\t * </ul>\n\t * </pre>\n\t *\n\t * Then the compiled html would be (assuming Html5Mode is off and current state is contacts):\n\t * <pre>\n\t * <a href=\"#/home\" ui-sref=\"home\">Home</a> | <a href=\"#/about\" ui-sref=\"about\">About</a> | <a href=\"#/contacts?page=2\" ui-sref=\"{page: 2}\">Next page</a>\n\t *\n\t * <ul>\n\t *     <li ng-repeat=\"contact in contacts\">\n\t *         <a href=\"#/contacts/1\" ui-sref=\"contacts.detail({ id: contact.id })\">Joe</a>\n\t *     </li>\n\t *     <li ng-repeat=\"contact in contacts\">\n\t *         <a href=\"#/contacts/2\" ui-sref=\"contacts.detail({ id: contact.id })\">Alice</a>\n\t *     </li>\n\t *     <li ng-repeat=\"contact in contacts\">\n\t *         <a href=\"#/contacts/3\" ui-sref=\"contacts.detail({ id: contact.id })\">Bob</a>\n\t *     </li>\n\t * </ul>\n\t *\n\t * <a ui-sref=\"home\" ui-sref-opts=\"{reload: true}\">Home</a>\n\t * </pre>\n\t *\n\t * @param {string} ui-sref 'stateName' can be any valid absolute or relative state\n\t * @param {Object} ui-sref-opts options to pass to {@link ui.router.state.$state#methods_go $state.go()}\n\t */\n\t$StateRefDirective.$inject = ['$state', '$timeout'];\n\tfunction $StateRefDirective($state, $timeout) {\n\t  return {\n\t    restrict: 'A',\n\t    require: ['?^uiSrefActive', '?^uiSrefActiveEq'],\n\t    link: function(scope, element, attrs, uiSrefActive) {\n\t      var ref    = parseStateRef(attrs.uiSref, $state.current.name);\n\t      var def    = { state: ref.state, href: null, params: null };\n\t      var type   = getTypeInfo(element);\n\t      var active = uiSrefActive[1] || uiSrefActive[0];\n\t      var unlinkInfoFn = null;\n\t      var hookFn;\n\t\n\t      def.options = extend(defaultOpts(element, $state), attrs.uiSrefOpts ? scope.$eval(attrs.uiSrefOpts) : {});\n\t\n\t      var update = function(val) {\n\t        if (val) def.params = angular.copy(val);\n\t        def.href = $state.href(ref.state, def.params, def.options);\n\t\n\t        if (unlinkInfoFn) unlinkInfoFn();\n\t        if (active) unlinkInfoFn = active.$$addStateInfo(ref.state, def.params);\n\t        if (def.href !== null) attrs.$set(type.attr, def.href);\n\t      };\n\t\n\t      if (ref.paramExpr) {\n\t        scope.$watch(ref.paramExpr, function(val) { if (val !== def.params) update(val); }, true);\n\t        def.params = angular.copy(scope.$eval(ref.paramExpr));\n\t      }\n\t      update();\n\t\n\t      if (!type.clickable) return;\n\t      hookFn = clickHook(element, $state, $timeout, type, function() { return def; });\n\t      element.bind(\"click\", hookFn);\n\t      scope.$on('$destroy', function() {\n\t        element.unbind(\"click\", hookFn);\n\t      });\n\t    }\n\t  };\n\t}\n\t\n\t/**\n\t * @ngdoc directive\n\t * @name ui.router.state.directive:ui-state\n\t *\n\t * @requires ui.router.state.uiSref\n\t *\n\t * @restrict A\n\t *\n\t * @description\n\t * Much like ui-sref, but will accept named $scope properties to evaluate for a state definition,\n\t * params and override options.\n\t *\n\t * @param {string} ui-state 'stateName' can be any valid absolute or relative state\n\t * @param {Object} ui-state-params params to pass to {@link ui.router.state.$state#methods_href $state.href()}\n\t * @param {Object} ui-state-opts options to pass to {@link ui.router.state.$state#methods_go $state.go()}\n\t */\n\t$StateRefDynamicDirective.$inject = ['$state', '$timeout'];\n\tfunction $StateRefDynamicDirective($state, $timeout) {\n\t  return {\n\t    restrict: 'A',\n\t    require: ['?^uiSrefActive', '?^uiSrefActiveEq'],\n\t    link: function(scope, element, attrs, uiSrefActive) {\n\t      var type   = getTypeInfo(element);\n\t      var active = uiSrefActive[1] || uiSrefActive[0];\n\t      var group  = [attrs.uiState, attrs.uiStateParams || null, attrs.uiStateOpts || null];\n\t      var watch  = '[' + group.map(function(val) { return val || 'null'; }).join(', ') + ']';\n\t      var def    = { state: null, params: null, options: null, href: null };\n\t      var unlinkInfoFn = null;\n\t      var hookFn;\n\t\n\t      function runStateRefLink (group) {\n\t        def.state = group[0]; def.params = group[1]; def.options = group[2];\n\t        def.href = $state.href(def.state, def.params, def.options);\n\t\n\t        if (unlinkInfoFn) unlinkInfoFn();\n\t        if (active) unlinkInfoFn = active.$$addStateInfo(def.state, def.params);\n\t        if (def.href) attrs.$set(type.attr, def.href);\n\t      }\n\t\n\t      scope.$watch(watch, runStateRefLink, true);\n\t      runStateRefLink(scope.$eval(watch));\n\t\n\t      if (!type.clickable) return;\n\t      hookFn = clickHook(element, $state, $timeout, type, function() { return def; });\n\t      element.bind(\"click\", hookFn);\n\t      scope.$on('$destroy', function() {\n\t        element.unbind(\"click\", hookFn);\n\t      });\n\t    }\n\t  };\n\t}\n\t\n\t\n\t/**\n\t * @ngdoc directive\n\t * @name ui.router.state.directive:ui-sref-active\n\t *\n\t * @requires ui.router.state.$state\n\t * @requires ui.router.state.$stateParams\n\t * @requires $interpolate\n\t *\n\t * @restrict A\n\t *\n\t * @description\n\t * A directive working alongside ui-sref to add classes to an element when the\n\t * related ui-sref directive's state is active, and removing them when it is inactive.\n\t * The primary use-case is to simplify the special appearance of navigation menus\n\t * relying on `ui-sref`, by having the \"active\" state's menu button appear different,\n\t * distinguishing it from the inactive menu items.\n\t *\n\t * ui-sref-active can live on the same element as ui-sref or on a parent element. The first\n\t * ui-sref-active found at the same level or above the ui-sref will be used.\n\t *\n\t * Will activate when the ui-sref's target state or any child state is active. If you\n\t * need to activate only when the ui-sref target state is active and *not* any of\n\t * it's children, then you will use\n\t * {@link ui.router.state.directive:ui-sref-active-eq ui-sref-active-eq}\n\t *\n\t * @example\n\t * Given the following template:\n\t * <pre>\n\t * <ul>\n\t *   <li ui-sref-active=\"active\" class=\"item\">\n\t *     <a href ui-sref=\"app.user({user: 'bilbobaggins'})\">@bilbobaggins</a>\n\t *   </li>\n\t * </ul>\n\t * </pre>\n\t *\n\t *\n\t * When the app state is \"app.user\" (or any children states), and contains the state parameter \"user\" with value \"bilbobaggins\",\n\t * the resulting HTML will appear as (note the 'active' class):\n\t * <pre>\n\t * <ul>\n\t *   <li ui-sref-active=\"active\" class=\"item active\">\n\t *     <a ui-sref=\"app.user({user: 'bilbobaggins'})\" href=\"/users/bilbobaggins\">@bilbobaggins</a>\n\t *   </li>\n\t * </ul>\n\t * </pre>\n\t *\n\t * The class name is interpolated **once** during the directives link time (any further changes to the\n\t * interpolated value are ignored).\n\t *\n\t * Multiple classes may be specified in a space-separated format:\n\t * <pre>\n\t * <ul>\n\t *   <li ui-sref-active='class1 class2 class3'>\n\t *     <a ui-sref=\"app.user\">link</a>\n\t *   </li>\n\t * </ul>\n\t * </pre>\n\t *\n\t * It is also possible to pass ui-sref-active an expression that evaluates\n\t * to an object hash, whose keys represent active class names and whose\n\t * values represent the respective state names/globs.\n\t * ui-sref-active will match if the current active state **includes** any of\n\t * the specified state names/globs, even the abstract ones.\n\t *\n\t * @Example\n\t * Given the following template, with \"admin\" being an abstract state:\n\t * <pre>\n\t * <div ui-sref-active=\"{'active': 'admin.*'}\">\n\t *   <a ui-sref-active=\"active\" ui-sref=\"admin.roles\">Roles</a>\n\t * </div>\n\t * </pre>\n\t *\n\t * When the current state is \"admin.roles\" the \"active\" class will be applied\n\t * to both the <div> and <a> elements. It is important to note that the state\n\t * names/globs passed to ui-sref-active shadow the state provided by ui-sref.\n\t */\n\t\n\t/**\n\t * @ngdoc directive\n\t * @name ui.router.state.directive:ui-sref-active-eq\n\t *\n\t * @requires ui.router.state.$state\n\t * @requires ui.router.state.$stateParams\n\t * @requires $interpolate\n\t *\n\t * @restrict A\n\t *\n\t * @description\n\t * The same as {@link ui.router.state.directive:ui-sref-active ui-sref-active} but will only activate\n\t * when the exact target state used in the `ui-sref` is active; no child states.\n\t *\n\t */\n\t$StateRefActiveDirective.$inject = ['$state', '$stateParams', '$interpolate'];\n\tfunction $StateRefActiveDirective($state, $stateParams, $interpolate) {\n\t  return  {\n\t    restrict: \"A\",\n\t    controller: ['$scope', '$element', '$attrs', '$timeout', function ($scope, $element, $attrs, $timeout) {\n\t      var states = [], activeClasses = {}, activeEqClass, uiSrefActive;\n\t\n\t      // There probably isn't much point in $observing this\n\t      // uiSrefActive and uiSrefActiveEq share the same directive object with some\n\t      // slight difference in logic routing\n\t      activeEqClass = $interpolate($attrs.uiSrefActiveEq || '', false)($scope);\n\t\n\t      try {\n\t        uiSrefActive = $scope.$eval($attrs.uiSrefActive);\n\t      } catch (e) {\n\t        // Do nothing. uiSrefActive is not a valid expression.\n\t        // Fall back to using $interpolate below\n\t      }\n\t      uiSrefActive = uiSrefActive || $interpolate($attrs.uiSrefActive || '', false)($scope);\n\t      if (isObject(uiSrefActive)) {\n\t        forEach(uiSrefActive, function(stateOrName, activeClass) {\n\t          if (isString(stateOrName)) {\n\t            var ref = parseStateRef(stateOrName, $state.current.name);\n\t            addState(ref.state, $scope.$eval(ref.paramExpr), activeClass);\n\t          }\n\t        });\n\t      }\n\t\n\t      // Allow uiSref to communicate with uiSrefActive[Equals]\n\t      this.$$addStateInfo = function (newState, newParams) {\n\t        // we already got an explicit state provided by ui-sref-active, so we\n\t        // shadow the one that comes from ui-sref\n\t        if (isObject(uiSrefActive) && states.length > 0) {\n\t          return;\n\t        }\n\t        var deregister = addState(newState, newParams, uiSrefActive);\n\t        update();\n\t        return deregister;\n\t      };\n\t\n\t      $scope.$on('$stateChangeSuccess', update);\n\t\n\t      function addState(stateName, stateParams, activeClass) {\n\t        var state = $state.get(stateName, stateContext($element));\n\t        var stateHash = createStateHash(stateName, stateParams);\n\t\n\t        var stateInfo = {\n\t          state: state || { name: stateName },\n\t          params: stateParams,\n\t          hash: stateHash\n\t        };\n\t\n\t        states.push(stateInfo);\n\t        activeClasses[stateHash] = activeClass;\n\t\n\t        return function removeState() {\n\t          var idx = states.indexOf(stateInfo);\n\t          if (idx !== -1) states.splice(idx, 1);\n\t        };\n\t      }\n\t\n\t      /**\n\t       * @param {string} state\n\t       * @param {Object|string} [params]\n\t       * @return {string}\n\t       */\n\t      function createStateHash(state, params) {\n\t        if (!isString(state)) {\n\t          throw new Error('state should be a string');\n\t        }\n\t        if (isObject(params)) {\n\t          return state + toJson(params);\n\t        }\n\t        params = $scope.$eval(params);\n\t        if (isObject(params)) {\n\t          return state + toJson(params);\n\t        }\n\t        return state;\n\t      }\n\t\n\t      // Update route state\n\t      function update() {\n\t        for (var i = 0; i < states.length; i++) {\n\t          if (anyMatch(states[i].state, states[i].params)) {\n\t            addClass($element, activeClasses[states[i].hash]);\n\t          } else {\n\t            removeClass($element, activeClasses[states[i].hash]);\n\t          }\n\t\n\t          if (exactMatch(states[i].state, states[i].params)) {\n\t            addClass($element, activeEqClass);\n\t          } else {\n\t            removeClass($element, activeEqClass);\n\t          }\n\t        }\n\t      }\n\t\n\t      function addClass(el, className) { $timeout(function () { el.addClass(className); }); }\n\t      function removeClass(el, className) { el.removeClass(className); }\n\t      function anyMatch(state, params) { return $state.includes(state.name, params); }\n\t      function exactMatch(state, params) { return $state.is(state.name, params); }\n\t\n\t      update();\n\t    }]\n\t  };\n\t}\n\t\n\tangular.module('ui.router.state')\n\t  .directive('uiSref', $StateRefDirective)\n\t  .directive('uiSrefActive', $StateRefActiveDirective)\n\t  .directive('uiSrefActiveEq', $StateRefActiveDirective)\n\t  .directive('uiState', $StateRefDynamicDirective);\n\t\n\t/**\n\t * @ngdoc filter\n\t * @name ui.router.state.filter:isState\n\t *\n\t * @requires ui.router.state.$state\n\t *\n\t * @description\n\t * Translates to {@link ui.router.state.$state#methods_is $state.is(\"stateName\")}.\n\t */\n\t$IsStateFilter.$inject = ['$state'];\n\tfunction $IsStateFilter($state) {\n\t  var isFilter = function (state, params) {\n\t    return $state.is(state, params);\n\t  };\n\t  isFilter.$stateful = true;\n\t  return isFilter;\n\t}\n\t\n\t/**\n\t * @ngdoc filter\n\t * @name ui.router.state.filter:includedByState\n\t *\n\t * @requires ui.router.state.$state\n\t *\n\t * @description\n\t * Translates to {@link ui.router.state.$state#methods_includes $state.includes('fullOrPartialStateName')}.\n\t */\n\t$IncludedByStateFilter.$inject = ['$state'];\n\tfunction $IncludedByStateFilter($state) {\n\t  var includesFilter = function (state, params, options) {\n\t    return $state.includes(state, params, options);\n\t  };\n\t  includesFilter.$stateful = true;\n\t  return  includesFilter;\n\t}\n\t\n\tangular.module('ui.router.state')\n\t  .filter('isState', $IsStateFilter)\n\t  .filter('includedByState', $IncludedByStateFilter);\n\t})(window, window.angular);\n\n/***/ },\n/* 8 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*!\n\t * angular-translate - v2.11.1 - 2016-07-17\n\t * \n\t * Copyright (c) 2016 The angular-translate team, Pascal Precht; Licensed MIT\n\t */\n\t(function (root, factory) {\n\t  if (true) {\n\t    // AMD. Register as an anonymous module unless amdModuleId is set\n\t    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = function () {\n\t      return (factory());\n\t    }.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\t  } else if (typeof exports === 'object') {\n\t    // Node. Does not work with strict CommonJS, but\n\t    // only CommonJS-like environments that support module.exports,\n\t    // like Node.\n\t    module.exports = factory();\n\t  } else {\n\t    factory();\n\t  }\n\t}(this, function () {\n\t\n\t/**\n\t * @ngdoc overview\n\t * @name pascalprecht.translate\n\t *\n\t * @description\n\t * The main module which holds everything together.\n\t */\n\trunTranslate.$inject = ['$translate'];\n\t$translate.$inject = ['$STORAGE_KEY', '$windowProvider', '$translateSanitizationProvider', 'pascalprechtTranslateOverrider'];\n\t$translateDefaultInterpolation.$inject = ['$interpolate', '$translateSanitization'];\n\ttranslateDirective.$inject = ['$translate', '$q', '$interpolate', '$compile', '$parse', '$rootScope'];\n\ttranslateCloakDirective.$inject = ['$translate', '$rootScope'];\n\ttranslateFilterFactory.$inject = ['$parse', '$translate'];\n\t$translationCache.$inject = ['$cacheFactory'];\n\tangular.module('pascalprecht.translate', ['ng'])\n\t  .run(runTranslate);\n\t\n\tfunction runTranslate($translate) {\n\t\n\t  'use strict';\n\t\n\t  var key = $translate.storageKey(),\n\t    storage = $translate.storage();\n\t\n\t  var fallbackFromIncorrectStorageValue = function () {\n\t    var preferred = $translate.preferredLanguage();\n\t    if (angular.isString(preferred)) {\n\t      $translate.use(preferred);\n\t      // $translate.use() will also remember the language.\n\t      // So, we don't need to call storage.put() here.\n\t    } else {\n\t      storage.put(key, $translate.use());\n\t    }\n\t  };\n\t\n\t  fallbackFromIncorrectStorageValue.displayName = 'fallbackFromIncorrectStorageValue';\n\t\n\t  if (storage) {\n\t    if (!storage.get(key)) {\n\t      fallbackFromIncorrectStorageValue();\n\t    } else {\n\t      $translate.use(storage.get(key))['catch'](fallbackFromIncorrectStorageValue);\n\t    }\n\t  } else if (angular.isString($translate.preferredLanguage())) {\n\t    $translate.use($translate.preferredLanguage());\n\t  }\n\t}\n\t\n\trunTranslate.displayName = 'runTranslate';\n\t\n\t/**\n\t * @ngdoc object\n\t * @name pascalprecht.translate.$translateSanitizationProvider\n\t *\n\t * @description\n\t *\n\t * Configurations for $translateSanitization\n\t */\n\tangular.module('pascalprecht.translate').provider('$translateSanitization', $translateSanitizationProvider);\n\t\n\tfunction $translateSanitizationProvider () {\n\t\n\t  'use strict';\n\t\n\t  var $sanitize,\n\t      currentStrategy = null, // TODO change to either 'sanitize', 'escape' or ['sanitize', 'escapeParameters'] in 3.0.\n\t      hasConfiguredStrategy = false,\n\t      hasShownNoStrategyConfiguredWarning = false,\n\t      strategies;\n\t\n\t  /**\n\t   * Definition of a sanitization strategy function\n\t   * @callback StrategyFunction\n\t   * @param {string|object} value - value to be sanitized (either a string or an interpolated value map)\n\t   * @param {string} mode - either 'text' for a string (translation) or 'params' for the interpolated params\n\t   * @return {string|object}\n\t   */\n\t\n\t  /**\n\t   * @ngdoc property\n\t   * @name strategies\n\t   * @propertyOf pascalprecht.translate.$translateSanitizationProvider\n\t   *\n\t   * @description\n\t   * Following strategies are built-in:\n\t   * <dl>\n\t   *   <dt>sanitize</dt>\n\t   *   <dd>Sanitizes HTML in the translation text using $sanitize</dd>\n\t   *   <dt>escape</dt>\n\t   *   <dd>Escapes HTML in the translation</dd>\n\t   *   <dt>sanitizeParameters</dt>\n\t   *   <dd>Sanitizes HTML in the values of the interpolation parameters using $sanitize</dd>\n\t   *   <dt>escapeParameters</dt>\n\t   *   <dd>Escapes HTML in the values of the interpolation parameters</dd>\n\t   *   <dt>escaped</dt>\n\t   *   <dd>Support legacy strategy name 'escaped' for backwards compatibility (will be removed in 3.0)</dd>\n\t   * </dl>\n\t   *\n\t   */\n\t\n\t  strategies = {\n\t    sanitize: function (value, mode) {\n\t      if (mode === 'text') {\n\t        value = htmlSanitizeValue(value);\n\t      }\n\t      return value;\n\t    },\n\t    escape: function (value, mode) {\n\t      if (mode === 'text') {\n\t        value = htmlEscapeValue(value);\n\t      }\n\t      return value;\n\t    },\n\t    sanitizeParameters: function (value, mode) {\n\t      if (mode === 'params') {\n\t        value = mapInterpolationParameters(value, htmlSanitizeValue);\n\t      }\n\t      return value;\n\t    },\n\t    escapeParameters: function (value, mode) {\n\t      if (mode === 'params') {\n\t        value = mapInterpolationParameters(value, htmlEscapeValue);\n\t      }\n\t      return value;\n\t    }\n\t  };\n\t  // Support legacy strategy name 'escaped' for backwards compatibility.\n\t  // TODO should be removed in 3.0\n\t  strategies.escaped = strategies.escapeParameters;\n\t\n\t  /**\n\t   * @ngdoc function\n\t   * @name pascalprecht.translate.$translateSanitizationProvider#addStrategy\n\t   * @methodOf pascalprecht.translate.$translateSanitizationProvider\n\t   *\n\t   * @description\n\t   * Adds a sanitization strategy to the list of known strategies.\n\t   *\n\t   * @param {string} strategyName - unique key for a strategy\n\t   * @param {StrategyFunction} strategyFunction - strategy function\n\t   * @returns {object} this\n\t   */\n\t  this.addStrategy = function (strategyName, strategyFunction) {\n\t    strategies[strategyName] = strategyFunction;\n\t    return this;\n\t  };\n\t\n\t  /**\n\t   * @ngdoc function\n\t   * @name pascalprecht.translate.$translateSanitizationProvider#removeStrategy\n\t   * @methodOf pascalprecht.translate.$translateSanitizationProvider\n\t   *\n\t   * @description\n\t   * Removes a sanitization strategy from the list of known strategies.\n\t   *\n\t   * @param {string} strategyName - unique key for a strategy\n\t   * @returns {object} this\n\t   */\n\t  this.removeStrategy = function (strategyName) {\n\t    delete strategies[strategyName];\n\t    return this;\n\t  };\n\t\n\t  /**\n\t   * @ngdoc function\n\t   * @name pascalprecht.translate.$translateSanitizationProvider#useStrategy\n\t   * @methodOf pascalprecht.translate.$translateSanitizationProvider\n\t   *\n\t   * @description\n\t   * Selects a sanitization strategy. When an array is provided the strategies will be executed in order.\n\t   *\n\t   * @param {string|StrategyFunction|array} strategy The sanitization strategy / strategies which should be used. Either a name of an existing strategy, a custom strategy function, or an array consisting of multiple names and / or custom functions.\n\t   * @returns {object} this\n\t   */\n\t  this.useStrategy = function (strategy) {\n\t    hasConfiguredStrategy = true;\n\t    currentStrategy = strategy;\n\t    return this;\n\t  };\n\t\n\t  /**\n\t   * @ngdoc object\n\t   * @name pascalprecht.translate.$translateSanitization\n\t   * @requires $injector\n\t   * @requires $log\n\t   *\n\t   * @description\n\t   * Sanitizes interpolation parameters and translated texts.\n\t   *\n\t   */\n\t  this.$get = ['$injector', '$log', function ($injector, $log) {\n\t\n\t    var cachedStrategyMap = {};\n\t\n\t    var applyStrategies = function (value, mode, selectedStrategies) {\n\t      angular.forEach(selectedStrategies, function (selectedStrategy) {\n\t        if (angular.isFunction(selectedStrategy)) {\n\t          value = selectedStrategy(value, mode);\n\t        } else if (angular.isFunction(strategies[selectedStrategy])) {\n\t          value = strategies[selectedStrategy](value, mode);\n\t        } else if (angular.isString(strategies[selectedStrategy])) {\n\t          if (!cachedStrategyMap[strategies[selectedStrategy]]) {\n\t            try {\n\t              cachedStrategyMap[strategies[selectedStrategy]] = $injector.get(strategies[selectedStrategy]);\n\t            } catch (e) {\n\t              cachedStrategyMap[strategies[selectedStrategy]] = function() {};\n\t              throw new Error('pascalprecht.translate.$translateSanitization: Unknown sanitization strategy: \\'' + selectedStrategy + '\\'');\n\t            }\n\t          }\n\t          value = cachedStrategyMap[strategies[selectedStrategy]](value, mode);\n\t        } else {\n\t          throw new Error('pascalprecht.translate.$translateSanitization: Unknown sanitization strategy: \\'' + selectedStrategy + '\\'');\n\t        }\n\t      });\n\t      return value;\n\t    };\n\t\n\t    // TODO: should be removed in 3.0\n\t    var showNoStrategyConfiguredWarning = function () {\n\t      if (!hasConfiguredStrategy && !hasShownNoStrategyConfiguredWarning) {\n\t        $log.warn('pascalprecht.translate.$translateSanitization: No sanitization strategy has been configured. This can have serious security implications. See http://angular-translate.github.io/docs/#/guide/19_security for details.');\n\t        hasShownNoStrategyConfiguredWarning = true;\n\t      }\n\t    };\n\t\n\t    if ($injector.has('$sanitize')) {\n\t      $sanitize = $injector.get('$sanitize');\n\t    }\n\t\n\t    return {\n\t      /**\n\t       * @ngdoc function\n\t       * @name pascalprecht.translate.$translateSanitization#useStrategy\n\t       * @methodOf pascalprecht.translate.$translateSanitization\n\t       *\n\t       * @description\n\t       * Selects a sanitization strategy. When an array is provided the strategies will be executed in order.\n\t       *\n\t       * @param {string|StrategyFunction|array} strategy The sanitization strategy / strategies which should be used. Either a name of an existing strategy, a custom strategy function, or an array consisting of multiple names and / or custom functions.\n\t       */\n\t      useStrategy: (function (self) {\n\t        return function (strategy) {\n\t          self.useStrategy(strategy);\n\t        };\n\t      })(this),\n\t\n\t      /**\n\t       * @ngdoc function\n\t       * @name pascalprecht.translate.$translateSanitization#sanitize\n\t       * @methodOf pascalprecht.translate.$translateSanitization\n\t       *\n\t       * @description\n\t       * Sanitizes a value.\n\t       *\n\t       * @param {string|object} value The value which should be sanitized.\n\t       * @param {string} mode The current sanitization mode, either 'params' or 'text'.\n\t       * @param {string|StrategyFunction|array} [strategy] Optional custom strategy which should be used instead of the currently selected strategy.\n\t       * @returns {string|object} sanitized value\n\t       */\n\t      sanitize: function (value, mode, strategy) {\n\t        if (!currentStrategy) {\n\t          showNoStrategyConfiguredWarning();\n\t        }\n\t\n\t        if (arguments.length < 3) {\n\t          strategy = currentStrategy;\n\t        }\n\t\n\t        if (!strategy) {\n\t          return value;\n\t        }\n\t\n\t        var selectedStrategies = angular.isArray(strategy) ? strategy : [strategy];\n\t        return applyStrategies(value, mode, selectedStrategies);\n\t      }\n\t    };\n\t  }];\n\t\n\t  var htmlEscapeValue = function (value) {\n\t    var element = angular.element('<div></div>');\n\t    element.text(value); // not chainable, see #1044\n\t    return element.html();\n\t  };\n\t\n\t  var htmlSanitizeValue = function (value) {\n\t    if (!$sanitize) {\n\t      throw new Error('pascalprecht.translate.$translateSanitization: Error cannot find $sanitize service. Either include the ngSanitize module (https://docs.angularjs.org/api/ngSanitize) or use a sanitization strategy which does not depend on $sanitize, such as \\'escape\\'.');\n\t    }\n\t    return $sanitize(value);\n\t  };\n\t\n\t  var mapInterpolationParameters = function (value, iteratee, stack) {\n\t    if (angular.isObject(value)) {\n\t      var result = angular.isArray(value) ? [] : {};\n\t\n\t      if (!stack) {\n\t        stack = [];\n\t      } else {\n\t        if (stack.indexOf(value) > -1) {\n\t          throw new Error('pascalprecht.translate.$translateSanitization: Error cannot interpolate parameter due recursive object');\n\t        }\n\t      }\n\t\n\t      stack.push(value);\n\t      angular.forEach(value, function (propertyValue, propertyKey) {\n\t\n\t        /* Skipping function properties. */\n\t        if (angular.isFunction(propertyValue)) {\n\t          return;\n\t        }\n\t\n\t        result[propertyKey] = mapInterpolationParameters(propertyValue, iteratee, stack);\n\t      });\n\t      stack.splice(-1, 1); // remove last\n\t\n\t      return result;\n\t    } else if (angular.isNumber(value)) {\n\t      return value;\n\t    } else {\n\t      return iteratee(value);\n\t    }\n\t  };\n\t}\n\t\n\t/**\n\t * @ngdoc object\n\t * @name pascalprecht.translate.$translateProvider\n\t * @description\n\t *\n\t * $translateProvider allows developers to register translation-tables, asynchronous loaders\n\t * and similar to configure translation behavior directly inside of a module.\n\t *\n\t */\n\tangular.module('pascalprecht.translate')\n\t.constant('pascalprechtTranslateOverrider', {})\n\t.provider('$translate', $translate);\n\t\n\tfunction $translate($STORAGE_KEY, $windowProvider, $translateSanitizationProvider, pascalprechtTranslateOverrider) {\n\t\n\t  'use strict';\n\t\n\t  var $translationTable = {},\n\t      $preferredLanguage,\n\t      $availableLanguageKeys = [],\n\t      $languageKeyAliases,\n\t      $fallbackLanguage,\n\t      $fallbackWasString,\n\t      $uses,\n\t      $nextLang,\n\t      $storageFactory,\n\t      $storageKey = $STORAGE_KEY,\n\t      $storagePrefix,\n\t      $missingTranslationHandlerFactory,\n\t      $interpolationFactory,\n\t      $interpolatorFactories = [],\n\t      $loaderFactory,\n\t      $cloakClassName = 'translate-cloak',\n\t      $loaderOptions,\n\t      $notFoundIndicatorLeft,\n\t      $notFoundIndicatorRight,\n\t      $postCompilingEnabled = false,\n\t      $forceAsyncReloadEnabled = false,\n\t      $nestedObjectDelimeter = '.',\n\t      $isReady = false,\n\t      $keepContent = false,\n\t      loaderCache,\n\t      directivePriority = 0,\n\t      statefulFilter = true,\n\t      postProcessFn,\n\t      uniformLanguageTagResolver = 'default',\n\t      languageTagResolver = {\n\t        'default': function (tag) {\n\t          return (tag || '').split('-').join('_');\n\t        },\n\t        java: function (tag) {\n\t          var temp = (tag || '').split('-').join('_');\n\t          var parts = temp.split('_');\n\t          return parts.length > 1 ? (parts[0].toLowerCase() + '_' + parts[1].toUpperCase()) : temp;\n\t        },\n\t        bcp47: function (tag) {\n\t          var temp = (tag || '').split('_').join('-');\n\t          var parts = temp.split('-');\n\t          return parts.length > 1 ? (parts[0].toLowerCase() + '-' + parts[1].toUpperCase()) : temp;\n\t        },\n\t        'iso639-1': function (tag) {\n\t          var temp = (tag || '').split('_').join('-');\n\t          var parts = temp.split('-');\n\t          return parts[0].toLowerCase();\n\t        }\n\t      };\n\t\n\t  var version = '2.11.1';\n\t\n\t  // tries to determine the browsers language\n\t  var getFirstBrowserLanguage = function () {\n\t\n\t    // internal purpose only\n\t    if (angular.isFunction(pascalprechtTranslateOverrider.getLocale)) {\n\t      return pascalprechtTranslateOverrider.getLocale();\n\t    }\n\t\n\t    var nav = $windowProvider.$get().navigator,\n\t        browserLanguagePropertyKeys = ['language', 'browserLanguage', 'systemLanguage', 'userLanguage'],\n\t        i,\n\t        language;\n\t\n\t    // support for HTML 5.1 \"navigator.languages\"\n\t    if (angular.isArray(nav.languages)) {\n\t      for (i = 0; i < nav.languages.length; i++) {\n\t        language = nav.languages[i];\n\t        if (language && language.length) {\n\t          return language;\n\t        }\n\t      }\n\t    }\n\t\n\t    // support for other well known properties in browsers\n\t    for (i = 0; i < browserLanguagePropertyKeys.length; i++) {\n\t      language = nav[browserLanguagePropertyKeys[i]];\n\t      if (language && language.length) {\n\t        return language;\n\t      }\n\t    }\n\t\n\t    return null;\n\t  };\n\t  getFirstBrowserLanguage.displayName = 'angular-translate/service: getFirstBrowserLanguage';\n\t\n\t  // tries to determine the browsers locale\n\t  var getLocale = function () {\n\t    var locale = getFirstBrowserLanguage() || '';\n\t    if (languageTagResolver[uniformLanguageTagResolver]) {\n\t      locale = languageTagResolver[uniformLanguageTagResolver](locale);\n\t    }\n\t    return locale;\n\t  };\n\t  getLocale.displayName = 'angular-translate/service: getLocale';\n\t\n\t  /**\n\t   * @name indexOf\n\t   * @private\n\t   *\n\t   * @description\n\t   * indexOf polyfill. Kinda sorta.\n\t   *\n\t   * @param {array} array Array to search in.\n\t   * @param {string} searchElement Element to search for.\n\t   *\n\t   * @returns {int} Index of search element.\n\t   */\n\t  var indexOf = function(array, searchElement) {\n\t    for (var i = 0, len = array.length; i < len; i++) {\n\t      if (array[i] === searchElement) {\n\t        return i;\n\t      }\n\t    }\n\t    return -1;\n\t  };\n\t\n\t  /**\n\t   * @name trim\n\t   * @private\n\t   *\n\t   * @description\n\t   * trim polyfill\n\t   *\n\t   * @returns {string} The string stripped of whitespace from both ends\n\t   */\n\t  var trim = function() {\n\t    return this.toString().replace(/^\\s+|\\s+$/g, '');\n\t  };\n\t\n\t  var negotiateLocale = function (preferred) {\n\t    if(!preferred) {\n\t      return;\n\t    }\n\t\n\t    var avail = [],\n\t        locale = angular.lowercase(preferred),\n\t        i = 0,\n\t        n = $availableLanguageKeys.length;\n\t\n\t    for (; i < n; i++) {\n\t      avail.push(angular.lowercase($availableLanguageKeys[i]));\n\t    }\n\t\n\t    // Check for an exact match in our list of available keys\n\t    if (indexOf(avail, locale) > -1) {\n\t      return preferred;\n\t    }\n\t\n\t    if ($languageKeyAliases) {\n\t      var alias;\n\t      for (var langKeyAlias in $languageKeyAliases) {\n\t        if ($languageKeyAliases.hasOwnProperty(langKeyAlias)) {\n\t          var hasWildcardKey = false;\n\t          var hasExactKey = Object.prototype.hasOwnProperty.call($languageKeyAliases, langKeyAlias) &&\n\t            angular.lowercase(langKeyAlias) === angular.lowercase(preferred);\n\t\n\t          if (langKeyAlias.slice(-1) === '*') {\n\t            hasWildcardKey = langKeyAlias.slice(0, -1) === preferred.slice(0, langKeyAlias.length - 1);\n\t          }\n\t          if (hasExactKey || hasWildcardKey) {\n\t            alias = $languageKeyAliases[langKeyAlias];\n\t            if (indexOf(avail, angular.lowercase(alias)) > -1) {\n\t              return alias;\n\t            }\n\t          }\n\t        }\n\t      }\n\t    }\n\t\n\t    // Check for a language code without region\n\t    var parts = preferred.split('_');\n\t\n\t    if (parts.length > 1 && indexOf(avail, angular.lowercase(parts[0])) > -1) {\n\t      return parts[0];\n\t    }\n\t\n\t    // If everything fails, return undefined.\n\t    return;\n\t  };\n\t\n\t  /**\n\t   * @ngdoc function\n\t   * @name pascalprecht.translate.$translateProvider#translations\n\t   * @methodOf pascalprecht.translate.$translateProvider\n\t   *\n\t   * @description\n\t   * Registers a new translation table for specific language key.\n\t   *\n\t   * To register a translation table for specific language, pass a defined language\n\t   * key as first parameter.\n\t   *\n\t   * <pre>\n\t   *  // register translation table for language: 'de_DE'\n\t   *  $translateProvider.translations('de_DE', {\n\t   *    'GREETING': 'Hallo Welt!'\n\t   *  });\n\t   *\n\t   *  // register another one\n\t   *  $translateProvider.translations('en_US', {\n\t   *    'GREETING': 'Hello world!'\n\t   *  });\n\t   * </pre>\n\t   *\n\t   * When registering multiple translation tables for for the same language key,\n\t   * the actual translation table gets extended. This allows you to define module\n\t   * specific translation which only get added, once a specific module is loaded in\n\t   * your app.\n\t   *\n\t   * Invoking this method with no arguments returns the translation table which was\n\t   * registered with no language key. Invoking it with a language key returns the\n\t   * related translation table.\n\t   *\n\t   * @param {string} langKey A language key.\n\t   * @param {object} translationTable A plain old JavaScript object that represents a translation table.\n\t   *\n\t   */\n\t  var translations = function (langKey, translationTable) {\n\t\n\t    if (!langKey && !translationTable) {\n\t      return $translationTable;\n\t    }\n\t\n\t    if (langKey && !translationTable) {\n\t      if (angular.isString(langKey)) {\n\t        return $translationTable[langKey];\n\t      }\n\t    } else {\n\t      if (!angular.isObject($translationTable[langKey])) {\n\t        $translationTable[langKey] = {};\n\t      }\n\t      angular.extend($translationTable[langKey], flatObject(translationTable));\n\t    }\n\t    return this;\n\t  };\n\t\n\t  this.translations = translations;\n\t\n\t  /**\n\t   * @ngdoc function\n\t   * @name pascalprecht.translate.$translateProvider#cloakClassName\n\t   * @methodOf pascalprecht.translate.$translateProvider\n\t   *\n\t   * @description\n\t   *\n\t   * Let's you change the class name for `translate-cloak` directive.\n\t   * Default class name is `translate-cloak`.\n\t   *\n\t   * @param {string} name translate-cloak class name\n\t   */\n\t  this.cloakClassName = function (name) {\n\t    if (!name) {\n\t      return $cloakClassName;\n\t    }\n\t    $cloakClassName = name;\n\t    return this;\n\t  };\n\t\n\t  /**\n\t   * @ngdoc function\n\t   * @name pascalprecht.translate.$translateProvider#nestedObjectDelimeter\n\t   * @methodOf pascalprecht.translate.$translateProvider\n\t   *\n\t   * @description\n\t   *\n\t   * Let's you change the delimiter for namespaced translations.\n\t   * Default delimiter is `.`.\n\t   *\n\t   * @param {string} delimiter namespace separator\n\t   */\n\t  this.nestedObjectDelimeter = function (delimiter) {\n\t    if (!delimiter) {\n\t      return $nestedObjectDelimeter;\n\t    }\n\t    $nestedObjectDelimeter = delimiter;\n\t    return this;\n\t  };\n\t\n\t  /**\n\t   * @name flatObject\n\t   * @private\n\t   *\n\t   * @description\n\t   * Flats an object. This function is used to flatten given translation data with\n\t   * namespaces, so they are later accessible via dot notation.\n\t   */\n\t  var flatObject = function (data, path, result, prevKey) {\n\t    var key, keyWithPath, keyWithShortPath, val;\n\t\n\t    if (!path) {\n\t      path = [];\n\t    }\n\t    if (!result) {\n\t      result = {};\n\t    }\n\t    for (key in data) {\n\t      if (!Object.prototype.hasOwnProperty.call(data, key)) {\n\t        continue;\n\t      }\n\t      val = data[key];\n\t      if (angular.isObject(val)) {\n\t        flatObject(val, path.concat(key), result, key);\n\t      } else {\n\t        keyWithPath = path.length ? ('' + path.join($nestedObjectDelimeter) + $nestedObjectDelimeter + key) : key;\n\t        if(path.length && key === prevKey){\n\t          // Create shortcut path (foo.bar == foo.bar.bar)\n\t          keyWithShortPath = '' + path.join($nestedObjectDelimeter);\n\t          // Link it to original path\n\t          result[keyWithShortPath] = '@:' + keyWithPath;\n\t        }\n\t        result[keyWithPath] = val;\n\t      }\n\t    }\n\t    return result;\n\t  };\n\t  flatObject.displayName = 'flatObject';\n\t\n\t  /**\n\t   * @ngdoc function\n\t   * @name pascalprecht.translate.$translateProvider#addInterpolation\n\t   * @methodOf pascalprecht.translate.$translateProvider\n\t   *\n\t   * @description\n\t   * Adds interpolation services to angular-translate, so it can manage them.\n\t   *\n\t   * @param {object} factory Interpolation service factory\n\t   */\n\t  this.addInterpolation = function (factory) {\n\t    $interpolatorFactories.push(factory);\n\t    return this;\n\t  };\n\t\n\t  /**\n\t   * @ngdoc function\n\t   * @name pascalprecht.translate.$translateProvider#useMessageFormatInterpolation\n\t   * @methodOf pascalprecht.translate.$translateProvider\n\t   *\n\t   * @description\n\t   * Tells angular-translate to use interpolation functionality of messageformat.js.\n\t   * This is useful when having high level pluralization and gender selection.\n\t   */\n\t  this.useMessageFormatInterpolation = function () {\n\t    return this.useInterpolation('$translateMessageFormatInterpolation');\n\t  };\n\t\n\t  /**\n\t   * @ngdoc function\n\t   * @name pascalprecht.translate.$translateProvider#useInterpolation\n\t   * @methodOf pascalprecht.translate.$translateProvider\n\t   *\n\t   * @description\n\t   * Tells angular-translate which interpolation style to use as default, application-wide.\n\t   * Simply pass a factory/service name. The interpolation service has to implement\n\t   * the correct interface.\n\t   *\n\t   * @param {string} factory Interpolation service name.\n\t   */\n\t  this.useInterpolation = function (factory) {\n\t    $interpolationFactory = factory;\n\t    return this;\n\t  };\n\t\n\t  /**\n\t   * @ngdoc function\n\t   * @name pascalprecht.translate.$translateProvider#useSanitizeStrategy\n\t   * @methodOf pascalprecht.translate.$translateProvider\n\t   *\n\t   * @description\n\t   * Simply sets a sanitation strategy type.\n\t   *\n\t   * @param {string} value Strategy type.\n\t   */\n\t  this.useSanitizeValueStrategy = function (value) {\n\t    $translateSanitizationProvider.useStrategy(value);\n\t    return this;\n\t  };\n\t\n\t /**\n\t   * @ngdoc function\n\t   * @name pascalprecht.translate.$translateProvider#preferredLanguage\n\t   * @methodOf pascalprecht.translate.$translateProvider\n\t   *\n\t   * @description\n\t   * Tells the module which of the registered translation tables to use for translation\n\t   * at initial startup by passing a language key. Similar to `$translateProvider#use`\n\t   * only that it says which language to **prefer**.\n\t   *\n\t   * @param {string} langKey A language key.\n\t   */\n\t  this.preferredLanguage = function(langKey) {\n\t    if (langKey) {\n\t      setupPreferredLanguage(langKey);\n\t      return this;\n\t    }\n\t    return $preferredLanguage;\n\t  };\n\t  var setupPreferredLanguage = function (langKey) {\n\t    if (langKey) {\n\t      $preferredLanguage = langKey;\n\t    }\n\t    return $preferredLanguage;\n\t  };\n\t  /**\n\t   * @ngdoc function\n\t   * @name pascalprecht.translate.$translateProvider#translationNotFoundIndicator\n\t   * @methodOf pascalprecht.translate.$translateProvider\n\t   *\n\t   * @description\n\t   * Sets an indicator which is used when a translation isn't found. E.g. when\n\t   * setting the indicator as 'X' and one tries to translate a translation id\n\t   * called `NOT_FOUND`, this will result in `X NOT_FOUND X`.\n\t   *\n\t   * Internally this methods sets a left indicator and a right indicator using\n\t   * `$translateProvider.translationNotFoundIndicatorLeft()` and\n\t   * `$translateProvider.translationNotFoundIndicatorRight()`.\n\t   *\n\t   * **Note**: These methods automatically add a whitespace between the indicators\n\t   * and the translation id.\n\t   *\n\t   * @param {string} indicator An indicator, could be any string.\n\t   */\n\t  this.translationNotFoundIndicator = function (indicator) {\n\t    this.translationNotFoundIndicatorLeft(indicator);\n\t    this.translationNotFoundIndicatorRight(indicator);\n\t    return this;\n\t  };\n\t\n\t  /**\n\t   * ngdoc function\n\t   * @name pascalprecht.translate.$translateProvider#translationNotFoundIndicatorLeft\n\t   * @methodOf pascalprecht.translate.$translateProvider\n\t   *\n\t   * @description\n\t   * Sets an indicator which is used when a translation isn't found left to the\n\t   * translation id.\n\t   *\n\t   * @param {string} indicator An indicator.\n\t   */\n\t  this.translationNotFoundIndicatorLeft = function (indicator) {\n\t    if (!indicator) {\n\t      return $notFoundIndicatorLeft;\n\t    }\n\t    $notFoundIndicatorLeft = indicator;\n\t    return this;\n\t  };\n\t\n\t  /**\n\t   * ngdoc function\n\t   * @name pascalprecht.translate.$translateProvider#translationNotFoundIndicatorLeft\n\t   * @methodOf pascalprecht.translate.$translateProvider\n\t   *\n\t   * @description\n\t   * Sets an indicator which is used when a translation isn't found right to the\n\t   * translation id.\n\t   *\n\t   * @param {string} indicator An indicator.\n\t   */\n\t  this.translationNotFoundIndicatorRight = function (indicator) {\n\t    if (!indicator) {\n\t      return $notFoundIndicatorRight;\n\t    }\n\t    $notFoundIndicatorRight = indicator;\n\t    return this;\n\t  };\n\t\n\t  /**\n\t   * @ngdoc function\n\t   * @name pascalprecht.translate.$translateProvider#fallbackLanguage\n\t   * @methodOf pascalprecht.translate.$translateProvider\n\t   *\n\t   * @description\n\t   * Tells the module which of the registered translation tables to use when missing translations\n\t   * at initial startup by passing a language key. Similar to `$translateProvider#use`\n\t   * only that it says which language to **fallback**.\n\t   *\n\t   * @param {string||array} langKey A language key.\n\t   *\n\t   */\n\t  this.fallbackLanguage = function (langKey) {\n\t    fallbackStack(langKey);\n\t    return this;\n\t  };\n\t\n\t  var fallbackStack = function (langKey) {\n\t    if (langKey) {\n\t      if (angular.isString(langKey)) {\n\t        $fallbackWasString = true;\n\t        $fallbackLanguage = [ langKey ];\n\t      } else if (angular.isArray(langKey)) {\n\t        $fallbackWasString = false;\n\t        $fallbackLanguage = langKey;\n\t      }\n\t      if (angular.isString($preferredLanguage)  && indexOf($fallbackLanguage, $preferredLanguage) < 0) {\n\t        $fallbackLanguage.push($preferredLanguage);\n\t      }\n\t\n\t      return this;\n\t    } else {\n\t      if ($fallbackWasString) {\n\t        return $fallbackLanguage[0];\n\t      } else {\n\t        return $fallbackLanguage;\n\t      }\n\t    }\n\t  };\n\t\n\t  /**\n\t   * @ngdoc function\n\t   * @name pascalprecht.translate.$translateProvider#use\n\t   * @methodOf pascalprecht.translate.$translateProvider\n\t   *\n\t   * @description\n\t   * Set which translation table to use for translation by given language key. When\n\t   * trying to 'use' a language which isn't provided, it'll throw an error.\n\t   *\n\t   * You actually don't have to use this method since `$translateProvider#preferredLanguage`\n\t   * does the job too.\n\t   *\n\t   * @param {string} langKey A language key.\n\t   */\n\t  this.use = function (langKey) {\n\t    if (langKey) {\n\t      if (!$translationTable[langKey] && (!$loaderFactory)) {\n\t        // only throw an error, when not loading translation data asynchronously\n\t        throw new Error('$translateProvider couldn\\'t find translationTable for langKey: \\'' + langKey + '\\'');\n\t      }\n\t      $uses = langKey;\n\t      return this;\n\t    }\n\t    return $uses;\n\t  };\n\t\n\t  /**\n\t   * @ngdoc function\n\t   * @name pascalprecht.translate.$translateProvider#resolveClientLocale\n\t   * @methodOf pascalprecht.translate.$translateProvider\n\t   *\n\t   * @description\n\t   * This returns the current browser/client's language key. The result is processed with the configured uniform tag resolver.\n\t   *\n\t   * @returns {string} the current client/browser language key\n\t   */\n\t  this.resolveClientLocale = function () {\n\t    return getLocale();\n\t  };\n\t\n\t /**\n\t   * @ngdoc function\n\t   * @name pascalprecht.translate.$translateProvider#storageKey\n\t   * @methodOf pascalprecht.translate.$translateProvider\n\t   *\n\t   * @description\n\t   * Tells the module which key must represent the choosed language by a user in the storage.\n\t   *\n\t   * @param {string} key A key for the storage.\n\t   */\n\t  var storageKey = function(key) {\n\t    if (!key) {\n\t      if ($storagePrefix) {\n\t        return $storagePrefix + $storageKey;\n\t      }\n\t      return $storageKey;\n\t    }\n\t    $storageKey = key;\n\t    return this;\n\t  };\n\t\n\t  this.storageKey = storageKey;\n\t\n\t  /**\n\t   * @ngdoc function\n\t   * @name pascalprecht.translate.$translateProvider#useUrlLoader\n\t   * @methodOf pascalprecht.translate.$translateProvider\n\t   *\n\t   * @description\n\t   * Tells angular-translate to use `$translateUrlLoader` extension service as loader.\n\t   *\n\t   * @param {string} url Url\n\t   * @param {Object=} options Optional configuration object\n\t   */\n\t  this.useUrlLoader = function (url, options) {\n\t    return this.useLoader('$translateUrlLoader', angular.extend({ url: url }, options));\n\t  };\n\t\n\t  /**\n\t   * @ngdoc function\n\t   * @name pascalprecht.translate.$translateProvider#useStaticFilesLoader\n\t   * @methodOf pascalprecht.translate.$translateProvider\n\t   *\n\t   * @description\n\t   * Tells angular-translate to use `$translateStaticFilesLoader` extension service as loader.\n\t   *\n\t   * @param {Object=} options Optional configuration object\n\t   */\n\t  this.useStaticFilesLoader = function (options) {\n\t    return this.useLoader('$translateStaticFilesLoader', options);\n\t  };\n\t\n\t  /**\n\t   * @ngdoc function\n\t   * @name pascalprecht.translate.$translateProvider#useLoader\n\t   * @methodOf pascalprecht.translate.$translateProvider\n\t   *\n\t   * @description\n\t   * Tells angular-translate to use any other service as loader.\n\t   *\n\t   * @param {string} loaderFactory Factory name to use\n\t   * @param {Object=} options Optional configuration object\n\t   */\n\t  this.useLoader = function (loaderFactory, options) {\n\t    $loaderFactory = loaderFactory;\n\t    $loaderOptions = options || {};\n\t    return this;\n\t  };\n\t\n\t  /**\n\t   * @ngdoc function\n\t   * @name pascalprecht.translate.$translateProvider#useLocalStorage\n\t   * @methodOf pascalprecht.translate.$translateProvider\n\t   *\n\t   * @description\n\t   * Tells angular-translate to use `$translateLocalStorage` service as storage layer.\n\t   *\n\t   */\n\t  this.useLocalStorage = function () {\n\t    return this.useStorage('$translateLocalStorage');\n\t  };\n\t\n\t  /**\n\t   * @ngdoc function\n\t   * @name pascalprecht.translate.$translateProvider#useCookieStorage\n\t   * @methodOf pascalprecht.translate.$translateProvider\n\t   *\n\t   * @description\n\t   * Tells angular-translate to use `$translateCookieStorage` service as storage layer.\n\t   */\n\t  this.useCookieStorage = function () {\n\t    return this.useStorage('$translateCookieStorage');\n\t  };\n\t\n\t  /**\n\t   * @ngdoc function\n\t   * @name pascalprecht.translate.$translateProvider#useStorage\n\t   * @methodOf pascalprecht.translate.$translateProvider\n\t   *\n\t   * @description\n\t   * Tells angular-translate to use custom service as storage layer.\n\t   */\n\t  this.useStorage = function (storageFactory) {\n\t    $storageFactory = storageFactory;\n\t    return this;\n\t  };\n\t\n\t  /**\n\t   * @ngdoc function\n\t   * @name pascalprecht.translate.$translateProvider#storagePrefix\n\t   * @methodOf pascalprecht.translate.$translateProvider\n\t   *\n\t   * @description\n\t   * Sets prefix for storage key.\n\t   *\n\t   * @param {string} prefix Storage key prefix\n\t   */\n\t  this.storagePrefix = function (prefix) {\n\t    if (!prefix) {\n\t      return prefix;\n\t    }\n\t    $storagePrefix = prefix;\n\t    return this;\n\t  };\n\t\n\t  /**\n\t   * @ngdoc function\n\t   * @name pascalprecht.translate.$translateProvider#useMissingTranslationHandlerLog\n\t   * @methodOf pascalprecht.translate.$translateProvider\n\t   *\n\t   * @description\n\t   * Tells angular-translate to use built-in log handler when trying to translate\n\t   * a translation Id which doesn't exist.\n\t   *\n\t   * This is actually a shortcut method for `useMissingTranslationHandler()`.\n\t   *\n\t   */\n\t  this.useMissingTranslationHandlerLog = function () {\n\t    return this.useMissingTranslationHandler('$translateMissingTranslationHandlerLog');\n\t  };\n\t\n\t  /**\n\t   * @ngdoc function\n\t   * @name pascalprecht.translate.$translateProvider#useMissingTranslationHandler\n\t   * @methodOf pascalprecht.translate.$translateProvider\n\t   *\n\t   * @description\n\t   * Expects a factory name which later gets instantiated with `$injector`.\n\t   * This method can be used to tell angular-translate to use a custom\n\t   * missingTranslationHandler. Just build a factory which returns a function\n\t   * and expects a translation id as argument.\n\t   *\n\t   * Example:\n\t   * <pre>\n\t   *  app.config(function ($translateProvider) {\n\t   *    $translateProvider.useMissingTranslationHandler('customHandler');\n\t   *  });\n\t   *\n\t   *  app.factory('customHandler', function (dep1, dep2) {\n\t   *    return function (translationId) {\n\t   *      // something with translationId and dep1 and dep2\n\t   *    };\n\t   *  });\n\t   * </pre>\n\t   *\n\t   * @param {string} factory Factory name\n\t   */\n\t  this.useMissingTranslationHandler = function (factory) {\n\t    $missingTranslationHandlerFactory = factory;\n\t    return this;\n\t  };\n\t\n\t  /**\n\t   * @ngdoc function\n\t   * @name pascalprecht.translate.$translateProvider#usePostCompiling\n\t   * @methodOf pascalprecht.translate.$translateProvider\n\t   *\n\t   * @description\n\t   * If post compiling is enabled, all translated values will be processed\n\t   * again with AngularJS' $compile.\n\t   *\n\t   * Example:\n\t   * <pre>\n\t   *  app.config(function ($translateProvider) {\n\t   *    $translateProvider.usePostCompiling(true);\n\t   *  });\n\t   * </pre>\n\t   *\n\t   * @param {string} factory Factory name\n\t   */\n\t  this.usePostCompiling = function (value) {\n\t    $postCompilingEnabled = !(!value);\n\t    return this;\n\t  };\n\t\n\t  /**\n\t   * @ngdoc function\n\t   * @name pascalprecht.translate.$translateProvider#forceAsyncReload\n\t   * @methodOf pascalprecht.translate.$translateProvider\n\t   *\n\t   * @description\n\t   * If force async reload is enabled, async loader will always be called\n\t   * even if $translationTable already contains the language key, adding\n\t   * possible new entries to the $translationTable.\n\t   *\n\t   * Example:\n\t   * <pre>\n\t   *  app.config(function ($translateProvider) {\n\t   *    $translateProvider.forceAsyncReload(true);\n\t   *  });\n\t   * </pre>\n\t   *\n\t   * @param {boolean} value - valid values are true or false\n\t   */\n\t  this.forceAsyncReload = function (value) {\n\t    $forceAsyncReloadEnabled = !(!value);\n\t    return this;\n\t  };\n\t\n\t  /**\n\t   * @ngdoc function\n\t   * @name pascalprecht.translate.$translateProvider#uniformLanguageTag\n\t   * @methodOf pascalprecht.translate.$translateProvider\n\t   *\n\t   * @description\n\t   * Tells angular-translate which language tag should be used as a result when determining\n\t   * the current browser language.\n\t   *\n\t   * This setting must be set before invoking {@link pascalprecht.translate.$translateProvider#methods_determinePreferredLanguage determinePreferredLanguage()}.\n\t   *\n\t   * <pre>\n\t   * $translateProvider\n\t   *   .uniformLanguageTag('bcp47')\n\t   *   .determinePreferredLanguage()\n\t   * </pre>\n\t   *\n\t   * The resolver currently supports:\n\t   * * default\n\t   *     (traditionally: hyphens will be converted into underscores, i.e. en-US => en_US)\n\t   *     en-US => en_US\n\t   *     en_US => en_US\n\t   *     en-us => en_us\n\t   * * java\n\t   *     like default, but the second part will be always in uppercase\n\t   *     en-US => en_US\n\t   *     en_US => en_US\n\t   *     en-us => en_US\n\t   * * BCP 47 (RFC 4646 & 4647)\n\t   *     en-US => en-US\n\t   *     en_US => en-US\n\t   *     en-us => en-US\n\t   *\n\t   * See also:\n\t   * * http://en.wikipedia.org/wiki/IETF_language_tag\n\t   * * http://www.w3.org/International/core/langtags/\n\t   * * http://tools.ietf.org/html/bcp47\n\t   *\n\t   * @param {string|object} options - options (or standard)\n\t   * @param {string} options.standard - valid values are 'default', 'bcp47', 'java'\n\t   */\n\t  this.uniformLanguageTag = function (options) {\n\t\n\t    if (!options) {\n\t      options = {};\n\t    } else if (angular.isString(options)) {\n\t      options = {\n\t        standard: options\n\t      };\n\t    }\n\t\n\t    uniformLanguageTagResolver = options.standard;\n\t\n\t    return this;\n\t  };\n\t\n\t  /**\n\t   * @ngdoc function\n\t   * @name pascalprecht.translate.$translateProvider#determinePreferredLanguage\n\t   * @methodOf pascalprecht.translate.$translateProvider\n\t   *\n\t   * @description\n\t   * Tells angular-translate to try to determine on its own which language key\n\t   * to set as preferred language. When `fn` is given, angular-translate uses it\n\t   * to determine a language key, otherwise it uses the built-in `getLocale()`\n\t   * method.\n\t   *\n\t   * The `getLocale()` returns a language key in the format `[lang]_[country]` or\n\t   * `[lang]` depending on what the browser provides.\n\t   *\n\t   * Use this method at your own risk, since not all browsers return a valid\n\t   * locale (see {@link pascalprecht.translate.$translateProvider#methods_uniformLanguageTag uniformLanguageTag()}).\n\t   *\n\t   * @param {Function=} fn Function to determine a browser's locale\n\t   */\n\t  this.determinePreferredLanguage = function (fn) {\n\t\n\t    var locale = (fn && angular.isFunction(fn)) ? fn() : getLocale();\n\t\n\t    if (!$availableLanguageKeys.length) {\n\t      $preferredLanguage = locale;\n\t    } else {\n\t      $preferredLanguage = negotiateLocale(locale) || locale;\n\t    }\n\t\n\t    return this;\n\t  };\n\t\n\t  /**\n\t   * @ngdoc function\n\t   * @name pascalprecht.translate.$translateProvider#registerAvailableLanguageKeys\n\t   * @methodOf pascalprecht.translate.$translateProvider\n\t   *\n\t   * @description\n\t   * Registers a set of language keys the app will work with. Use this method in\n\t   * combination with\n\t   * {@link pascalprecht.translate.$translateProvider#determinePreferredLanguage determinePreferredLanguage}.\n\t   * When available languages keys are registered, angular-translate\n\t   * tries to find the best fitting language key depending on the browsers locale,\n\t   * considering your language key convention.\n\t   *\n\t   * @param {object} languageKeys Array of language keys the your app will use\n\t   * @param {object=} aliases Alias map.\n\t   */\n\t  this.registerAvailableLanguageKeys = function (languageKeys, aliases) {\n\t    if (languageKeys) {\n\t      $availableLanguageKeys = languageKeys;\n\t      if (aliases) {\n\t        $languageKeyAliases = aliases;\n\t      }\n\t      return this;\n\t    }\n\t    return $availableLanguageKeys;\n\t  };\n\t\n\t  /**\n\t   * @ngdoc function\n\t   * @name pascalprecht.translate.$translateProvider#useLoaderCache\n\t   * @methodOf pascalprecht.translate.$translateProvider\n\t   *\n\t   * @description\n\t   * Registers a cache for internal $http based loaders.\n\t   * {@link pascalprecht.translate.$translationCache $translationCache}.\n\t   * When false the cache will be disabled (default). When true or undefined\n\t   * the cache will be a default (see $cacheFactory). When an object it will\n\t   * be treat as a cache object itself: the usage is $http({cache: cache})\n\t   *\n\t   * @param {object} cache boolean, string or cache-object\n\t   */\n\t  this.useLoaderCache = function (cache) {\n\t    if (cache === false) {\n\t      // disable cache\n\t      loaderCache = undefined;\n\t    } else if (cache === true) {\n\t      // enable cache using AJS defaults\n\t      loaderCache = true;\n\t    } else if (typeof(cache) === 'undefined') {\n\t      // enable cache using default\n\t      loaderCache = '$translationCache';\n\t    } else if (cache) {\n\t      // enable cache using given one (see $cacheFactory)\n\t      loaderCache = cache;\n\t    }\n\t    return this;\n\t  };\n\t\n\t  /**\n\t   * @ngdoc function\n\t   * @name pascalprecht.translate.$translateProvider#directivePriority\n\t   * @methodOf pascalprecht.translate.$translateProvider\n\t   *\n\t   * @description\n\t   * Sets the default priority of the translate directive. The standard value is `0`.\n\t   * Calling this function without an argument will return the current value.\n\t   *\n\t   * @param {number} priority for the translate-directive\n\t   */\n\t  this.directivePriority = function (priority) {\n\t    if (priority === undefined) {\n\t      // getter\n\t      return directivePriority;\n\t    } else {\n\t      // setter with chaining\n\t      directivePriority = priority;\n\t      return this;\n\t    }\n\t  };\n\t\n\t  /**\n\t   * @ngdoc function\n\t   * @name pascalprecht.translate.$translateProvider#statefulFilter\n\t   * @methodOf pascalprecht.translate.$translateProvider\n\t   *\n\t   * @description\n\t   * Since AngularJS 1.3, filters which are not stateless (depending at the scope)\n\t   * have to explicit define this behavior.\n\t   * Sets whether the translate filter should be stateful or stateless. The standard value is `true`\n\t   * meaning being stateful.\n\t   * Calling this function without an argument will return the current value.\n\t   *\n\t   * @param {boolean} state - defines the state of the filter\n\t   */\n\t  this.statefulFilter = function (state) {\n\t    if (state === undefined) {\n\t      // getter\n\t      return statefulFilter;\n\t    } else {\n\t      // setter with chaining\n\t      statefulFilter = state;\n\t      return this;\n\t    }\n\t  };\n\t\n\t  /**\n\t   * @ngdoc function\n\t   * @name pascalprecht.translate.$translateProvider#postProcess\n\t   * @methodOf pascalprecht.translate.$translateProvider\n\t   *\n\t   * @description\n\t   * The post processor will be intercept right after the translation result. It can modify the result.\n\t   *\n\t   * @param {object} fn Function or service name (string) to be called after the translation value has been set / resolved. The function itself will enrich every value being processed and then continue the normal resolver process\n\t   */\n\t  this.postProcess = function (fn) {\n\t    if (fn) {\n\t      postProcessFn = fn;\n\t    } else {\n\t      postProcessFn = undefined;\n\t    }\n\t    return this;\n\t  };\n\t\n\t  /**\n\t   * @ngdoc function\n\t   * @name pascalprecht.translate.$translateProvider#keepContent\n\t   * @methodOf pascalprecht.translate.$translateProvider\n\t   *\n\t   * @description\n\t   * If keepContent is set to true than translate directive will always use innerHTML\n\t   * as a default translation\n\t   *\n\t   * Example:\n\t   * <pre>\n\t   *  app.config(function ($translateProvider) {\n\t   *    $translateProvider.keepContent(true);\n\t   *  });\n\t   * </pre>\n\t   *\n\t   * @param {boolean} value - valid values are true or false\n\t   */\n\t  this.keepContent = function (value) {\n\t    $keepContent = !(!value);\n\t    return this;\n\t  };\n\t\n\t  /**\n\t   * @ngdoc object\n\t   * @name pascalprecht.translate.$translate\n\t   * @requires $interpolate\n\t   * @requires $log\n\t   * @requires $rootScope\n\t   * @requires $q\n\t   *\n\t   * @description\n\t   * The `$translate` service is the actual core of angular-translate. It expects a translation id\n\t   * and optional interpolate parameters to translate contents.\n\t   *\n\t   * <pre>\n\t   *  $translate('HEADLINE_TEXT').then(function (translation) {\n\t   *    $scope.translatedText = translation;\n\t   *  });\n\t   * </pre>\n\t   *\n\t   * @param {string|array} translationId A token which represents a translation id\n\t   *                                     This can be optionally an array of translation ids which\n\t   *                                     results that the function returns an object where each key\n\t   *                                     is the translation id and the value the translation.\n\t   * @param {object=} interpolateParams An object hash for dynamic values\n\t   * @param {string} interpolationId The id of the interpolation to use\n\t   * @param {string} defaultTranslationText the optional default translation text that is written as\n\t   *                                        as default text in case it is not found in any configured language\n\t   * @param {string} forceLanguage A language to be used instead of the current language\n\t   * @returns {object} promise\n\t   */\n\t  this.$get = [\n\t    '$log',\n\t    '$injector',\n\t    '$rootScope',\n\t    '$q',\n\t    function ($log, $injector, $rootScope, $q) {\n\t\n\t      var Storage,\n\t          defaultInterpolator = $injector.get($interpolationFactory || '$translateDefaultInterpolation'),\n\t          pendingLoader = false,\n\t          interpolatorHashMap = {},\n\t          langPromises = {},\n\t          fallbackIndex,\n\t          startFallbackIteration;\n\t\n\t      var $translate = function (translationId, interpolateParams, interpolationId, defaultTranslationText, forceLanguage) {\n\t        if (!$uses && $preferredLanguage) {\n\t          $uses = $preferredLanguage;\n\t        }\n\t        var uses = (forceLanguage && forceLanguage !== $uses) ? // we don't want to re-negotiate $uses\n\t              (negotiateLocale(forceLanguage) || forceLanguage) : $uses;\n\t\n\t        // Check forceLanguage is present\n\t        if (forceLanguage) {\n\t          loadTranslationsIfMissing(forceLanguage);\n\t        }\n\t\n\t        // Duck detection: If the first argument is an array, a bunch of translations was requested.\n\t        // The result is an object.\n\t        if (angular.isArray(translationId)) {\n\t          // Inspired by Q.allSettled by Kris Kowal\n\t          // https://github.com/kriskowal/q/blob/b0fa72980717dc202ffc3cbf03b936e10ebbb9d7/q.js#L1553-1563\n\t          // This transforms all promises regardless resolved or rejected\n\t          var translateAll = function (translationIds) {\n\t            var results = {}; // storing the actual results\n\t            var promises = []; // promises to wait for\n\t            // Wraps the promise a) being always resolved and b) storing the link id->value\n\t            var translate = function (translationId) {\n\t              var deferred = $q.defer();\n\t              var regardless = function (value) {\n\t                results[translationId] = value;\n\t                deferred.resolve([translationId, value]);\n\t              };\n\t              // we don't care whether the promise was resolved or rejected; just store the values\n\t              $translate(translationId, interpolateParams, interpolationId, defaultTranslationText, forceLanguage).then(regardless, regardless);\n\t              return deferred.promise;\n\t            };\n\t            for (var i = 0, c = translationIds.length; i < c; i++) {\n\t              promises.push(translate(translationIds[i]));\n\t            }\n\t            // wait for all (including storing to results)\n\t            return $q.all(promises).then(function () {\n\t              // return the results\n\t              return results;\n\t            });\n\t          };\n\t          return translateAll(translationId);\n\t        }\n\t\n\t        var deferred = $q.defer();\n\t\n\t        // trim off any whitespace\n\t        if (translationId) {\n\t          translationId = trim.apply(translationId);\n\t        }\n\t\n\t        var promiseToWaitFor = (function () {\n\t          var promise = $preferredLanguage ?\n\t            langPromises[$preferredLanguage] :\n\t            langPromises[uses];\n\t\n\t          fallbackIndex = 0;\n\t\n\t          if ($storageFactory && !promise) {\n\t            // looks like there's no pending promise for $preferredLanguage or\n\t            // $uses. Maybe there's one pending for a language that comes from\n\t            // storage.\n\t            var langKey = Storage.get($storageKey);\n\t            promise = langPromises[langKey];\n\t\n\t            if ($fallbackLanguage && $fallbackLanguage.length) {\n\t                var index = indexOf($fallbackLanguage, langKey);\n\t                // maybe the language from storage is also defined as fallback language\n\t                // we increase the fallback language index to not search in that language\n\t                // as fallback, since it's probably the first used language\n\t                // in that case the index starts after the first element\n\t                fallbackIndex = (index === 0) ? 1 : 0;\n\t\n\t                // but we can make sure to ALWAYS fallback to preferred language at least\n\t                if (indexOf($fallbackLanguage, $preferredLanguage) < 0) {\n\t                  $fallbackLanguage.push($preferredLanguage);\n\t                }\n\t            }\n\t          }\n\t          return promise;\n\t        }());\n\t\n\t        if (!promiseToWaitFor) {\n\t          // no promise to wait for? okay. Then there's no loader registered\n\t          // nor is a one pending for language that comes from storage.\n\t          // We can just translate.\n\t          determineTranslation(translationId, interpolateParams, interpolationId, defaultTranslationText, uses).then(deferred.resolve, deferred.reject);\n\t        } else {\n\t          var promiseResolved = function () {\n\t            // $uses may have changed while waiting\n\t            if (!forceLanguage) {\n\t              uses = $uses;\n\t            }\n\t            determineTranslation(translationId, interpolateParams, interpolationId, defaultTranslationText, uses).then(deferred.resolve, deferred.reject);\n\t          };\n\t          promiseResolved.displayName = 'promiseResolved';\n\t\n\t          promiseToWaitFor['finally'](promiseResolved);\n\t        }\n\t        return deferred.promise;\n\t      };\n\t\n\t      /**\n\t       * @name applyNotFoundIndicators\n\t       * @private\n\t       *\n\t       * @description\n\t       * Applies not fount indicators to given translation id, if needed.\n\t       * This function gets only executed, if a translation id doesn't exist,\n\t       * which is why a translation id is expected as argument.\n\t       *\n\t       * @param {string} translationId Translation id.\n\t       * @returns {string} Same as given translation id but applied with not found\n\t       * indicators.\n\t       */\n\t      var applyNotFoundIndicators = function (translationId) {\n\t        // applying notFoundIndicators\n\t        if ($notFoundIndicatorLeft) {\n\t          translationId = [$notFoundIndicatorLeft, translationId].join(' ');\n\t        }\n\t        if ($notFoundIndicatorRight) {\n\t          translationId = [translationId, $notFoundIndicatorRight].join(' ');\n\t        }\n\t        return translationId;\n\t      };\n\t\n\t      /**\n\t       * @name useLanguage\n\t       * @private\n\t       *\n\t       * @description\n\t       * Makes actual use of a language by setting a given language key as used\n\t       * language and informs registered interpolators to also use the given\n\t       * key as locale.\n\t       *\n\t       * @param {string} key Locale key.\n\t       */\n\t      var useLanguage = function (key) {\n\t        $uses = key;\n\t\n\t        // make sure to store new language key before triggering success event\n\t        if ($storageFactory) {\n\t          Storage.put($translate.storageKey(), $uses);\n\t        }\n\t\n\t        $rootScope.$emit('$translateChangeSuccess', {language: key});\n\t\n\t        // inform default interpolator\n\t        defaultInterpolator.setLocale($uses);\n\t\n\t        var eachInterpolator = function (interpolator, id) {\n\t          interpolatorHashMap[id].setLocale($uses);\n\t        };\n\t        eachInterpolator.displayName = 'eachInterpolatorLocaleSetter';\n\t\n\t        // inform all others too!\n\t        angular.forEach(interpolatorHashMap, eachInterpolator);\n\t        $rootScope.$emit('$translateChangeEnd', {language: key});\n\t      };\n\t\n\t      /**\n\t       * @name loadAsync\n\t       * @private\n\t       *\n\t       * @description\n\t       * Kicks of registered async loader using `$injector` and applies existing\n\t       * loader options. When resolved, it updates translation tables accordingly\n\t       * or rejects with given language key.\n\t       *\n\t       * @param {string} key Language key.\n\t       * @return {Promise} A promise.\n\t       */\n\t      var loadAsync = function (key) {\n\t        if (!key) {\n\t          throw 'No language key specified for loading.';\n\t        }\n\t\n\t        var deferred = $q.defer();\n\t\n\t        $rootScope.$emit('$translateLoadingStart', {language: key});\n\t        pendingLoader = true;\n\t\n\t        var cache = loaderCache;\n\t        if (typeof(cache) === 'string') {\n\t          // getting on-demand instance of loader\n\t          cache = $injector.get(cache);\n\t        }\n\t\n\t        var loaderOptions = angular.extend({}, $loaderOptions, {\n\t          key: key,\n\t          $http: angular.extend({}, {\n\t            cache: cache\n\t          }, $loaderOptions.$http)\n\t        });\n\t\n\t        var onLoaderSuccess = function (data) {\n\t          var translationTable = {};\n\t          $rootScope.$emit('$translateLoadingSuccess', {language: key});\n\t\n\t          if (angular.isArray(data)) {\n\t            angular.forEach(data, function (table) {\n\t              angular.extend(translationTable, flatObject(table));\n\t            });\n\t          } else {\n\t            angular.extend(translationTable, flatObject(data));\n\t          }\n\t          pendingLoader = false;\n\t          deferred.resolve({\n\t            key: key,\n\t            table: translationTable\n\t          });\n\t          $rootScope.$emit('$translateLoadingEnd', {language: key});\n\t        };\n\t        onLoaderSuccess.displayName = 'onLoaderSuccess';\n\t\n\t        var onLoaderError = function (key) {\n\t          $rootScope.$emit('$translateLoadingError', {language: key});\n\t          deferred.reject(key);\n\t          $rootScope.$emit('$translateLoadingEnd', {language: key});\n\t        };\n\t        onLoaderError.displayName = 'onLoaderError';\n\t\n\t        $injector.get($loaderFactory)(loaderOptions)\n\t          .then(onLoaderSuccess, onLoaderError);\n\t\n\t        return deferred.promise;\n\t      };\n\t\n\t      if ($storageFactory) {\n\t        Storage = $injector.get($storageFactory);\n\t\n\t        if (!Storage.get || !Storage.put) {\n\t          throw new Error('Couldn\\'t use storage \\'' + $storageFactory + '\\', missing get() or put() method!');\n\t        }\n\t      }\n\t\n\t      // if we have additional interpolations that were added via\n\t      // $translateProvider.addInterpolation(), we have to map'em\n\t      if ($interpolatorFactories.length) {\n\t        var eachInterpolationFactory = function (interpolatorFactory) {\n\t          var interpolator = $injector.get(interpolatorFactory);\n\t          // setting initial locale for each interpolation service\n\t          interpolator.setLocale($preferredLanguage || $uses);\n\t          // make'em recognizable through id\n\t          interpolatorHashMap[interpolator.getInterpolationIdentifier()] = interpolator;\n\t        };\n\t        eachInterpolationFactory.displayName = 'interpolationFactoryAdder';\n\t\n\t        angular.forEach($interpolatorFactories, eachInterpolationFactory);\n\t      }\n\t\n\t      /**\n\t       * @name getTranslationTable\n\t       * @private\n\t       *\n\t       * @description\n\t       * Returns a promise that resolves to the translation table\n\t       * or is rejected if an error occurred.\n\t       *\n\t       * @param langKey\n\t       * @returns {Q.promise}\n\t       */\n\t      var getTranslationTable = function (langKey) {\n\t        var deferred = $q.defer();\n\t        if (Object.prototype.hasOwnProperty.call($translationTable, langKey)) {\n\t          deferred.resolve($translationTable[langKey]);\n\t        } else if (langPromises[langKey]) {\n\t          var onResolve = function (data) {\n\t            translations(data.key, data.table);\n\t            deferred.resolve(data.table);\n\t          };\n\t          onResolve.displayName = 'translationTableResolver';\n\t          langPromises[langKey].then(onResolve, deferred.reject);\n\t        } else {\n\t          deferred.reject();\n\t        }\n\t        return deferred.promise;\n\t      };\n\t\n\t      /**\n\t       * @name getFallbackTranslation\n\t       * @private\n\t       *\n\t       * @description\n\t       * Returns a promise that will resolve to the translation\n\t       * or be rejected if no translation was found for the language.\n\t       * This function is currently only used for fallback language translation.\n\t       *\n\t       * @param langKey The language to translate to.\n\t       * @param translationId\n\t       * @param interpolateParams\n\t       * @param Interpolator\n\t       * @returns {Q.promise}\n\t       */\n\t      var getFallbackTranslation = function (langKey, translationId, interpolateParams, Interpolator) {\n\t        var deferred = $q.defer();\n\t\n\t        var onResolve = function (translationTable) {\n\t          if (Object.prototype.hasOwnProperty.call(translationTable, translationId)) {\n\t            Interpolator.setLocale(langKey);\n\t            var translation = translationTable[translationId];\n\t            if (translation.substr(0, 2) === '@:') {\n\t              getFallbackTranslation(langKey, translation.substr(2), interpolateParams, Interpolator)\n\t                .then(deferred.resolve, deferred.reject);\n\t            } else {\n\t              var interpolatedValue = Interpolator.interpolate(translationTable[translationId], interpolateParams);\n\t              interpolatedValue = applyPostProcessing(translationId, translationTable[translationId], interpolatedValue, interpolateParams, langKey);\n\t\n\t              deferred.resolve(interpolatedValue);\n\t\n\t            }\n\t            Interpolator.setLocale($uses);\n\t          } else {\n\t            deferred.reject();\n\t          }\n\t        };\n\t        onResolve.displayName = 'fallbackTranslationResolver';\n\t\n\t        getTranslationTable(langKey).then(onResolve, deferred.reject);\n\t\n\t        return deferred.promise;\n\t      };\n\t\n\t      /**\n\t       * @name getFallbackTranslationInstant\n\t       * @private\n\t       *\n\t       * @description\n\t       * Returns a translation\n\t       * This function is currently only used for fallback language translation.\n\t       *\n\t       * @param langKey The language to translate to.\n\t       * @param translationId\n\t       * @param interpolateParams\n\t       * @param Interpolator\n\t       * @returns {string} translation\n\t       */\n\t      var getFallbackTranslationInstant = function (langKey, translationId, interpolateParams, Interpolator) {\n\t        var result, translationTable = $translationTable[langKey];\n\t\n\t        if (translationTable && Object.prototype.hasOwnProperty.call(translationTable, translationId)) {\n\t          Interpolator.setLocale(langKey);\n\t          result = Interpolator.interpolate(translationTable[translationId], interpolateParams);\n\t          result = applyPostProcessing(translationId, translationTable[translationId], result, interpolateParams, langKey);\n\t          if (result.substr(0, 2) === '@:') {\n\t            return getFallbackTranslationInstant(langKey, result.substr(2), interpolateParams, Interpolator);\n\t          }\n\t          Interpolator.setLocale($uses);\n\t        }\n\t\n\t        return result;\n\t      };\n\t\n\t\n\t      /**\n\t       * @name translateByHandler\n\t       * @private\n\t       *\n\t       * Translate by missing translation handler.\n\t       *\n\t       * @param translationId\n\t       * @param interpolateParams\n\t       * @param defaultTranslationText\n\t       * @returns translation created by $missingTranslationHandler or translationId is $missingTranslationHandler is\n\t       * absent\n\t       */\n\t      var translateByHandler = function (translationId, interpolateParams, defaultTranslationText) {\n\t        // If we have a handler factory - we might also call it here to determine if it provides\n\t        // a default text for a translationid that can't be found anywhere in our tables\n\t        if ($missingTranslationHandlerFactory) {\n\t          var resultString = $injector.get($missingTranslationHandlerFactory)(translationId, $uses, interpolateParams, defaultTranslationText);\n\t          if (resultString !== undefined) {\n\t            return resultString;\n\t          } else {\n\t            return translationId;\n\t          }\n\t        } else {\n\t          return translationId;\n\t        }\n\t      };\n\t\n\t      /**\n\t       * @name resolveForFallbackLanguage\n\t       * @private\n\t       *\n\t       * Recursive helper function for fallbackTranslation that will sequentially look\n\t       * for a translation in the fallbackLanguages starting with fallbackLanguageIndex.\n\t       *\n\t       * @param fallbackLanguageIndex\n\t       * @param translationId\n\t       * @param interpolateParams\n\t       * @param Interpolator\n\t       * @returns {Q.promise} Promise that will resolve to the translation.\n\t       */\n\t      var resolveForFallbackLanguage = function (fallbackLanguageIndex, translationId, interpolateParams, Interpolator, defaultTranslationText) {\n\t        var deferred = $q.defer();\n\t\n\t        if (fallbackLanguageIndex < $fallbackLanguage.length) {\n\t          var langKey = $fallbackLanguage[fallbackLanguageIndex];\n\t          getFallbackTranslation(langKey, translationId, interpolateParams, Interpolator).then(\n\t            function (data) {\n\t                deferred.resolve(data);\n\t            },\n\t            function () {\n\t              // Look in the next fallback language for a translation.\n\t              // It delays the resolving by passing another promise to resolve.\n\t              return resolveForFallbackLanguage(fallbackLanguageIndex + 1, translationId, interpolateParams, Interpolator, defaultTranslationText).then(deferred.resolve, deferred.reject);\n\t            }\n\t          );\n\t        } else {\n\t          // No translation found in any fallback language\n\t          // if a default translation text is set in the directive, then return this as a result\n\t          if (defaultTranslationText) {\n\t            deferred.resolve(defaultTranslationText);\n\t          } else {\n\t            // if no default translation is set and an error handler is defined, send it to the handler\n\t            // and then return the result\n\t            if ($missingTranslationHandlerFactory) {\n\t              deferred.resolve(translateByHandler(translationId, interpolateParams));\n\t            } else {\n\t              deferred.reject(translateByHandler(translationId, interpolateParams));\n\t            }\n\t\n\t          }\n\t        }\n\t        return deferred.promise;\n\t      };\n\t\n\t      /**\n\t       * @name resolveForFallbackLanguageInstant\n\t       * @private\n\t       *\n\t       * Recursive helper function for fallbackTranslation that will sequentially look\n\t       * for a translation in the fallbackLanguages starting with fallbackLanguageIndex.\n\t       *\n\t       * @param fallbackLanguageIndex\n\t       * @param translationId\n\t       * @param interpolateParams\n\t       * @param Interpolator\n\t       * @returns {string} translation\n\t       */\n\t      var resolveForFallbackLanguageInstant = function (fallbackLanguageIndex, translationId, interpolateParams, Interpolator) {\n\t        var result;\n\t\n\t        if (fallbackLanguageIndex < $fallbackLanguage.length) {\n\t          var langKey = $fallbackLanguage[fallbackLanguageIndex];\n\t          result = getFallbackTranslationInstant(langKey, translationId, interpolateParams, Interpolator);\n\t          if (!result) {\n\t            result = resolveForFallbackLanguageInstant(fallbackLanguageIndex + 1, translationId, interpolateParams, Interpolator);\n\t          }\n\t        }\n\t        return result;\n\t      };\n\t\n\t      /**\n\t       * Translates with the usage of the fallback languages.\n\t       *\n\t       * @param translationId\n\t       * @param interpolateParams\n\t       * @param Interpolator\n\t       * @returns {Q.promise} Promise, that resolves to the translation.\n\t       */\n\t      var fallbackTranslation = function (translationId, interpolateParams, Interpolator, defaultTranslationText) {\n\t        // Start with the fallbackLanguage with index 0\n\t        return resolveForFallbackLanguage((startFallbackIteration>0 ? startFallbackIteration : fallbackIndex), translationId, interpolateParams, Interpolator, defaultTranslationText);\n\t      };\n\t\n\t      /**\n\t       * Translates with the usage of the fallback languages.\n\t       *\n\t       * @param translationId\n\t       * @param interpolateParams\n\t       * @param Interpolator\n\t       * @returns {String} translation\n\t       */\n\t      var fallbackTranslationInstant = function (translationId, interpolateParams, Interpolator) {\n\t        // Start with the fallbackLanguage with index 0\n\t        return resolveForFallbackLanguageInstant((startFallbackIteration>0 ? startFallbackIteration : fallbackIndex), translationId, interpolateParams, Interpolator);\n\t      };\n\t\n\t      var determineTranslation = function (translationId, interpolateParams, interpolationId, defaultTranslationText, uses) {\n\t\n\t        var deferred = $q.defer();\n\t\n\t        var table = uses ? $translationTable[uses] : $translationTable,\n\t            Interpolator = (interpolationId) ? interpolatorHashMap[interpolationId] : defaultInterpolator;\n\t\n\t        // if the translation id exists, we can just interpolate it\n\t        if (table && Object.prototype.hasOwnProperty.call(table, translationId)) {\n\t          var translation = table[translationId];\n\t\n\t          // If using link, rerun $translate with linked translationId and return it\n\t          if (translation.substr(0, 2) === '@:') {\n\t\n\t            $translate(translation.substr(2), interpolateParams, interpolationId, defaultTranslationText, uses)\n\t              .then(deferred.resolve, deferred.reject);\n\t          } else {\n\t            //\n\t            var resolvedTranslation = Interpolator.interpolate(translation, interpolateParams);\n\t            resolvedTranslation = applyPostProcessing(translationId, translation, resolvedTranslation, interpolateParams, uses);\n\t            deferred.resolve(resolvedTranslation);\n\t          }\n\t        } else {\n\t          var missingTranslationHandlerTranslation;\n\t          // for logging purposes only (as in $translateMissingTranslationHandlerLog), value is not returned to promise\n\t          if ($missingTranslationHandlerFactory && !pendingLoader) {\n\t            missingTranslationHandlerTranslation = translateByHandler(translationId, interpolateParams, defaultTranslationText);\n\t          }\n\t\n\t          // since we couldn't translate the inital requested translation id,\n\t          // we try it now with one or more fallback languages, if fallback language(s) is\n\t          // configured.\n\t          if (uses && $fallbackLanguage && $fallbackLanguage.length) {\n\t            fallbackTranslation(translationId, interpolateParams, Interpolator, defaultTranslationText)\n\t                .then(function (translation) {\n\t                  deferred.resolve(translation);\n\t                }, function (_translationId) {\n\t                  deferred.reject(applyNotFoundIndicators(_translationId));\n\t                });\n\t          } else if ($missingTranslationHandlerFactory && !pendingLoader && missingTranslationHandlerTranslation) {\n\t            // looks like the requested translation id doesn't exists.\n\t            // Now, if there is a registered handler for missing translations and no\n\t            // asyncLoader is pending, we execute the handler\n\t            if (defaultTranslationText) {\n\t              deferred.resolve(defaultTranslationText);\n\t              } else {\n\t                deferred.resolve(missingTranslationHandlerTranslation);\n\t              }\n\t          } else {\n\t            if (defaultTranslationText) {\n\t              deferred.resolve(defaultTranslationText);\n\t            } else {\n\t              deferred.reject(applyNotFoundIndicators(translationId));\n\t            }\n\t          }\n\t        }\n\t        return deferred.promise;\n\t      };\n\t\n\t      var determineTranslationInstant = function (translationId, interpolateParams, interpolationId, uses) {\n\t\n\t        var result, table = uses ? $translationTable[uses] : $translationTable,\n\t            Interpolator = defaultInterpolator;\n\t\n\t        // if the interpolation id exists use custom interpolator\n\t        if (interpolatorHashMap && Object.prototype.hasOwnProperty.call(interpolatorHashMap, interpolationId)) {\n\t          Interpolator = interpolatorHashMap[interpolationId];\n\t        }\n\t\n\t        // if the translation id exists, we can just interpolate it\n\t        if (table && Object.prototype.hasOwnProperty.call(table, translationId)) {\n\t          var translation = table[translationId];\n\t\n\t          // If using link, rerun $translate with linked translationId and return it\n\t          if (translation.substr(0, 2) === '@:') {\n\t            result = determineTranslationInstant(translation.substr(2), interpolateParams, interpolationId, uses);\n\t          } else {\n\t            result = Interpolator.interpolate(translation, interpolateParams);\n\t            result = applyPostProcessing(translationId, translation, result, interpolateParams, uses);\n\t          }\n\t        } else {\n\t          var missingTranslationHandlerTranslation;\n\t          // for logging purposes only (as in $translateMissingTranslationHandlerLog), value is not returned to promise\n\t          if ($missingTranslationHandlerFactory && !pendingLoader) {\n\t            missingTranslationHandlerTranslation = translateByHandler(translationId, interpolateParams);\n\t          }\n\t\n\t          // since we couldn't translate the inital requested translation id,\n\t          // we try it now with one or more fallback languages, if fallback language(s) is\n\t          // configured.\n\t          if (uses && $fallbackLanguage && $fallbackLanguage.length) {\n\t            fallbackIndex = 0;\n\t            result = fallbackTranslationInstant(translationId, interpolateParams, Interpolator);\n\t          } else if ($missingTranslationHandlerFactory && !pendingLoader && missingTranslationHandlerTranslation) {\n\t            // looks like the requested translation id doesn't exists.\n\t            // Now, if there is a registered handler for missing translations and no\n\t            // asyncLoader is pending, we execute the handler\n\t            result = missingTranslationHandlerTranslation;\n\t          } else {\n\t            result = applyNotFoundIndicators(translationId);\n\t          }\n\t        }\n\t\n\t        return result;\n\t      };\n\t\n\t      var clearNextLangAndPromise = function(key) {\n\t        if ($nextLang === key) {\n\t          $nextLang = undefined;\n\t        }\n\t        langPromises[key] = undefined;\n\t      };\n\t\n\t      var applyPostProcessing = function (translationId, translation, resolvedTranslation, interpolateParams, uses) {\n\t        var fn = postProcessFn;\n\t\n\t        if (fn) {\n\t\n\t          if (typeof(fn) === 'string') {\n\t            // getting on-demand instance\n\t            fn = $injector.get(fn);\n\t          }\n\t          if (fn) {\n\t            return fn(translationId, translation, resolvedTranslation, interpolateParams, uses);\n\t          }\n\t        }\n\t\n\t        return resolvedTranslation;\n\t      };\n\t\n\t      var loadTranslationsIfMissing = function (key) {\n\t        if (!$translationTable[key] && $loaderFactory && !langPromises[key]) {\n\t          langPromises[key] = loadAsync(key).then(function (translation) {\n\t            translations(translation.key, translation.table);\n\t            return translation;\n\t          });\n\t        }\n\t      };\n\t\n\t      /**\n\t       * @ngdoc function\n\t       * @name pascalprecht.translate.$translate#preferredLanguage\n\t       * @methodOf pascalprecht.translate.$translate\n\t       *\n\t       * @description\n\t       * Returns the language key for the preferred language.\n\t       *\n\t       * @param {string} langKey language String or Array to be used as preferredLanguage (changing at runtime)\n\t       *\n\t       * @return {string} preferred language key\n\t       */\n\t      $translate.preferredLanguage = function (langKey) {\n\t        if(langKey) {\n\t          setupPreferredLanguage(langKey);\n\t        }\n\t        return $preferredLanguage;\n\t      };\n\t\n\t      /**\n\t       * @ngdoc function\n\t       * @name pascalprecht.translate.$translate#cloakClassName\n\t       * @methodOf pascalprecht.translate.$translate\n\t       *\n\t       * @description\n\t       * Returns the configured class name for `translate-cloak` directive.\n\t       *\n\t       * @return {string} cloakClassName\n\t       */\n\t      $translate.cloakClassName = function () {\n\t        return $cloakClassName;\n\t      };\n\t\n\t      /**\n\t       * @ngdoc function\n\t       * @name pascalprecht.translate.$translate#nestedObjectDelimeter\n\t       * @methodOf pascalprecht.translate.$translate\n\t       *\n\t       * @description\n\t       * Returns the configured delimiter for nested namespaces.\n\t       *\n\t       * @return {string} nestedObjectDelimeter\n\t       */\n\t      $translate.nestedObjectDelimeter = function () {\n\t        return $nestedObjectDelimeter;\n\t      };\n\t\n\t      /**\n\t       * @ngdoc function\n\t       * @name pascalprecht.translate.$translate#fallbackLanguage\n\t       * @methodOf pascalprecht.translate.$translate\n\t       *\n\t       * @description\n\t       * Returns the language key for the fallback languages or sets a new fallback stack.\n\t       *\n\t       * @param {string=} langKey language String or Array of fallback languages to be used (to change stack at runtime)\n\t       *\n\t       * @return {string||array} fallback language key\n\t       */\n\t      $translate.fallbackLanguage = function (langKey) {\n\t        if (langKey !== undefined && langKey !== null) {\n\t          fallbackStack(langKey);\n\t\n\t          // as we might have an async loader initiated and a new translation language might have been defined\n\t          // we need to add the promise to the stack also. So - iterate.\n\t          if ($loaderFactory) {\n\t            if ($fallbackLanguage && $fallbackLanguage.length) {\n\t              for (var i = 0, len = $fallbackLanguage.length; i < len; i++) {\n\t                if (!langPromises[$fallbackLanguage[i]]) {\n\t                  langPromises[$fallbackLanguage[i]] = loadAsync($fallbackLanguage[i]);\n\t                }\n\t              }\n\t            }\n\t          }\n\t          $translate.use($translate.use());\n\t        }\n\t        if ($fallbackWasString) {\n\t          return $fallbackLanguage[0];\n\t        } else {\n\t          return $fallbackLanguage;\n\t        }\n\t\n\t      };\n\t\n\t      /**\n\t       * @ngdoc function\n\t       * @name pascalprecht.translate.$translate#useFallbackLanguage\n\t       * @methodOf pascalprecht.translate.$translate\n\t       *\n\t       * @description\n\t       * Sets the first key of the fallback language stack to be used for translation.\n\t       * Therefore all languages in the fallback array BEFORE this key will be skipped!\n\t       *\n\t       * @param {string=} langKey Contains the langKey the iteration shall start with. Set to false if you want to\n\t       * get back to the whole stack\n\t       */\n\t      $translate.useFallbackLanguage = function (langKey) {\n\t        if (langKey !== undefined && langKey !== null) {\n\t          if (!langKey) {\n\t            startFallbackIteration = 0;\n\t          } else {\n\t            var langKeyPosition = indexOf($fallbackLanguage, langKey);\n\t            if (langKeyPosition > -1) {\n\t              startFallbackIteration = langKeyPosition;\n\t            }\n\t          }\n\t\n\t        }\n\t\n\t      };\n\t\n\t      /**\n\t       * @ngdoc function\n\t       * @name pascalprecht.translate.$translate#proposedLanguage\n\t       * @methodOf pascalprecht.translate.$translate\n\t       *\n\t       * @description\n\t       * Returns the language key of language that is currently loaded asynchronously.\n\t       *\n\t       * @return {string} language key\n\t       */\n\t      $translate.proposedLanguage = function () {\n\t        return $nextLang;\n\t      };\n\t\n\t      /**\n\t       * @ngdoc function\n\t       * @name pascalprecht.translate.$translate#storage\n\t       * @methodOf pascalprecht.translate.$translate\n\t       *\n\t       * @description\n\t       * Returns registered storage.\n\t       *\n\t       * @return {object} Storage\n\t       */\n\t      $translate.storage = function () {\n\t        return Storage;\n\t      };\n\t\n\t      /**\n\t       * @ngdoc function\n\t       * @name pascalprecht.translate.$translate#negotiateLocale\n\t       * @methodOf pascalprecht.translate.$translate\n\t       *\n\t       * @description\n\t       * Returns a language key based on available languages and language aliases. If a\n\t       * language key cannot be resolved, returns undefined.\n\t       *\n\t       * If no or a falsy key is given, returns undefined.\n\t       *\n\t       * @param {string} [key] Language key\n\t       * @return {string|undefined} Language key or undefined if no language key is found.\n\t       */\n\t      $translate.negotiateLocale = negotiateLocale;\n\t\n\t      /**\n\t       * @ngdoc function\n\t       * @name pascalprecht.translate.$translate#use\n\t       * @methodOf pascalprecht.translate.$translate\n\t       *\n\t       * @description\n\t       * Tells angular-translate which language to use by given language key. This method is\n\t       * used to change language at runtime. It also takes care of storing the language\n\t       * key in a configured store to let your app remember the choosed language.\n\t       *\n\t       * When trying to 'use' a language which isn't available it tries to load it\n\t       * asynchronously with registered loaders.\n\t       *\n\t       * Returns promise object with loaded language file data or string of the currently used language.\n\t       *\n\t       * If no or a falsy key is given it returns the currently used language key.\n\t       * The returned string will be ```undefined``` if setting up $translate hasn't finished.\n\t       * @example\n\t       * $translate.use(\"en_US\").then(function(data){\n\t       *   $scope.text = $translate(\"HELLO\");\n\t       * });\n\t       *\n\t       * @param {string} [key] Language key\n\t       * @return {object|string} Promise with loaded language data or the language key if a falsy param was given.\n\t       */\n\t      $translate.use = function (key) {\n\t        if (!key) {\n\t          return $uses;\n\t        }\n\t\n\t        var deferred = $q.defer();\n\t\n\t        $rootScope.$emit('$translateChangeStart', {language: key});\n\t\n\t        // Try to get the aliased language key\n\t        var aliasedKey = negotiateLocale(key);\n\t        // Ensure only registered language keys will be loaded\n\t        if ($availableLanguageKeys.length > 0 && !aliasedKey) {\n\t          return $q.reject(key);\n\t        }\n\t\n\t        if (aliasedKey) {\n\t          key = aliasedKey;\n\t        }\n\t\n\t        // if there isn't a translation table for the language we've requested,\n\t        // we load it asynchronously\n\t        $nextLang = key;\n\t        if (($forceAsyncReloadEnabled || !$translationTable[key]) && $loaderFactory && !langPromises[key]) {\n\t          langPromises[key] = loadAsync(key).then(function (translation) {\n\t            translations(translation.key, translation.table);\n\t            deferred.resolve(translation.key);\n\t            if ($nextLang === key) {\n\t              useLanguage(translation.key);\n\t            }\n\t            return translation;\n\t          }, function (key) {\n\t            $rootScope.$emit('$translateChangeError', {language: key});\n\t            deferred.reject(key);\n\t            $rootScope.$emit('$translateChangeEnd', {language: key});\n\t            return $q.reject(key);\n\t          });\n\t          langPromises[key]['finally'](function () {\n\t            clearNextLangAndPromise(key);\n\t          });\n\t        } else if (langPromises[key]) {\n\t          // we are already loading this asynchronously\n\t          // resolve our new deferred when the old langPromise is resolved\n\t          langPromises[key].then(function (translation) {\n\t            if ($nextLang === translation.key) {\n\t              useLanguage(translation.key);\n\t            }\n\t            deferred.resolve(translation.key);\n\t            return translation;\n\t          }, function (key) {\n\t            // find first available fallback language if that request has failed\n\t            if (!$uses && $fallbackLanguage && $fallbackLanguage.length > 0) {\n\t              return $translate.use($fallbackLanguage[0]).then(deferred.resolve, deferred.reject);\n\t            } else {\n\t              return deferred.reject(key);\n\t            }\n\t          });\n\t        } else {\n\t          deferred.resolve(key);\n\t          useLanguage(key);\n\t        }\n\t\n\t        return deferred.promise;\n\t      };\n\t\n\t      /**\n\t       * @ngdoc function\n\t       * @name pascalprecht.translate.$translate#resolveClientLocale\n\t       * @methodOf pascalprecht.translate.$translate\n\t       *\n\t       * @description\n\t       * This returns the current browser/client's language key. The result is processed with the configured uniform tag resolver.\n\t       *\n\t       * @returns {string} the current client/browser language key\n\t       */\n\t      $translate.resolveClientLocale = function () {\n\t        return getLocale();\n\t      };\n\t\n\t      /**\n\t       * @ngdoc function\n\t       * @name pascalprecht.translate.$translate#storageKey\n\t       * @methodOf pascalprecht.translate.$translate\n\t       *\n\t       * @description\n\t       * Returns the key for the storage.\n\t       *\n\t       * @return {string} storage key\n\t       */\n\t      $translate.storageKey = function () {\n\t        return storageKey();\n\t      };\n\t\n\t      /**\n\t       * @ngdoc function\n\t       * @name pascalprecht.translate.$translate#isPostCompilingEnabled\n\t       * @methodOf pascalprecht.translate.$translate\n\t       *\n\t       * @description\n\t       * Returns whether post compiling is enabled or not\n\t       *\n\t       * @return {bool} storage key\n\t       */\n\t      $translate.isPostCompilingEnabled = function () {\n\t        return $postCompilingEnabled;\n\t      };\n\t\n\t      /**\n\t       * @ngdoc function\n\t       * @name pascalprecht.translate.$translate#isForceAsyncReloadEnabled\n\t       * @methodOf pascalprecht.translate.$translate\n\t       *\n\t       * @description\n\t       * Returns whether force async reload is enabled or not\n\t       *\n\t       * @return {boolean} forceAsyncReload value\n\t       */\n\t      $translate.isForceAsyncReloadEnabled = function () {\n\t        return $forceAsyncReloadEnabled;\n\t      };\n\t\n\t      /**\n\t       * @ngdoc function\n\t       * @name pascalprecht.translate.$translate#isKeepContent\n\t       * @methodOf pascalprecht.translate.$translate\n\t       *\n\t       * @description\n\t       * Returns whether keepContent or not\n\t       *\n\t       * @return {boolean} keepContent value\n\t       */\n\t      $translate.isKeepContent = function () {\n\t        return $keepContent;\n\t      };\n\t\n\t      /**\n\t       * @ngdoc function\n\t       * @name pascalprecht.translate.$translate#refresh\n\t       * @methodOf pascalprecht.translate.$translate\n\t       *\n\t       * @description\n\t       * Refreshes a translation table pointed by the given langKey. If langKey is not specified,\n\t       * the module will drop all existent translation tables and load new version of those which\n\t       * are currently in use.\n\t       *\n\t       * Refresh means that the module will drop target translation table and try to load it again.\n\t       *\n\t       * In case there are no loaders registered the refresh() method will throw an Error.\n\t       *\n\t       * If the module is able to refresh translation tables refresh() method will broadcast\n\t       * $translateRefreshStart and $translateRefreshEnd events.\n\t       *\n\t       * @example\n\t       * // this will drop all currently existent translation tables and reload those which are\n\t       * // currently in use\n\t       * $translate.refresh();\n\t       * // this will refresh a translation table for the en_US language\n\t       * $translate.refresh('en_US');\n\t       *\n\t       * @param {string} langKey A language key of the table, which has to be refreshed\n\t       *\n\t       * @return {promise} Promise, which will be resolved in case a translation tables refreshing\n\t       * process is finished successfully, and reject if not.\n\t       */\n\t      $translate.refresh = function (langKey) {\n\t        if (!$loaderFactory) {\n\t          throw new Error('Couldn\\'t refresh translation table, no loader registered!');\n\t        }\n\t\n\t        var deferred = $q.defer();\n\t\n\t        function resolve() {\n\t          deferred.resolve();\n\t          $rootScope.$emit('$translateRefreshEnd', {language: langKey});\n\t        }\n\t\n\t        function reject() {\n\t          deferred.reject();\n\t          $rootScope.$emit('$translateRefreshEnd', {language: langKey});\n\t        }\n\t\n\t        $rootScope.$emit('$translateRefreshStart', {language: langKey});\n\t\n\t        if (!langKey) {\n\t          // if there's no language key specified we refresh ALL THE THINGS!\n\t          var tables = [], loadingKeys = {};\n\t\n\t          // reload registered fallback languages\n\t          if ($fallbackLanguage && $fallbackLanguage.length) {\n\t            for (var i = 0, len = $fallbackLanguage.length; i < len; i++) {\n\t              tables.push(loadAsync($fallbackLanguage[i]));\n\t              loadingKeys[$fallbackLanguage[i]] = true;\n\t            }\n\t          }\n\t\n\t          // reload currently used language\n\t          if ($uses && !loadingKeys[$uses]) {\n\t            tables.push(loadAsync($uses));\n\t          }\n\t\n\t          var allTranslationsLoaded = function (tableData) {\n\t            $translationTable = {};\n\t            angular.forEach(tableData, function (data) {\n\t              translations(data.key, data.table);\n\t            });\n\t            if ($uses) {\n\t              useLanguage($uses);\n\t            }\n\t            resolve();\n\t          };\n\t          allTranslationsLoaded.displayName = 'refreshPostProcessor';\n\t\n\t          $q.all(tables).then(allTranslationsLoaded, reject);\n\t\n\t        } else if ($translationTable[langKey]) {\n\t\n\t          var oneTranslationsLoaded = function (data) {\n\t            translations(data.key, data.table);\n\t            if (langKey === $uses) {\n\t              useLanguage($uses);\n\t            }\n\t            resolve();\n\t            return data;\n\t          };\n\t          oneTranslationsLoaded.displayName = 'refreshPostProcessor';\n\t\n\t          loadAsync(langKey).then(oneTranslationsLoaded, reject);\n\t\n\t        } else {\n\t          reject();\n\t        }\n\t        return deferred.promise;\n\t      };\n\t\n\t      /**\n\t       * @ngdoc function\n\t       * @name pascalprecht.translate.$translate#instant\n\t       * @methodOf pascalprecht.translate.$translate\n\t       *\n\t       * @description\n\t       * Returns a translation instantly from the internal state of loaded translation. All rules\n\t       * regarding the current language, the preferred language of even fallback languages will be\n\t       * used except any promise handling. If a language was not found, an asynchronous loading\n\t       * will be invoked in the background.\n\t       *\n\t       * @param {string|array} translationId A token which represents a translation id\n\t       *                                     This can be optionally an array of translation ids which\n\t       *                                     results that the function's promise returns an object where\n\t       *                                     each key is the translation id and the value the translation.\n\t       * @param {object} interpolateParams Params\n\t       * @param {string} interpolationId The id of the interpolation to use\n\t       * @param {string} forceLanguage A language to be used instead of the current language\n\t       *\n\t       * @return {string|object} translation\n\t       */\n\t      $translate.instant = function (translationId, interpolateParams, interpolationId, forceLanguage) {\n\t\n\t        // we don't want to re-negotiate $uses\n\t        var uses = (forceLanguage && forceLanguage !== $uses) ? // we don't want to re-negotiate $uses\n\t              (negotiateLocale(forceLanguage) || forceLanguage) : $uses;\n\t\n\t        // Detect undefined and null values to shorten the execution and prevent exceptions\n\t        if (translationId === null || angular.isUndefined(translationId)) {\n\t          return translationId;\n\t        }\n\t\n\t        // Check forceLanguage is present\n\t        if (forceLanguage) {\n\t          loadTranslationsIfMissing(forceLanguage);\n\t        }\n\t\n\t        // Duck detection: If the first argument is an array, a bunch of translations was requested.\n\t        // The result is an object.\n\t        if (angular.isArray(translationId)) {\n\t          var results = {};\n\t          for (var i = 0, c = translationId.length; i < c; i++) {\n\t            results[translationId[i]] = $translate.instant(translationId[i], interpolateParams, interpolationId, forceLanguage);\n\t          }\n\t          return results;\n\t        }\n\t\n\t        // We discarded unacceptable values. So we just need to verify if translationId is empty String\n\t        if (angular.isString(translationId) && translationId.length < 1) {\n\t          return translationId;\n\t        }\n\t\n\t        // trim off any whitespace\n\t        if (translationId) {\n\t          translationId = trim.apply(translationId);\n\t        }\n\t\n\t        var result, possibleLangKeys = [];\n\t        if ($preferredLanguage) {\n\t          possibleLangKeys.push($preferredLanguage);\n\t        }\n\t        if (uses) {\n\t          possibleLangKeys.push(uses);\n\t        }\n\t        if ($fallbackLanguage && $fallbackLanguage.length) {\n\t          possibleLangKeys = possibleLangKeys.concat($fallbackLanguage);\n\t        }\n\t        for (var j = 0, d = possibleLangKeys.length; j < d; j++) {\n\t          var possibleLangKey = possibleLangKeys[j];\n\t          if ($translationTable[possibleLangKey]) {\n\t            if (typeof $translationTable[possibleLangKey][translationId] !== 'undefined') {\n\t              result = determineTranslationInstant(translationId, interpolateParams, interpolationId, uses);\n\t            }\n\t          }\n\t          if (typeof result !== 'undefined') {\n\t            break;\n\t          }\n\t        }\n\t\n\t        if (!result && result !== '') {\n\t          if ($notFoundIndicatorLeft || $notFoundIndicatorRight) {\n\t            result = applyNotFoundIndicators(translationId);\n\t          } else {\n\t            // Return translation of default interpolator if not found anything.\n\t            result = defaultInterpolator.interpolate(translationId, interpolateParams);\n\t            if ($missingTranslationHandlerFactory && !pendingLoader) {\n\t              result = translateByHandler(translationId, interpolateParams);\n\t            }\n\t          }\n\t        }\n\t\n\t        return result;\n\t      };\n\t\n\t      /**\n\t       * @ngdoc function\n\t       * @name pascalprecht.translate.$translate#versionInfo\n\t       * @methodOf pascalprecht.translate.$translate\n\t       *\n\t       * @description\n\t       * Returns the current version information for the angular-translate library\n\t       *\n\t       * @return {string} angular-translate version\n\t       */\n\t      $translate.versionInfo = function () {\n\t        return version;\n\t      };\n\t\n\t      /**\n\t       * @ngdoc function\n\t       * @name pascalprecht.translate.$translate#loaderCache\n\t       * @methodOf pascalprecht.translate.$translate\n\t       *\n\t       * @description\n\t       * Returns the defined loaderCache.\n\t       *\n\t       * @return {boolean|string|object} current value of loaderCache\n\t       */\n\t      $translate.loaderCache = function () {\n\t        return loaderCache;\n\t      };\n\t\n\t      // internal purpose only\n\t      $translate.directivePriority = function () {\n\t        return directivePriority;\n\t      };\n\t\n\t      // internal purpose only\n\t      $translate.statefulFilter = function () {\n\t        return statefulFilter;\n\t      };\n\t\n\t      /**\n\t       * @ngdoc function\n\t       * @name pascalprecht.translate.$translate#isReady\n\t       * @methodOf pascalprecht.translate.$translate\n\t       *\n\t       * @description\n\t       * Returns whether the service is \"ready\" to translate (i.e. loading 1st language).\n\t       *\n\t       * See also {@link pascalprecht.translate.$translate#methods_onReady onReady()}.\n\t       *\n\t       * @return {boolean} current value of ready\n\t       */\n\t      $translate.isReady = function () {\n\t        return $isReady;\n\t      };\n\t\n\t      var $onReadyDeferred = $q.defer();\n\t      $onReadyDeferred.promise.then(function () {\n\t        $isReady = true;\n\t      });\n\t\n\t      /**\n\t       * @ngdoc function\n\t       * @name pascalprecht.translate.$translate#onReady\n\t       * @methodOf pascalprecht.translate.$translate\n\t       *\n\t       * @description\n\t       * Returns whether the service is \"ready\" to translate (i.e. loading 1st language).\n\t       *\n\t       * See also {@link pascalprecht.translate.$translate#methods_isReady isReady()}.\n\t       *\n\t       * @param {Function=} fn Function to invoke when service is ready\n\t       * @return {object} Promise resolved when service is ready\n\t       */\n\t      $translate.onReady = function (fn) {\n\t        var deferred = $q.defer();\n\t        if (angular.isFunction(fn)) {\n\t          deferred.promise.then(fn);\n\t        }\n\t        if ($isReady) {\n\t          deferred.resolve();\n\t        } else {\n\t          $onReadyDeferred.promise.then(deferred.resolve);\n\t        }\n\t        return deferred.promise;\n\t      };\n\t\n\t      /**\n\t       * @ngdoc function\n\t       * @name pascalprecht.translate.$translate#getAvailableLanguageKeys\n\t       * @methodOf pascalprecht.translate.$translate\n\t       *\n\t       * @description\n\t       * This function simply returns the registered language keys being defined before in the config phase\n\t       * With this, an application can use the array to provide a language selection dropdown or similar\n\t       * without any additional effort\n\t       *\n\t       * @returns {object} returns the list of possibly registered language keys and mapping or null if not defined\n\t       */\n\t      $translate.getAvailableLanguageKeys = function () {\n\t        if ($availableLanguageKeys.length > 0) {\n\t          return $availableLanguageKeys;\n\t        }\n\t        return null;\n\t      };\n\t\n\t      // Whenever $translateReady is being fired, this will ensure the state of $isReady\n\t      var globalOnReadyListener = $rootScope.$on('$translateReady', function () {\n\t        $onReadyDeferred.resolve();\n\t        globalOnReadyListener(); // one time only\n\t        globalOnReadyListener = null;\n\t      });\n\t      var globalOnChangeListener = $rootScope.$on('$translateChangeEnd', function () {\n\t        $onReadyDeferred.resolve();\n\t        globalOnChangeListener(); // one time only\n\t        globalOnChangeListener = null;\n\t      });\n\t\n\t      if ($loaderFactory) {\n\t\n\t        // If at least one async loader is defined and there are no\n\t        // (default) translations available we should try to load them.\n\t        if (angular.equals($translationTable, {})) {\n\t          if ($translate.use()) {\n\t            $translate.use($translate.use());\n\t          }\n\t        }\n\t\n\t        // Also, if there are any fallback language registered, we start\n\t        // loading them asynchronously as soon as we can.\n\t        if ($fallbackLanguage && $fallbackLanguage.length) {\n\t          var processAsyncResult = function (translation) {\n\t            translations(translation.key, translation.table);\n\t            $rootScope.$emit('$translateChangeEnd', { language: translation.key });\n\t            return translation;\n\t          };\n\t          for (var i = 0, len = $fallbackLanguage.length; i < len; i++) {\n\t            var fallbackLanguageId = $fallbackLanguage[i];\n\t            if ($forceAsyncReloadEnabled || !$translationTable[fallbackLanguageId]) {\n\t              langPromises[fallbackLanguageId] = loadAsync(fallbackLanguageId).then(processAsyncResult);\n\t            }\n\t          }\n\t        }\n\t      } else {\n\t        $rootScope.$emit('$translateReady', { language: $translate.use() });\n\t      }\n\t\n\t      return $translate;\n\t    }\n\t  ];\n\t}\n\t\n\t$translate.displayName = 'displayName';\n\t\n\t/**\n\t * @ngdoc object\n\t * @name pascalprecht.translate.$translateDefaultInterpolation\n\t * @requires $interpolate\n\t *\n\t * @description\n\t * Uses angular's `$interpolate` services to interpolate strings against some values.\n\t *\n\t * Be aware to configure a proper sanitization strategy.\n\t *\n\t * See also:\n\t * * {@link pascalprecht.translate.$translateSanitization}\n\t *\n\t * @return {object} $translateDefaultInterpolation Interpolator service\n\t */\n\tangular.module('pascalprecht.translate').factory('$translateDefaultInterpolation', $translateDefaultInterpolation);\n\t\n\tfunction $translateDefaultInterpolation ($interpolate, $translateSanitization) {\n\t\n\t  'use strict';\n\t\n\t  var $translateInterpolator = {},\n\t      $locale,\n\t      $identifier = 'default';\n\t\n\t  /**\n\t   * @ngdoc function\n\t   * @name pascalprecht.translate.$translateDefaultInterpolation#setLocale\n\t   * @methodOf pascalprecht.translate.$translateDefaultInterpolation\n\t   *\n\t   * @description\n\t   * Sets current locale (this is currently not use in this interpolation).\n\t   *\n\t   * @param {string} locale Language key or locale.\n\t   */\n\t  $translateInterpolator.setLocale = function (locale) {\n\t    $locale = locale;\n\t  };\n\t\n\t  /**\n\t   * @ngdoc function\n\t   * @name pascalprecht.translate.$translateDefaultInterpolation#getInterpolationIdentifier\n\t   * @methodOf pascalprecht.translate.$translateDefaultInterpolation\n\t   *\n\t   * @description\n\t   * Returns an identifier for this interpolation service.\n\t   *\n\t   * @returns {string} $identifier\n\t   */\n\t  $translateInterpolator.getInterpolationIdentifier = function () {\n\t    return $identifier;\n\t  };\n\t\n\t  /**\n\t   * @deprecated will be removed in 3.0\n\t   * @see {@link pascalprecht.translate.$translateSanitization}\n\t   */\n\t  $translateInterpolator.useSanitizeValueStrategy = function (value) {\n\t    $translateSanitization.useStrategy(value);\n\t    return this;\n\t  };\n\t\n\t  /**\n\t   * @ngdoc function\n\t   * @name pascalprecht.translate.$translateDefaultInterpolation#interpolate\n\t   * @methodOf pascalprecht.translate.$translateDefaultInterpolation\n\t   *\n\t   * @description\n\t   * Interpolates given value agains given interpolate params using angulars\n\t   * `$interpolate` service.\n\t   *\n\t   * Since AngularJS 1.5, `value` must not be a string but can be anything input.\n\t   *\n\t   * @returns {string} interpolated string.\n\t   */\n\t  $translateInterpolator.interpolate = function (value, interpolationParams) {\n\t    interpolationParams = interpolationParams || {};\n\t    interpolationParams = $translateSanitization.sanitize(interpolationParams, 'params');\n\t\n\t    var interpolatedText;\n\t    if (angular.isNumber(value)) {\n\t      // numbers are safe\n\t      interpolatedText = '' + value;\n\t    } else if (angular.isString(value)) {\n\t      // strings must be interpolated (that's the job here)\n\t      interpolatedText = $interpolate(value)(interpolationParams);\n\t      interpolatedText = $translateSanitization.sanitize(interpolatedText, 'text');\n\t    } else {\n\t      // neither a number or a string, cant interpolate => empty string\n\t      interpolatedText = '';\n\t    }\n\t\n\t    return interpolatedText;\n\t  };\n\t\n\t  return $translateInterpolator;\n\t}\n\t\n\t$translateDefaultInterpolation.displayName = '$translateDefaultInterpolation';\n\t\n\tangular.module('pascalprecht.translate').constant('$STORAGE_KEY', 'NG_TRANSLATE_LANG_KEY');\n\t\n\tangular.module('pascalprecht.translate')\n\t/**\n\t * @ngdoc directive\n\t * @name pascalprecht.translate.directive:translate\n\t * @requires $compile\n\t * @requires $filter\n\t * @requires $interpolate\n\t * @restrict AE\n\t *\n\t * @description\n\t * Translates given translation id either through attribute or DOM content.\n\t * Internally it uses `translate` filter to translate translation id. It possible to\n\t * pass an optional `translate-values` object literal as string into translation id.\n\t *\n\t * @param {string=} translate Translation id which could be either string or interpolated string.\n\t * @param {string=} translate-values Values to pass into translation id. Can be passed as object literal string or interpolated object.\n\t * @param {string=} translate-attr-ATTR translate Translation id and put it into ATTR attribute.\n\t * @param {string=} translate-default will be used unless translation was successful\n\t * @param {boolean=} translate-compile (default true if present) defines locally activation of {@link pascalprecht.translate.$translateProvider#methods_usePostCompiling}\n\t * @param {boolean=} translate-keep-content (default true if present) defines that in case a KEY could not be translated, that the existing content is left in the innerHTML}\n\t *\n\t * @example\n\t   <example module=\"ngView\">\n\t    <file name=\"index.html\">\n\t      <div ng-controller=\"TranslateCtrl\">\n\t\n\t        <pre translate=\"TRANSLATION_ID\"></pre>\n\t        <pre translate>TRANSLATION_ID</pre>\n\t        <pre translate translate-attr-title=\"TRANSLATION_ID\"></pre>\n\t        <pre translate=\"{{translationId}}\"></pre>\n\t        <pre translate>{{translationId}}</pre>\n\t        <pre translate=\"WITH_VALUES\" translate-values=\"{value: 5}\"></pre>\n\t        <pre translate translate-values=\"{value: 5}\">WITH_VALUES</pre>\n\t        <pre translate=\"WITH_VALUES\" translate-values=\"{{values}}\"></pre>\n\t        <pre translate translate-values=\"{{values}}\">WITH_VALUES</pre>\n\t        <pre translate translate-attr-title=\"WITH_VALUES\" translate-values=\"{{values}}\"></pre>\n\t        <pre translate=\"WITH_CAMEL_CASE_KEY\" translate-value-camel-case-key=\"Hi\"></pre>\n\t\n\t      </div>\n\t    </file>\n\t    <file name=\"script.js\">\n\t      angular.module('ngView', ['pascalprecht.translate'])\n\t\n\t      .config(function ($translateProvider) {\n\t\n\t        $translateProvider.translations('en',{\n\t          'TRANSLATION_ID': 'Hello there!',\n\t          'WITH_VALUES': 'The following value is dynamic: {{value}}',\n\t          'WITH_CAMEL_CASE_KEY': 'The interpolation key is camel cased: {{camelCaseKey}}'\n\t        }).preferredLanguage('en');\n\t\n\t      });\n\t\n\t      angular.module('ngView').controller('TranslateCtrl', function ($scope) {\n\t        $scope.translationId = 'TRANSLATION_ID';\n\t\n\t        $scope.values = {\n\t          value: 78\n\t        };\n\t      });\n\t    </file>\n\t    <file name=\"scenario.js\">\n\t      it('should translate', function () {\n\t        inject(function ($rootScope, $compile) {\n\t          $rootScope.translationId = 'TRANSLATION_ID';\n\t\n\t          element = $compile('<p translate=\"TRANSLATION_ID\"></p>')($rootScope);\n\t          $rootScope.$digest();\n\t          expect(element.text()).toBe('Hello there!');\n\t\n\t          element = $compile('<p translate=\"{{translationId}}\"></p>')($rootScope);\n\t          $rootScope.$digest();\n\t          expect(element.text()).toBe('Hello there!');\n\t\n\t          element = $compile('<p translate>TRANSLATION_ID</p>')($rootScope);\n\t          $rootScope.$digest();\n\t          expect(element.text()).toBe('Hello there!');\n\t\n\t          element = $compile('<p translate>{{translationId}}</p>')($rootScope);\n\t          $rootScope.$digest();\n\t          expect(element.text()).toBe('Hello there!');\n\t\n\t          element = $compile('<p translate translate-attr-title=\"TRANSLATION_ID\"></p>')($rootScope);\n\t          $rootScope.$digest();\n\t          expect(element.attr('title')).toBe('Hello there!');\n\t\n\t          element = $compile('<p translate=\"WITH_CAMEL_CASE_KEY\" translate-value-camel-case-key=\"Hello\"></p>')($rootScope);\n\t          $rootScope.$digest();\n\t          expect(element.text()).toBe('The interpolation key is camel cased: Hello');\n\t        });\n\t      });\n\t    </file>\n\t   </example>\n\t */\n\t.directive('translate', translateDirective);\n\tfunction translateDirective($translate, $q, $interpolate, $compile, $parse, $rootScope) {\n\t\n\t  'use strict';\n\t\n\t  /**\n\t   * @name trim\n\t   * @private\n\t   *\n\t   * @description\n\t   * trim polyfill\n\t   *\n\t   * @returns {string} The string stripped of whitespace from both ends\n\t   */\n\t  var trim = function() {\n\t    return this.toString().replace(/^\\s+|\\s+$/g, '');\n\t  };\n\t\n\t  return {\n\t    restrict: 'AE',\n\t    scope: true,\n\t    priority: $translate.directivePriority(),\n\t    compile: function (tElement, tAttr) {\n\t\n\t      var translateValuesExist = (tAttr.translateValues) ?\n\t        tAttr.translateValues : undefined;\n\t\n\t      var translateInterpolation = (tAttr.translateInterpolation) ?\n\t        tAttr.translateInterpolation : undefined;\n\t\n\t      var translateValueExist = tElement[0].outerHTML.match(/translate-value-+/i);\n\t\n\t      var interpolateRegExp = '^(.*)(' + $interpolate.startSymbol() + '.*' + $interpolate.endSymbol() + ')(.*)',\n\t          watcherRegExp = '^(.*)' + $interpolate.startSymbol() + '(.*)' + $interpolate.endSymbol() + '(.*)';\n\t\n\t      return function linkFn(scope, iElement, iAttr) {\n\t\n\t        scope.interpolateParams = {};\n\t        scope.preText = '';\n\t        scope.postText = '';\n\t        scope.translateNamespace = getTranslateNamespace(scope);\n\t        var translationIds = {};\n\t\n\t        var initInterpolationParams = function (interpolateParams, iAttr, tAttr) {\n\t          // initial setup\n\t          if (iAttr.translateValues) {\n\t            angular.extend(interpolateParams, $parse(iAttr.translateValues)(scope.$parent));\n\t          }\n\t          // initially fetch all attributes if existing and fill the params\n\t          if (translateValueExist) {\n\t            for (var attr in tAttr) {\n\t              if (Object.prototype.hasOwnProperty.call(iAttr, attr) && attr.substr(0, 14) === 'translateValue' && attr !== 'translateValues') {\n\t                var attributeName = angular.lowercase(attr.substr(14, 1)) + attr.substr(15);\n\t                interpolateParams[attributeName] = tAttr[attr];\n\t              }\n\t            }\n\t          }\n\t        };\n\t\n\t        // Ensures any change of the attribute \"translate\" containing the id will\n\t        // be re-stored to the scope's \"translationId\".\n\t        // If the attribute has no content, the element's text value (white spaces trimmed off) will be used.\n\t        var observeElementTranslation = function (translationId) {\n\t\n\t          // Remove any old watcher\n\t          if (angular.isFunction(observeElementTranslation._unwatchOld)) {\n\t            observeElementTranslation._unwatchOld();\n\t            observeElementTranslation._unwatchOld = undefined;\n\t          }\n\t\n\t          if (angular.equals(translationId , '') || !angular.isDefined(translationId)) {\n\t            var iElementText = trim.apply(iElement.text());\n\t\n\t            // Resolve translation id by inner html if required\n\t            var interpolateMatches = iElementText.match(interpolateRegExp);\n\t            // Interpolate translation id if required\n\t            if (angular.isArray(interpolateMatches)) {\n\t              scope.preText = interpolateMatches[1];\n\t              scope.postText = interpolateMatches[3];\n\t              translationIds.translate = $interpolate(interpolateMatches[2])(scope.$parent);\n\t              var watcherMatches = iElementText.match(watcherRegExp);\n\t              if (angular.isArray(watcherMatches) && watcherMatches[2] && watcherMatches[2].length) {\n\t                observeElementTranslation._unwatchOld = scope.$watch(watcherMatches[2], function (newValue) {\n\t                  translationIds.translate = newValue;\n\t                  updateTranslations();\n\t                });\n\t              }\n\t            } else {\n\t              // do not assigne the translation id if it is empty.\n\t              translationIds.translate = !iElementText ? undefined : iElementText;\n\t            }\n\t          } else {\n\t            translationIds.translate = translationId;\n\t          }\n\t          updateTranslations();\n\t        };\n\t\n\t        var observeAttributeTranslation = function (translateAttr) {\n\t          iAttr.$observe(translateAttr, function (translationId) {\n\t            translationIds[translateAttr] = translationId;\n\t            updateTranslations();\n\t          });\n\t        };\n\t\n\t        // initial setup with values\n\t        initInterpolationParams(scope.interpolateParams, iAttr, tAttr);\n\t\n\t        var firstAttributeChangedEvent = true;\n\t        iAttr.$observe('translate', function (translationId) {\n\t          if (typeof translationId === 'undefined') {\n\t            // case of element \"<translate>xyz</translate>\"\n\t            observeElementTranslation('');\n\t          } else {\n\t            // case of regular attribute\n\t            if (translationId !== '' || !firstAttributeChangedEvent) {\n\t              translationIds.translate = translationId;\n\t              updateTranslations();\n\t            }\n\t          }\n\t          firstAttributeChangedEvent = false;\n\t        });\n\t\n\t        for (var translateAttr in iAttr) {\n\t          if (iAttr.hasOwnProperty(translateAttr) && translateAttr.substr(0, 13) === 'translateAttr') {\n\t            observeAttributeTranslation(translateAttr);\n\t          }\n\t        }\n\t\n\t        iAttr.$observe('translateDefault', function (value) {\n\t          scope.defaultText = value;\n\t          updateTranslations();\n\t        });\n\t\n\t        if (translateValuesExist) {\n\t          iAttr.$observe('translateValues', function (interpolateParams) {\n\t            if (interpolateParams) {\n\t              scope.$parent.$watch(function () {\n\t                angular.extend(scope.interpolateParams, $parse(interpolateParams)(scope.$parent));\n\t              });\n\t            }\n\t          });\n\t        }\n\t\n\t        if (translateValueExist) {\n\t          var observeValueAttribute = function (attrName) {\n\t            iAttr.$observe(attrName, function (value) {\n\t              var attributeName = angular.lowercase(attrName.substr(14, 1)) + attrName.substr(15);\n\t              scope.interpolateParams[attributeName] = value;\n\t            });\n\t          };\n\t          for (var attr in iAttr) {\n\t            if (Object.prototype.hasOwnProperty.call(iAttr, attr) && attr.substr(0, 14) === 'translateValue' && attr !== 'translateValues') {\n\t              observeValueAttribute(attr);\n\t            }\n\t          }\n\t        }\n\t\n\t        // Master update function\n\t        var updateTranslations = function () {\n\t          for (var key in translationIds) {\n\t            if (translationIds.hasOwnProperty(key) && translationIds[key] !== undefined) {\n\t              updateTranslation(key, translationIds[key], scope, scope.interpolateParams, scope.defaultText, scope.translateNamespace);\n\t            }\n\t          }\n\t        };\n\t\n\t        // Put translation processing function outside loop\n\t        var updateTranslation = function(translateAttr, translationId, scope, interpolateParams, defaultTranslationText, translateNamespace) {\n\t          if (translationId) {\n\t            // if translation id starts with '.' and translateNamespace given, prepend namespace\n\t            if (translateNamespace && translationId.charAt(0) === '.') {\n\t              translationId = translateNamespace + translationId;\n\t            }\n\t\n\t            $translate(translationId, interpolateParams, translateInterpolation, defaultTranslationText, scope.translateLanguage)\n\t              .then(function (translation) {\n\t                applyTranslation(translation, scope, true, translateAttr);\n\t              }, function (translationId) {\n\t                applyTranslation(translationId, scope, false, translateAttr);\n\t              });\n\t          } else {\n\t            // as an empty string cannot be translated, we can solve this using successful=false\n\t            applyTranslation(translationId, scope, false, translateAttr);\n\t          }\n\t        };\n\t\n\t        var applyTranslation = function (value, scope, successful, translateAttr) {\n\t          if (!successful) {\n\t            if (typeof scope.defaultText !== 'undefined') {\n\t              value = scope.defaultText;\n\t            }\n\t          }\n\t          if (translateAttr === 'translate') {\n\t            // default translate into innerHTML\n\t            if (successful || (!successful && !$translate.isKeepContent() && typeof iAttr.translateKeepContent === 'undefined')) {\n\t              iElement.empty().append(scope.preText + value + scope.postText);\n\t            }\n\t            var globallyEnabled = $translate.isPostCompilingEnabled();\n\t            var locallyDefined = typeof tAttr.translateCompile !== 'undefined';\n\t            var locallyEnabled = locallyDefined && tAttr.translateCompile !== 'false';\n\t            if ((globallyEnabled && !locallyDefined) || locallyEnabled) {\n\t              $compile(iElement.contents())(scope);\n\t            }\n\t          } else {\n\t            // translate attribute\n\t            var attributeName = iAttr.$attr[translateAttr];\n\t            if (attributeName.substr(0, 5) === 'data-') {\n\t              // ensure html5 data prefix is stripped\n\t              attributeName = attributeName.substr(5);\n\t            }\n\t            attributeName = attributeName.substr(15);\n\t            iElement.attr(attributeName, value);\n\t          }\n\t        };\n\t\n\t        if (translateValuesExist || translateValueExist || iAttr.translateDefault) {\n\t          scope.$watch('interpolateParams', updateTranslations, true);\n\t        }\n\t\n\t        // Replaced watcher on translateLanguage with event listener\n\t        var unbindTranslateLanguage = scope.$on('translateLanguageChanged', updateTranslations);\n\t\n\t        // Ensures the text will be refreshed after the current language was changed\n\t        // w/ $translate.use(...)\n\t        var unbind = $rootScope.$on('$translateChangeSuccess', updateTranslations);\n\t\n\t        // ensure translation will be looked up at least one\n\t        if (iElement.text().length) {\n\t          if (iAttr.translate) {\n\t            observeElementTranslation(iAttr.translate);\n\t          } else {\n\t            observeElementTranslation('');\n\t          }\n\t        } else if (iAttr.translate) {\n\t          // ensure attribute will be not skipped\n\t          observeElementTranslation(iAttr.translate);\n\t        }\n\t        updateTranslations();\n\t        scope.$on('$destroy', function(){\n\t          unbindTranslateLanguage();\n\t          unbind();\n\t        });\n\t      };\n\t    }\n\t  };\n\t}\n\t\n\t/**\n\t * Returns the scope's namespace.\n\t * @private\n\t * @param scope\n\t * @returns {string}\n\t */\n\tfunction getTranslateNamespace(scope) {\n\t  'use strict';\n\t  if (scope.translateNamespace) {\n\t    return scope.translateNamespace;\n\t  }\n\t  if (scope.$parent) {\n\t    return getTranslateNamespace(scope.$parent);\n\t  }\n\t}\n\t\n\ttranslateDirective.displayName = 'translateDirective';\n\t\n\tangular.module('pascalprecht.translate')\n\t/**\n\t * @ngdoc directive\n\t * @name pascalprecht.translate.directive:translateCloak\n\t * @requires $rootScope\n\t * @requires $translate\n\t * @restrict A\n\t *\n\t * $description\n\t * Adds a `translate-cloak` class name to the given element where this directive\n\t * is applied initially and removes it, once a loader has finished loading.\n\t *\n\t * This directive can be used to prevent initial flickering when loading translation\n\t * data asynchronously.\n\t *\n\t * The class name is defined in\n\t * {@link pascalprecht.translate.$translateProvider#cloakClassName $translate.cloakClassName()}.\n\t *\n\t * @param {string=} translate-cloak If a translationId is provided, it will be used for showing\n\t *                                  or hiding the cloak. Basically it relies on the translation\n\t *                                  resolve.\n\t */\n\t.directive('translateCloak', translateCloakDirective);\n\t\n\tfunction translateCloakDirective($translate, $rootScope) {\n\t\n\t  'use strict';\n\t\n\t  return {\n\t    compile: function (tElement) {\n\t      var applyCloak = function () {\n\t        tElement.addClass($translate.cloakClassName());\n\t      },\n\t      removeCloak = function () {\n\t        tElement.removeClass($translate.cloakClassName());\n\t      };\n\t      $translate.onReady(function () {\n\t        removeCloak();\n\t      });\n\t      applyCloak();\n\t\n\t      return function linkFn(scope, iElement, iAttr) {\n\t        if (iAttr.translateCloak && iAttr.translateCloak.length) {\n\t          // Register a watcher for the defined translation allowing a fine tuned cloak\n\t          iAttr.$observe('translateCloak', function (translationId) {\n\t            $translate(translationId).then(removeCloak, applyCloak);\n\t          });\n\t          // Register for change events as this is being another indicicator revalidating the cloak)\n\t          $rootScope.$on('$translateChangeSuccess', function () {\n\t            $translate(iAttr.translateCloak).then(removeCloak, applyCloak);\n\t          });\n\t        }\n\t      };\n\t    }\n\t  };\n\t}\n\t\n\ttranslateCloakDirective.displayName = 'translateCloakDirective';\n\t\n\tangular.module('pascalprecht.translate')\n\t/**\n\t * @ngdoc directive\n\t * @name pascalprecht.translate.directive:translateNamespace\n\t * @restrict A\n\t *\n\t * @description\n\t * Translates given translation id either through attribute or DOM content.\n\t * Internally it uses `translate` filter to translate translation id. It possible to\n\t * pass an optional `translate-values` object literal as string into translation id.\n\t *\n\t * @param {string=} translate namespace name which could be either string or interpolated string.\n\t *\n\t * @example\n\t   <example module=\"ngView\">\n\t    <file name=\"index.html\">\n\t      <div translate-namespace=\"CONTENT\">\n\t\n\t        <div>\n\t            <h1 translate>.HEADERS.TITLE</h1>\n\t            <h1 translate>.HEADERS.WELCOME</h1>\n\t        </div>\n\t\n\t        <div translate-namespace=\".HEADERS\">\n\t            <h1 translate>.TITLE</h1>\n\t            <h1 translate>.WELCOME</h1>\n\t        </div>\n\t\n\t      </div>\n\t    </file>\n\t    <file name=\"script.js\">\n\t      angular.module('ngView', ['pascalprecht.translate'])\n\t\n\t      .config(function ($translateProvider) {\n\t\n\t        $translateProvider.translations('en',{\n\t          'TRANSLATION_ID': 'Hello there!',\n\t          'CONTENT': {\n\t            'HEADERS': {\n\t                TITLE: 'Title'\n\t            }\n\t          },\n\t          'CONTENT.HEADERS.WELCOME': 'Welcome'\n\t        }).preferredLanguage('en');\n\t\n\t      });\n\t\n\t    </file>\n\t   </example>\n\t */\n\t.directive('translateNamespace', translateNamespaceDirective);\n\t\n\tfunction translateNamespaceDirective() {\n\t\n\t  'use strict';\n\t\n\t  return {\n\t    restrict: 'A',\n\t    scope: true,\n\t    compile: function () {\n\t      return {\n\t        pre: function (scope, iElement, iAttrs) {\n\t          scope.translateNamespace = getTranslateNamespace(scope);\n\t\n\t          if (scope.translateNamespace && iAttrs.translateNamespace.charAt(0) === '.') {\n\t            scope.translateNamespace += iAttrs.translateNamespace;\n\t          } else {\n\t            scope.translateNamespace = iAttrs.translateNamespace;\n\t          }\n\t        }\n\t      };\n\t    }\n\t  };\n\t}\n\t\n\t/**\n\t * Returns the scope's namespace.\n\t * @private\n\t * @param scope\n\t * @returns {string}\n\t */\n\tfunction getTranslateNamespace(scope) {\n\t  'use strict';\n\t  if (scope.translateNamespace) {\n\t    return scope.translateNamespace;\n\t  }\n\t  if (scope.$parent) {\n\t    return getTranslateNamespace(scope.$parent);\n\t  }\n\t}\n\t\n\ttranslateNamespaceDirective.displayName = 'translateNamespaceDirective';\n\t\n\tangular.module('pascalprecht.translate')\n\t/**\n\t * @ngdoc directive\n\t * @name pascalprecht.translate.directive:translateLanguage\n\t * @restrict A\n\t *\n\t * @description\n\t * Forces the language to the directives in the underlying scope.\n\t *\n\t * @param {string=} translate language that will be negotiated.\n\t *\n\t * @example\n\t   <example module=\"ngView\">\n\t    <file name=\"index.html\">\n\t      <div>\n\t\n\t        <div>\n\t            <h1 translate>HELLO</h1>\n\t        </div>\n\t\n\t        <div translate-language=\"de\">\n\t            <h1 translate>HELLO</h1>\n\t        </div>\n\t\n\t      </div>\n\t    </file>\n\t    <file name=\"script.js\">\n\t      angular.module('ngView', ['pascalprecht.translate'])\n\t\n\t      .config(function ($translateProvider) {\n\t\n\t        $translateProvider\n\t          .translations('en',{\n\t            'HELLO': 'Hello world!'\n\t          })\n\t          .translations('de',{\n\t            'HELLO': 'Hallo Welt!'\n\t          })\n\t          .preferredLanguage('en');\n\t\n\t      });\n\t\n\t    </file>\n\t   </example>\n\t */\n\t.directive('translateLanguage', translateLanguageDirective);\n\t\n\tfunction translateLanguageDirective() {\n\t\n\t  'use strict';\n\t\n\t  return {\n\t    restrict: 'A',\n\t    scope: true,\n\t    compile: function () {\n\t      return function linkFn(scope, iElement, iAttrs) {\n\t\n\t        iAttrs.$observe('translateLanguage', function (newTranslateLanguage) {\n\t          scope.translateLanguage = newTranslateLanguage;\n\t        });\n\t\n\t        scope.$watch('translateLanguage', function(){\n\t          scope.$broadcast('translateLanguageChanged');\n\t        });\n\t      };\n\t    }\n\t  };\n\t}\n\t\n\ttranslateLanguageDirective.displayName = 'translateLanguageDirective';\n\t\n\tangular.module('pascalprecht.translate')\n\t/**\n\t * @ngdoc filter\n\t * @name pascalprecht.translate.filter:translate\n\t * @requires $parse\n\t * @requires pascalprecht.translate.$translate\n\t * @function\n\t *\n\t * @description\n\t * Uses `$translate` service to translate contents. Accepts interpolate parameters\n\t * to pass dynamized values though translation.\n\t *\n\t * @param {string} translationId A translation id to be translated.\n\t * @param {*=} interpolateParams Optional object literal (as hash or string) to pass values into translation.\n\t *\n\t * @returns {string} Translated text.\n\t *\n\t * @example\n\t   <example module=\"ngView\">\n\t    <file name=\"index.html\">\n\t      <div ng-controller=\"TranslateCtrl\">\n\t\n\t        <pre>{{ 'TRANSLATION_ID' | translate }}</pre>\n\t        <pre>{{ translationId | translate }}</pre>\n\t        <pre>{{ 'WITH_VALUES' | translate:'{value: 5}' }}</pre>\n\t        <pre>{{ 'WITH_VALUES' | translate:values }}</pre>\n\t\n\t      </div>\n\t    </file>\n\t    <file name=\"script.js\">\n\t      angular.module('ngView', ['pascalprecht.translate'])\n\t\n\t      .config(function ($translateProvider) {\n\t\n\t        $translateProvider.translations('en', {\n\t          'TRANSLATION_ID': 'Hello there!',\n\t          'WITH_VALUES': 'The following value is dynamic: {{value}}'\n\t        });\n\t        $translateProvider.preferredLanguage('en');\n\t\n\t      });\n\t\n\t      angular.module('ngView').controller('TranslateCtrl', function ($scope) {\n\t        $scope.translationId = 'TRANSLATION_ID';\n\t\n\t        $scope.values = {\n\t          value: 78\n\t        };\n\t      });\n\t    </file>\n\t   </example>\n\t */\n\t.filter('translate', translateFilterFactory);\n\t\n\tfunction translateFilterFactory($parse, $translate) {\n\t\n\t  'use strict';\n\t\n\t  var translateFilter = function (translationId, interpolateParams, interpolation, forceLanguage) {\n\t    if (!angular.isObject(interpolateParams)) {\n\t      interpolateParams = $parse(interpolateParams)(this);\n\t    }\n\t\n\t    return $translate.instant(translationId, interpolateParams, interpolation, forceLanguage);\n\t  };\n\t\n\t  if ($translate.statefulFilter()) {\n\t    translateFilter.$stateful = true;\n\t  }\n\t\n\t  return translateFilter;\n\t}\n\t\n\ttranslateFilterFactory.displayName = 'translateFilterFactory';\n\t\n\tangular.module('pascalprecht.translate')\n\t\n\t/**\n\t * @ngdoc object\n\t * @name pascalprecht.translate.$translationCache\n\t * @requires $cacheFactory\n\t *\n\t * @description\n\t * The first time a translation table is used, it is loaded in the translation cache for quick retrieval. You\n\t * can load translation tables directly into the cache by consuming the\n\t * `$translationCache` service directly.\n\t *\n\t * @return {object} $cacheFactory object.\n\t */\n\t  .factory('$translationCache', $translationCache);\n\t\n\tfunction $translationCache($cacheFactory) {\n\t\n\t  'use strict';\n\t\n\t  return $cacheFactory('translations');\n\t}\n\t\n\t$translationCache.displayName = '$translationCache';\n\treturn 'pascalprecht.translate';\n\t\n\t}));\n\n\n/***/ },\n/* 9 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t__webpack_require__(10);\n\tmodule.exports = 'ngCookies';\n\n\n/***/ },\n/* 10 */\n/***/ function(module, exports) {\n\n\t/**\n\t * @license AngularJS v1.5.8\n\t * (c) 2010-2016 Google, Inc. http://angularjs.org\n\t * License: MIT\n\t */\n\t(function(window, angular) {'use strict';\n\t\n\t/**\n\t * @ngdoc module\n\t * @name ngCookies\n\t * @description\n\t *\n\t * # ngCookies\n\t *\n\t * The `ngCookies` module provides a convenient wrapper for reading and writing browser cookies.\n\t *\n\t *\n\t * <div doc-module-components=\"ngCookies\"></div>\n\t *\n\t * See {@link ngCookies.$cookies `$cookies`} for usage.\n\t */\n\t\n\t\n\tangular.module('ngCookies', ['ng']).\n\t  /**\n\t   * @ngdoc provider\n\t   * @name $cookiesProvider\n\t   * @description\n\t   * Use `$cookiesProvider` to change the default behavior of the {@link ngCookies.$cookies $cookies} service.\n\t   * */\n\t   provider('$cookies', [function $CookiesProvider() {\n\t    /**\n\t     * @ngdoc property\n\t     * @name $cookiesProvider#defaults\n\t     * @description\n\t     *\n\t     * Object containing default options to pass when setting cookies.\n\t     *\n\t     * The object may have following properties:\n\t     *\n\t     * - **path** - `{string}` - The cookie will be available only for this path and its\n\t     *   sub-paths. By default, this is the URL that appears in your `<base>` tag.\n\t     * - **domain** - `{string}` - The cookie will be available only for this domain and\n\t     *   its sub-domains. For security reasons the user agent will not accept the cookie\n\t     *   if the current domain is not a sub-domain of this domain or equal to it.\n\t     * - **expires** - `{string|Date}` - String of the form \"Wdy, DD Mon YYYY HH:MM:SS GMT\"\n\t     *   or a Date object indicating the exact date/time this cookie will expire.\n\t     * - **secure** - `{boolean}` - If `true`, then the cookie will only be available through a\n\t     *   secured connection.\n\t     *\n\t     * Note: By default, the address that appears in your `<base>` tag will be used as the path.\n\t     * This is important so that cookies will be visible for all routes when html5mode is enabled.\n\t     *\n\t     **/\n\t    var defaults = this.defaults = {};\n\t\n\t    function calcOptions(options) {\n\t      return options ? angular.extend({}, defaults, options) : defaults;\n\t    }\n\t\n\t    /**\n\t     * @ngdoc service\n\t     * @name $cookies\n\t     *\n\t     * @description\n\t     * Provides read/write access to browser's cookies.\n\t     *\n\t     * <div class=\"alert alert-info\">\n\t     * Up until Angular 1.3, `$cookies` exposed properties that represented the\n\t     * current browser cookie values. In version 1.4, this behavior has changed, and\n\t     * `$cookies` now provides a standard api of getters, setters etc.\n\t     * </div>\n\t     *\n\t     * Requires the {@link ngCookies `ngCookies`} module to be installed.\n\t     *\n\t     * @example\n\t     *\n\t     * ```js\n\t     * angular.module('cookiesExample', ['ngCookies'])\n\t     *   .controller('ExampleController', ['$cookies', function($cookies) {\n\t     *     // Retrieving a cookie\n\t     *     var favoriteCookie = $cookies.get('myFavorite');\n\t     *     // Setting a cookie\n\t     *     $cookies.put('myFavorite', 'oatmeal');\n\t     *   }]);\n\t     * ```\n\t     */\n\t    this.$get = ['$$cookieReader', '$$cookieWriter', function($$cookieReader, $$cookieWriter) {\n\t      return {\n\t        /**\n\t         * @ngdoc method\n\t         * @name $cookies#get\n\t         *\n\t         * @description\n\t         * Returns the value of given cookie key\n\t         *\n\t         * @param {string} key Id to use for lookup.\n\t         * @returns {string} Raw cookie value.\n\t         */\n\t        get: function(key) {\n\t          return $$cookieReader()[key];\n\t        },\n\t\n\t        /**\n\t         * @ngdoc method\n\t         * @name $cookies#getObject\n\t         *\n\t         * @description\n\t         * Returns the deserialized value of given cookie key\n\t         *\n\t         * @param {string} key Id to use for lookup.\n\t         * @returns {Object} Deserialized cookie value.\n\t         */\n\t        getObject: function(key) {\n\t          var value = this.get(key);\n\t          return value ? angular.fromJson(value) : value;\n\t        },\n\t\n\t        /**\n\t         * @ngdoc method\n\t         * @name $cookies#getAll\n\t         *\n\t         * @description\n\t         * Returns a key value object with all the cookies\n\t         *\n\t         * @returns {Object} All cookies\n\t         */\n\t        getAll: function() {\n\t          return $$cookieReader();\n\t        },\n\t\n\t        /**\n\t         * @ngdoc method\n\t         * @name $cookies#put\n\t         *\n\t         * @description\n\t         * Sets a value for given cookie key\n\t         *\n\t         * @param {string} key Id for the `value`.\n\t         * @param {string} value Raw value to be stored.\n\t         * @param {Object=} options Options object.\n\t         *    See {@link ngCookies.$cookiesProvider#defaults $cookiesProvider.defaults}\n\t         */\n\t        put: function(key, value, options) {\n\t          $$cookieWriter(key, value, calcOptions(options));\n\t        },\n\t\n\t        /**\n\t         * @ngdoc method\n\t         * @name $cookies#putObject\n\t         *\n\t         * @description\n\t         * Serializes and sets a value for given cookie key\n\t         *\n\t         * @param {string} key Id for the `value`.\n\t         * @param {Object} value Value to be stored.\n\t         * @param {Object=} options Options object.\n\t         *    See {@link ngCookies.$cookiesProvider#defaults $cookiesProvider.defaults}\n\t         */\n\t        putObject: function(key, value, options) {\n\t          this.put(key, angular.toJson(value), options);\n\t        },\n\t\n\t        /**\n\t         * @ngdoc method\n\t         * @name $cookies#remove\n\t         *\n\t         * @description\n\t         * Remove given cookie\n\t         *\n\t         * @param {string} key Id of the key-value pair to delete.\n\t         * @param {Object=} options Options object.\n\t         *    See {@link ngCookies.$cookiesProvider#defaults $cookiesProvider.defaults}\n\t         */\n\t        remove: function(key, options) {\n\t          $$cookieWriter(key, undefined, calcOptions(options));\n\t        }\n\t      };\n\t    }];\n\t  }]);\n\t\n\tangular.module('ngCookies').\n\t/**\n\t * @ngdoc service\n\t * @name $cookieStore\n\t * @deprecated\n\t * @requires $cookies\n\t *\n\t * @description\n\t * Provides a key-value (string-object) storage, that is backed by session cookies.\n\t * Objects put or retrieved from this storage are automatically serialized or\n\t * deserialized by angular's toJson/fromJson.\n\t *\n\t * Requires the {@link ngCookies `ngCookies`} module to be installed.\n\t *\n\t * <div class=\"alert alert-danger\">\n\t * **Note:** The $cookieStore service is **deprecated**.\n\t * Please use the {@link ngCookies.$cookies `$cookies`} service instead.\n\t * </div>\n\t *\n\t * @example\n\t *\n\t * ```js\n\t * angular.module('cookieStoreExample', ['ngCookies'])\n\t *   .controller('ExampleController', ['$cookieStore', function($cookieStore) {\n\t *     // Put cookie\n\t *     $cookieStore.put('myFavorite','oatmeal');\n\t *     // Get cookie\n\t *     var favoriteCookie = $cookieStore.get('myFavorite');\n\t *     // Removing a cookie\n\t *     $cookieStore.remove('myFavorite');\n\t *   }]);\n\t * ```\n\t */\n\t factory('$cookieStore', ['$cookies', function($cookies) {\n\t\n\t    return {\n\t      /**\n\t       * @ngdoc method\n\t       * @name $cookieStore#get\n\t       *\n\t       * @description\n\t       * Returns the value of given cookie key\n\t       *\n\t       * @param {string} key Id to use for lookup.\n\t       * @returns {Object} Deserialized cookie value, undefined if the cookie does not exist.\n\t       */\n\t      get: function(key) {\n\t        return $cookies.getObject(key);\n\t      },\n\t\n\t      /**\n\t       * @ngdoc method\n\t       * @name $cookieStore#put\n\t       *\n\t       * @description\n\t       * Sets a value for given cookie key\n\t       *\n\t       * @param {string} key Id for the `value`.\n\t       * @param {Object} value Value to be stored.\n\t       */\n\t      put: function(key, value) {\n\t        $cookies.putObject(key, value);\n\t      },\n\t\n\t      /**\n\t       * @ngdoc method\n\t       * @name $cookieStore#remove\n\t       *\n\t       * @description\n\t       * Remove given cookie\n\t       *\n\t       * @param {string} key Id of the key-value pair to delete.\n\t       */\n\t      remove: function(key) {\n\t        $cookies.remove(key);\n\t      }\n\t    };\n\t\n\t  }]);\n\t\n\t/**\n\t * @name $$cookieWriter\n\t * @requires $document\n\t *\n\t * @description\n\t * This is a private service for writing cookies\n\t *\n\t * @param {string} name Cookie name\n\t * @param {string=} value Cookie value (if undefined, cookie will be deleted)\n\t * @param {Object=} options Object with options that need to be stored for the cookie.\n\t */\n\tfunction $$CookieWriter($document, $log, $browser) {\n\t  var cookiePath = $browser.baseHref();\n\t  var rawDocument = $document[0];\n\t\n\t  function buildCookieString(name, value, options) {\n\t    var path, expires;\n\t    options = options || {};\n\t    expires = options.expires;\n\t    path = angular.isDefined(options.path) ? options.path : cookiePath;\n\t    if (angular.isUndefined(value)) {\n\t      expires = 'Thu, 01 Jan 1970 00:00:00 GMT';\n\t      value = '';\n\t    }\n\t    if (angular.isString(expires)) {\n\t      expires = new Date(expires);\n\t    }\n\t\n\t    var str = encodeURIComponent(name) + '=' + encodeURIComponent(value);\n\t    str += path ? ';path=' + path : '';\n\t    str += options.domain ? ';domain=' + options.domain : '';\n\t    str += expires ? ';expires=' + expires.toUTCString() : '';\n\t    str += options.secure ? ';secure' : '';\n\t\n\t    // per http://www.ietf.org/rfc/rfc2109.txt browser must allow at minimum:\n\t    // - 300 cookies\n\t    // - 20 cookies per unique domain\n\t    // - 4096 bytes per cookie\n\t    var cookieLength = str.length + 1;\n\t    if (cookieLength > 4096) {\n\t      $log.warn(\"Cookie '\" + name +\n\t        \"' possibly not set or overflowed because it was too large (\" +\n\t        cookieLength + \" > 4096 bytes)!\");\n\t    }\n\t\n\t    return str;\n\t  }\n\t\n\t  return function(name, value, options) {\n\t    rawDocument.cookie = buildCookieString(name, value, options);\n\t  };\n\t}\n\t\n\t$$CookieWriter.$inject = ['$document', '$log', '$browser'];\n\t\n\tangular.module('ngCookies').provider('$$cookieWriter', function $$CookieWriterProvider() {\n\t  this.$get = $$CookieWriter;\n\t});\n\t\n\t\n\t})(window, window.angular);\n\n\n/***/ },\n/* 11 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t__webpack_require__(12);\n\tmodule.exports = 'ngResource';\n\n\n/***/ },\n/* 12 */\n/***/ function(module, exports) {\n\n\t/**\n\t * @license AngularJS v1.5.8\n\t * (c) 2010-2016 Google, Inc. http://angularjs.org\n\t * License: MIT\n\t */\n\t(function(window, angular) {'use strict';\n\t\n\tvar $resourceMinErr = angular.$$minErr('$resource');\n\t\n\t// Helper functions and regex to lookup a dotted path on an object\n\t// stopping at undefined/null.  The path must be composed of ASCII\n\t// identifiers (just like $parse)\n\tvar MEMBER_NAME_REGEX = /^(\\.[a-zA-Z_$@][0-9a-zA-Z_$@]*)+$/;\n\t\n\tfunction isValidDottedPath(path) {\n\t  return (path != null && path !== '' && path !== 'hasOwnProperty' &&\n\t      MEMBER_NAME_REGEX.test('.' + path));\n\t}\n\t\n\tfunction lookupDottedPath(obj, path) {\n\t  if (!isValidDottedPath(path)) {\n\t    throw $resourceMinErr('badmember', 'Dotted member path \"@{0}\" is invalid.', path);\n\t  }\n\t  var keys = path.split('.');\n\t  for (var i = 0, ii = keys.length; i < ii && angular.isDefined(obj); i++) {\n\t    var key = keys[i];\n\t    obj = (obj !== null) ? obj[key] : undefined;\n\t  }\n\t  return obj;\n\t}\n\t\n\t/**\n\t * Create a shallow copy of an object and clear other fields from the destination\n\t */\n\tfunction shallowClearAndCopy(src, dst) {\n\t  dst = dst || {};\n\t\n\t  angular.forEach(dst, function(value, key) {\n\t    delete dst[key];\n\t  });\n\t\n\t  for (var key in src) {\n\t    if (src.hasOwnProperty(key) && !(key.charAt(0) === '$' && key.charAt(1) === '$')) {\n\t      dst[key] = src[key];\n\t    }\n\t  }\n\t\n\t  return dst;\n\t}\n\t\n\t/**\n\t * @ngdoc module\n\t * @name ngResource\n\t * @description\n\t *\n\t * # ngResource\n\t *\n\t * The `ngResource` module provides interaction support with RESTful services\n\t * via the $resource service.\n\t *\n\t *\n\t * <div doc-module-components=\"ngResource\"></div>\n\t *\n\t * See {@link ngResource.$resourceProvider} and {@link ngResource.$resource} for usage.\n\t */\n\t\n\t/**\n\t * @ngdoc provider\n\t * @name $resourceProvider\n\t *\n\t * @description\n\t *\n\t * Use `$resourceProvider` to change the default behavior of the {@link ngResource.$resource}\n\t * service.\n\t *\n\t * ## Dependencies\n\t * Requires the {@link ngResource } module to be installed.\n\t *\n\t */\n\t\n\t/**\n\t * @ngdoc service\n\t * @name $resource\n\t * @requires $http\n\t * @requires ng.$log\n\t * @requires $q\n\t * @requires ng.$timeout\n\t *\n\t * @description\n\t * A factory which creates a resource object that lets you interact with\n\t * [RESTful](http://en.wikipedia.org/wiki/Representational_State_Transfer) server-side data sources.\n\t *\n\t * The returned resource object has action methods which provide high-level behaviors without\n\t * the need to interact with the low level {@link ng.$http $http} service.\n\t *\n\t * Requires the {@link ngResource `ngResource`} module to be installed.\n\t *\n\t * By default, trailing slashes will be stripped from the calculated URLs,\n\t * which can pose problems with server backends that do not expect that\n\t * behavior.  This can be disabled by configuring the `$resourceProvider` like\n\t * this:\n\t *\n\t * ```js\n\t     app.config(['$resourceProvider', function($resourceProvider) {\n\t       // Don't strip trailing slashes from calculated URLs\n\t       $resourceProvider.defaults.stripTrailingSlashes = false;\n\t     }]);\n\t * ```\n\t *\n\t * @param {string} url A parameterized URL template with parameters prefixed by `:` as in\n\t *   `/user/:username`. If you are using a URL with a port number (e.g.\n\t *   `http://example.com:8080/api`), it will be respected.\n\t *\n\t *   If you are using a url with a suffix, just add the suffix, like this:\n\t *   `$resource('http://example.com/resource.json')` or `$resource('http://example.com/:id.json')`\n\t *   or even `$resource('http://example.com/resource/:resource_id.:format')`\n\t *   If the parameter before the suffix is empty, :resource_id in this case, then the `/.` will be\n\t *   collapsed down to a single `.`.  If you need this sequence to appear and not collapse then you\n\t *   can escape it with `/\\.`.\n\t *\n\t * @param {Object=} paramDefaults Default values for `url` parameters. These can be overridden in\n\t *   `actions` methods. If a parameter value is a function, it will be called every time\n\t *   a param value needs to be obtained for a request (unless the param was overridden). The function\n\t *   will be passed the current data value as an argument.\n\t *\n\t *   Each key value in the parameter object is first bound to url template if present and then any\n\t *   excess keys are appended to the url search query after the `?`.\n\t *\n\t *   Given a template `/path/:verb` and parameter `{verb:'greet', salutation:'Hello'}` results in\n\t *   URL `/path/greet?salutation=Hello`.\n\t *\n\t *   If the parameter value is prefixed with `@`, then the value for that parameter will be\n\t *   extracted from the corresponding property on the `data` object (provided when calling a\n\t *   \"non-GET\" action method).\n\t *   For example, if the `defaultParam` object is `{someParam: '@someProp'}` then the value of\n\t *   `someParam` will be `data.someProp`.\n\t *   Note that the parameter will be ignored, when calling a \"GET\" action method (i.e. an action\n\t *   method that does not accept a request body)\n\t *\n\t * @param {Object.<Object>=} actions Hash with declaration of custom actions that should extend\n\t *   the default set of resource actions. The declaration should be created in the format of {@link\n\t *   ng.$http#usage $http.config}:\n\t *\n\t *       {action1: {method:?, params:?, isArray:?, headers:?, ...},\n\t *        action2: {method:?, params:?, isArray:?, headers:?, ...},\n\t *        ...}\n\t *\n\t *   Where:\n\t *\n\t *   - **`action`** – {string} – The name of action. This name becomes the name of the method on\n\t *     your resource object.\n\t *   - **`method`** – {string} – Case insensitive HTTP method (e.g. `GET`, `POST`, `PUT`,\n\t *     `DELETE`, `JSONP`, etc).\n\t *   - **`params`** – {Object=} – Optional set of pre-bound parameters for this action. If any of\n\t *     the parameter value is a function, it will be called every time when a param value needs to\n\t *     be obtained for a request (unless the param was overridden). The function will be passed the\n\t *     current data value as an argument.\n\t *   - **`url`** – {string} – action specific `url` override. The url templating is supported just\n\t *     like for the resource-level urls.\n\t *   - **`isArray`** – {boolean=} – If true then the returned object for this action is an array,\n\t *     see `returns` section.\n\t *   - **`transformRequest`** –\n\t *     `{function(data, headersGetter)|Array.<function(data, headersGetter)>}` –\n\t *     transform function or an array of such functions. The transform function takes the http\n\t *     request body and headers and returns its transformed (typically serialized) version.\n\t *     By default, transformRequest will contain one function that checks if the request data is\n\t *     an object and serializes to using `angular.toJson`. To prevent this behavior, set\n\t *     `transformRequest` to an empty array: `transformRequest: []`\n\t *   - **`transformResponse`** –\n\t *     `{function(data, headersGetter)|Array.<function(data, headersGetter)>}` –\n\t *     transform function or an array of such functions. The transform function takes the http\n\t *     response body and headers and returns its transformed (typically deserialized) version.\n\t *     By default, transformResponse will contain one function that checks if the response looks\n\t *     like a JSON string and deserializes it using `angular.fromJson`. To prevent this behavior,\n\t *     set `transformResponse` to an empty array: `transformResponse: []`\n\t *   - **`cache`** – `{boolean|Cache}` – If true, a default $http cache will be used to cache the\n\t *     GET request, otherwise if a cache instance built with\n\t *     {@link ng.$cacheFactory $cacheFactory}, this cache will be used for\n\t *     caching.\n\t *   - **`timeout`** – `{number}` – timeout in milliseconds.<br />\n\t *     **Note:** In contrast to {@link ng.$http#usage $http.config}, {@link ng.$q promises} are\n\t *     **not** supported in $resource, because the same value would be used for multiple requests.\n\t *     If you are looking for a way to cancel requests, you should use the `cancellable` option.\n\t *   - **`cancellable`** – `{boolean}` – if set to true, the request made by a \"non-instance\" call\n\t *     will be cancelled (if not already completed) by calling `$cancelRequest()` on the call's\n\t *     return value. Calling `$cancelRequest()` for a non-cancellable or an already\n\t *     completed/cancelled request will have no effect.<br />\n\t *   - **`withCredentials`** - `{boolean}` - whether to set the `withCredentials` flag on the\n\t *     XHR object. See\n\t *     [requests with credentials](https://developer.mozilla.org/en/http_access_control#section_5)\n\t *     for more information.\n\t *   - **`responseType`** - `{string}` - see\n\t *     [requestType](https://developer.mozilla.org/en-US/docs/DOM/XMLHttpRequest#responseType).\n\t *   - **`interceptor`** - `{Object=}` - The interceptor object has two optional methods -\n\t *     `response` and `responseError`. Both `response` and `responseError` interceptors get called\n\t *     with `http response` object. See {@link ng.$http $http interceptors}.\n\t *\n\t * @param {Object} options Hash with custom settings that should extend the\n\t *   default `$resourceProvider` behavior.  The supported options are:\n\t *\n\t *   - **`stripTrailingSlashes`** – {boolean} – If true then the trailing\n\t *   slashes from any calculated URL will be stripped. (Defaults to true.)\n\t *   - **`cancellable`** – {boolean} – If true, the request made by a \"non-instance\" call will be\n\t *   cancelled (if not already completed) by calling `$cancelRequest()` on the call's return value.\n\t *   This can be overwritten per action. (Defaults to false.)\n\t *\n\t * @returns {Object} A resource \"class\" object with methods for the default set of resource actions\n\t *   optionally extended with custom `actions`. The default set contains these actions:\n\t *   ```js\n\t *   { 'get':    {method:'GET'},\n\t *     'save':   {method:'POST'},\n\t *     'query':  {method:'GET', isArray:true},\n\t *     'remove': {method:'DELETE'},\n\t *     'delete': {method:'DELETE'} };\n\t *   ```\n\t *\n\t *   Calling these methods invoke an {@link ng.$http} with the specified http method,\n\t *   destination and parameters. When the data is returned from the server then the object is an\n\t *   instance of the resource class. The actions `save`, `remove` and `delete` are available on it\n\t *   as  methods with the `$` prefix. This allows you to easily perform CRUD operations (create,\n\t *   read, update, delete) on server-side data like this:\n\t *   ```js\n\t *   var User = $resource('/user/:userId', {userId:'@id'});\n\t *   var user = User.get({userId:123}, function() {\n\t *     user.abc = true;\n\t *     user.$save();\n\t *   });\n\t *   ```\n\t *\n\t *   It is important to realize that invoking a $resource object method immediately returns an\n\t *   empty reference (object or array depending on `isArray`). Once the data is returned from the\n\t *   server the existing reference is populated with the actual data. This is a useful trick since\n\t *   usually the resource is assigned to a model which is then rendered by the view. Having an empty\n\t *   object results in no rendering, once the data arrives from the server then the object is\n\t *   populated with the data and the view automatically re-renders itself showing the new data. This\n\t *   means that in most cases one never has to write a callback function for the action methods.\n\t *\n\t *   The action methods on the class object or instance object can be invoked with the following\n\t *   parameters:\n\t *\n\t *   - HTTP GET \"class\" actions: `Resource.action([parameters], [success], [error])`\n\t *   - non-GET \"class\" actions: `Resource.action([parameters], postData, [success], [error])`\n\t *   - non-GET instance actions:  `instance.$action([parameters], [success], [error])`\n\t *\n\t *\n\t *   Success callback is called with (value, responseHeaders) arguments, where the value is\n\t *   the populated resource instance or collection object. The error callback is called\n\t *   with (httpResponse) argument.\n\t *\n\t *   Class actions return empty instance (with additional properties below).\n\t *   Instance actions return promise of the action.\n\t *\n\t *   The Resource instances and collections have these additional properties:\n\t *\n\t *   - `$promise`: the {@link ng.$q promise} of the original server interaction that created this\n\t *     instance or collection.\n\t *\n\t *     On success, the promise is resolved with the same resource instance or collection object,\n\t *     updated with data from server. This makes it easy to use in\n\t *     {@link ngRoute.$routeProvider resolve section of $routeProvider.when()} to defer view\n\t *     rendering until the resource(s) are loaded.\n\t *\n\t *     On failure, the promise is rejected with the {@link ng.$http http response} object, without\n\t *     the `resource` property.\n\t *\n\t *     If an interceptor object was provided, the promise will instead be resolved with the value\n\t *     returned by the interceptor.\n\t *\n\t *   - `$resolved`: `true` after first server interaction is completed (either with success or\n\t *      rejection), `false` before that. Knowing if the Resource has been resolved is useful in\n\t *      data-binding.\n\t *\n\t *   The Resource instances and collections have these additional methods:\n\t *\n\t *   - `$cancelRequest`: If there is a cancellable, pending request related to the instance or\n\t *      collection, calling this method will abort the request.\n\t *\n\t *   The Resource instances have these additional methods:\n\t *\n\t *   - `toJSON`: It returns a simple object without any of the extra properties added as part of\n\t *     the Resource API. This object can be serialized through {@link angular.toJson} safely\n\t *     without attaching Angular-specific fields. Notice that `JSON.stringify` (and\n\t *     `angular.toJson`) automatically use this method when serializing a Resource instance\n\t *     (see [MDN](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/JSON/stringify#toJSON()_behavior)).\n\t *\n\t * @example\n\t *\n\t * # Credit card resource\n\t *\n\t * ```js\n\t     // Define CreditCard class\n\t     var CreditCard = $resource('/user/:userId/card/:cardId',\n\t      {userId:123, cardId:'@id'}, {\n\t       charge: {method:'POST', params:{charge:true}}\n\t      });\n\t\n\t     // We can retrieve a collection from the server\n\t     var cards = CreditCard.query(function() {\n\t       // GET: /user/123/card\n\t       // server returns: [ {id:456, number:'1234', name:'Smith'} ];\n\t\n\t       var card = cards[0];\n\t       // each item is an instance of CreditCard\n\t       expect(card instanceof CreditCard).toEqual(true);\n\t       card.name = \"J. Smith\";\n\t       // non GET methods are mapped onto the instances\n\t       card.$save();\n\t       // POST: /user/123/card/456 {id:456, number:'1234', name:'J. Smith'}\n\t       // server returns: {id:456, number:'1234', name: 'J. Smith'};\n\t\n\t       // our custom method is mapped as well.\n\t       card.$charge({amount:9.99});\n\t       // POST: /user/123/card/456?amount=9.99&charge=true {id:456, number:'1234', name:'J. Smith'}\n\t     });\n\t\n\t     // we can create an instance as well\n\t     var newCard = new CreditCard({number:'0123'});\n\t     newCard.name = \"Mike Smith\";\n\t     newCard.$save();\n\t     // POST: /user/123/card {number:'0123', name:'Mike Smith'}\n\t     // server returns: {id:789, number:'0123', name: 'Mike Smith'};\n\t     expect(newCard.id).toEqual(789);\n\t * ```\n\t *\n\t * The object returned from this function execution is a resource \"class\" which has \"static\" method\n\t * for each action in the definition.\n\t *\n\t * Calling these methods invoke `$http` on the `url` template with the given `method`, `params` and\n\t * `headers`.\n\t *\n\t * @example\n\t *\n\t * # User resource\n\t *\n\t * When the data is returned from the server then the object is an instance of the resource type and\n\t * all of the non-GET methods are available with `$` prefix. This allows you to easily support CRUD\n\t * operations (create, read, update, delete) on server-side data.\n\t\n\t   ```js\n\t     var User = $resource('/user/:userId', {userId:'@id'});\n\t     User.get({userId:123}, function(user) {\n\t       user.abc = true;\n\t       user.$save();\n\t     });\n\t   ```\n\t *\n\t * It's worth noting that the success callback for `get`, `query` and other methods gets passed\n\t * in the response that came from the server as well as $http header getter function, so one\n\t * could rewrite the above example and get access to http headers as:\n\t *\n\t   ```js\n\t     var User = $resource('/user/:userId', {userId:'@id'});\n\t     User.get({userId:123}, function(user, getResponseHeaders){\n\t       user.abc = true;\n\t       user.$save(function(user, putResponseHeaders) {\n\t         //user => saved user object\n\t         //putResponseHeaders => $http header getter\n\t       });\n\t     });\n\t   ```\n\t *\n\t * You can also access the raw `$http` promise via the `$promise` property on the object returned\n\t *\n\t   ```\n\t     var User = $resource('/user/:userId', {userId:'@id'});\n\t     User.get({userId:123})\n\t         .$promise.then(function(user) {\n\t           $scope.user = user;\n\t         });\n\t   ```\n\t *\n\t * @example\n\t *\n\t * # Creating a custom 'PUT' request\n\t *\n\t * In this example we create a custom method on our resource to make a PUT request\n\t * ```js\n\t *    var app = angular.module('app', ['ngResource', 'ngRoute']);\n\t *\n\t *    // Some APIs expect a PUT request in the format URL/object/ID\n\t *    // Here we are creating an 'update' method\n\t *    app.factory('Notes', ['$resource', function($resource) {\n\t *    return $resource('/notes/:id', null,\n\t *        {\n\t *            'update': { method:'PUT' }\n\t *        });\n\t *    }]);\n\t *\n\t *    // In our controller we get the ID from the URL using ngRoute and $routeParams\n\t *    // We pass in $routeParams and our Notes factory along with $scope\n\t *    app.controller('NotesCtrl', ['$scope', '$routeParams', 'Notes',\n\t                                      function($scope, $routeParams, Notes) {\n\t *    // First get a note object from the factory\n\t *    var note = Notes.get({ id:$routeParams.id });\n\t *    $id = note.id;\n\t *\n\t *    // Now call update passing in the ID first then the object you are updating\n\t *    Notes.update({ id:$id }, note);\n\t *\n\t *    // This will PUT /notes/ID with the note object in the request payload\n\t *    }]);\n\t * ```\n\t *\n\t * @example\n\t *\n\t * # Cancelling requests\n\t *\n\t * If an action's configuration specifies that it is cancellable, you can cancel the request related\n\t * to an instance or collection (as long as it is a result of a \"non-instance\" call):\n\t *\n\t   ```js\n\t     // ...defining the `Hotel` resource...\n\t     var Hotel = $resource('/api/hotel/:id', {id: '@id'}, {\n\t       // Let's make the `query()` method cancellable\n\t       query: {method: 'get', isArray: true, cancellable: true}\n\t     });\n\t\n\t     // ...somewhere in the PlanVacationController...\n\t     ...\n\t     this.onDestinationChanged = function onDestinationChanged(destination) {\n\t       // We don't care about any pending request for hotels\n\t       // in a different destination any more\n\t       this.availableHotels.$cancelRequest();\n\t\n\t       // Let's query for hotels in '<destination>'\n\t       // (calls: /api/hotel?location=<destination>)\n\t       this.availableHotels = Hotel.query({location: destination});\n\t     };\n\t   ```\n\t *\n\t */\n\tangular.module('ngResource', ['ng']).\n\t  provider('$resource', function() {\n\t    var PROTOCOL_AND_DOMAIN_REGEX = /^https?:\\/\\/[^\\/]*/;\n\t    var provider = this;\n\t\n\t    /**\n\t     * @ngdoc property\n\t     * @name $resourceProvider#defaults\n\t     * @description\n\t     * Object containing default options used when creating `$resource` instances.\n\t     *\n\t     * The default values satisfy a wide range of usecases, but you may choose to overwrite any of\n\t     * them to further customize your instances. The available properties are:\n\t     *\n\t     * - **stripTrailingSlashes** – `{boolean}` – If true, then the trailing slashes from any\n\t     *   calculated URL will be stripped.<br />\n\t     *   (Defaults to true.)\n\t     * - **cancellable** – `{boolean}` – If true, the request made by a \"non-instance\" call will be\n\t     *   cancelled (if not already completed) by calling `$cancelRequest()` on the call's return\n\t     *   value. For more details, see {@link ngResource.$resource}. This can be overwritten per\n\t     *   resource class or action.<br />\n\t     *   (Defaults to false.)\n\t     * - **actions** - `{Object.<Object>}` - A hash with default actions declarations. Actions are\n\t     *   high-level methods corresponding to RESTful actions/methods on resources. An action may\n\t     *   specify what HTTP method to use, what URL to hit, if the return value will be a single\n\t     *   object or a collection (array) of objects etc. For more details, see\n\t     *   {@link ngResource.$resource}. The actions can also be enhanced or overwritten per resource\n\t     *   class.<br />\n\t     *   The default actions are:\n\t     *   ```js\n\t     *   {\n\t     *     get: {method: 'GET'},\n\t     *     save: {method: 'POST'},\n\t     *     query: {method: 'GET', isArray: true},\n\t     *     remove: {method: 'DELETE'},\n\t     *     delete: {method: 'DELETE'}\n\t     *   }\n\t     *   ```\n\t     *\n\t     * #### Example\n\t     *\n\t     * For example, you can specify a new `update` action that uses the `PUT` HTTP verb:\n\t     *\n\t     * ```js\n\t     *   angular.\n\t     *     module('myApp').\n\t     *     config(['resourceProvider', function ($resourceProvider) {\n\t     *       $resourceProvider.defaults.actions.update = {\n\t     *         method: 'PUT'\n\t     *       };\n\t     *     });\n\t     * ```\n\t     *\n\t     * Or you can even overwrite the whole `actions` list and specify your own:\n\t     *\n\t     * ```js\n\t     *   angular.\n\t     *     module('myApp').\n\t     *     config(['resourceProvider', function ($resourceProvider) {\n\t     *       $resourceProvider.defaults.actions = {\n\t     *         create: {method: 'POST'}\n\t     *         get:    {method: 'GET'},\n\t     *         getAll: {method: 'GET', isArray:true},\n\t     *         update: {method: 'PUT'},\n\t     *         delete: {method: 'DELETE'}\n\t     *       };\n\t     *     });\n\t     * ```\n\t     *\n\t     */\n\t    this.defaults = {\n\t      // Strip slashes by default\n\t      stripTrailingSlashes: true,\n\t\n\t      // Make non-instance requests cancellable (via `$cancelRequest()`)\n\t      cancellable: false,\n\t\n\t      // Default actions configuration\n\t      actions: {\n\t        'get': {method: 'GET'},\n\t        'save': {method: 'POST'},\n\t        'query': {method: 'GET', isArray: true},\n\t        'remove': {method: 'DELETE'},\n\t        'delete': {method: 'DELETE'}\n\t      }\n\t    };\n\t\n\t    this.$get = ['$http', '$log', '$q', '$timeout', function($http, $log, $q, $timeout) {\n\t\n\t      var noop = angular.noop,\n\t        forEach = angular.forEach,\n\t        extend = angular.extend,\n\t        copy = angular.copy,\n\t        isFunction = angular.isFunction;\n\t\n\t      /**\n\t       * We need our custom method because encodeURIComponent is too aggressive and doesn't follow\n\t       * http://www.ietf.org/rfc/rfc3986.txt with regards to the character set\n\t       * (pchar) allowed in path segments:\n\t       *    segment       = *pchar\n\t       *    pchar         = unreserved / pct-encoded / sub-delims / \":\" / \"@\"\n\t       *    pct-encoded   = \"%\" HEXDIG HEXDIG\n\t       *    unreserved    = ALPHA / DIGIT / \"-\" / \".\" / \"_\" / \"~\"\n\t       *    sub-delims    = \"!\" / \"$\" / \"&\" / \"'\" / \"(\" / \")\"\n\t       *                     / \"*\" / \"+\" / \",\" / \";\" / \"=\"\n\t       */\n\t      function encodeUriSegment(val) {\n\t        return encodeUriQuery(val, true).\n\t          replace(/%26/gi, '&').\n\t          replace(/%3D/gi, '=').\n\t          replace(/%2B/gi, '+');\n\t      }\n\t\n\t\n\t      /**\n\t       * This method is intended for encoding *key* or *value* parts of query component. We need a\n\t       * custom method because encodeURIComponent is too aggressive and encodes stuff that doesn't\n\t       * have to be encoded per http://tools.ietf.org/html/rfc3986:\n\t       *    query       = *( pchar / \"/\" / \"?\" )\n\t       *    pchar         = unreserved / pct-encoded / sub-delims / \":\" / \"@\"\n\t       *    unreserved    = ALPHA / DIGIT / \"-\" / \".\" / \"_\" / \"~\"\n\t       *    pct-encoded   = \"%\" HEXDIG HEXDIG\n\t       *    sub-delims    = \"!\" / \"$\" / \"&\" / \"'\" / \"(\" / \")\"\n\t       *                     / \"*\" / \"+\" / \",\" / \";\" / \"=\"\n\t       */\n\t      function encodeUriQuery(val, pctEncodeSpaces) {\n\t        return encodeURIComponent(val).\n\t          replace(/%40/gi, '@').\n\t          replace(/%3A/gi, ':').\n\t          replace(/%24/g, '$').\n\t          replace(/%2C/gi, ',').\n\t          replace(/%20/g, (pctEncodeSpaces ? '%20' : '+'));\n\t      }\n\t\n\t      function Route(template, defaults) {\n\t        this.template = template;\n\t        this.defaults = extend({}, provider.defaults, defaults);\n\t        this.urlParams = {};\n\t      }\n\t\n\t      Route.prototype = {\n\t        setUrlParams: function(config, params, actionUrl) {\n\t          var self = this,\n\t            url = actionUrl || self.template,\n\t            val,\n\t            encodedVal,\n\t            protocolAndDomain = '';\n\t\n\t          var urlParams = self.urlParams = {};\n\t          forEach(url.split(/\\W/), function(param) {\n\t            if (param === 'hasOwnProperty') {\n\t              throw $resourceMinErr('badname', \"hasOwnProperty is not a valid parameter name.\");\n\t            }\n\t            if (!(new RegExp(\"^\\\\d+$\").test(param)) && param &&\n\t              (new RegExp(\"(^|[^\\\\\\\\]):\" + param + \"(\\\\W|$)\").test(url))) {\n\t              urlParams[param] = {\n\t                isQueryParamValue: (new RegExp(\"\\\\?.*=:\" + param + \"(?:\\\\W|$)\")).test(url)\n\t              };\n\t            }\n\t          });\n\t          url = url.replace(/\\\\:/g, ':');\n\t          url = url.replace(PROTOCOL_AND_DOMAIN_REGEX, function(match) {\n\t            protocolAndDomain = match;\n\t            return '';\n\t          });\n\t\n\t          params = params || {};\n\t          forEach(self.urlParams, function(paramInfo, urlParam) {\n\t            val = params.hasOwnProperty(urlParam) ? params[urlParam] : self.defaults[urlParam];\n\t            if (angular.isDefined(val) && val !== null) {\n\t              if (paramInfo.isQueryParamValue) {\n\t                encodedVal = encodeUriQuery(val, true);\n\t              } else {\n\t                encodedVal = encodeUriSegment(val);\n\t              }\n\t              url = url.replace(new RegExp(\":\" + urlParam + \"(\\\\W|$)\", \"g\"), function(match, p1) {\n\t                return encodedVal + p1;\n\t              });\n\t            } else {\n\t              url = url.replace(new RegExp(\"(\\/?):\" + urlParam + \"(\\\\W|$)\", \"g\"), function(match,\n\t                  leadingSlashes, tail) {\n\t                if (tail.charAt(0) == '/') {\n\t                  return tail;\n\t                } else {\n\t                  return leadingSlashes + tail;\n\t                }\n\t              });\n\t            }\n\t          });\n\t\n\t          // strip trailing slashes and set the url (unless this behavior is specifically disabled)\n\t          if (self.defaults.stripTrailingSlashes) {\n\t            url = url.replace(/\\/+$/, '') || '/';\n\t          }\n\t\n\t          // then replace collapse `/.` if found in the last URL path segment before the query\n\t          // E.g. `http://url.com/id./format?q=x` becomes `http://url.com/id.format?q=x`\n\t          url = url.replace(/\\/\\.(?=\\w+($|\\?))/, '.');\n\t          // replace escaped `/\\.` with `/.`\n\t          config.url = protocolAndDomain + url.replace(/\\/\\\\\\./, '/.');\n\t\n\t\n\t          // set params - delegate param encoding to $http\n\t          forEach(params, function(value, key) {\n\t            if (!self.urlParams[key]) {\n\t              config.params = config.params || {};\n\t              config.params[key] = value;\n\t            }\n\t          });\n\t        }\n\t      };\n\t\n\t\n\t      function resourceFactory(url, paramDefaults, actions, options) {\n\t        var route = new Route(url, options);\n\t\n\t        actions = extend({}, provider.defaults.actions, actions);\n\t\n\t        function extractParams(data, actionParams) {\n\t          var ids = {};\n\t          actionParams = extend({}, paramDefaults, actionParams);\n\t          forEach(actionParams, function(value, key) {\n\t            if (isFunction(value)) { value = value(data); }\n\t            ids[key] = value && value.charAt && value.charAt(0) == '@' ?\n\t              lookupDottedPath(data, value.substr(1)) : value;\n\t          });\n\t          return ids;\n\t        }\n\t\n\t        function defaultResponseInterceptor(response) {\n\t          return response.resource;\n\t        }\n\t\n\t        function Resource(value) {\n\t          shallowClearAndCopy(value || {}, this);\n\t        }\n\t\n\t        Resource.prototype.toJSON = function() {\n\t          var data = extend({}, this);\n\t          delete data.$promise;\n\t          delete data.$resolved;\n\t          return data;\n\t        };\n\t\n\t        forEach(actions, function(action, name) {\n\t          var hasBody = /^(POST|PUT|PATCH)$/i.test(action.method);\n\t          var numericTimeout = action.timeout;\n\t          var cancellable = angular.isDefined(action.cancellable) ? action.cancellable :\n\t              (options && angular.isDefined(options.cancellable)) ? options.cancellable :\n\t              provider.defaults.cancellable;\n\t\n\t          if (numericTimeout && !angular.isNumber(numericTimeout)) {\n\t            $log.debug('ngResource:\\n' +\n\t                       '  Only numeric values are allowed as `timeout`.\\n' +\n\t                       '  Promises are not supported in $resource, because the same value would ' +\n\t                       'be used for multiple requests. If you are looking for a way to cancel ' +\n\t                       'requests, you should use the `cancellable` option.');\n\t            delete action.timeout;\n\t            numericTimeout = null;\n\t          }\n\t\n\t          Resource[name] = function(a1, a2, a3, a4) {\n\t            var params = {}, data, success, error;\n\t\n\t            /* jshint -W086 */ /* (purposefully fall through case statements) */\n\t            switch (arguments.length) {\n\t              case 4:\n\t                error = a4;\n\t                success = a3;\n\t              //fallthrough\n\t              case 3:\n\t              case 2:\n\t                if (isFunction(a2)) {\n\t                  if (isFunction(a1)) {\n\t                    success = a1;\n\t                    error = a2;\n\t                    break;\n\t                  }\n\t\n\t                  success = a2;\n\t                  error = a3;\n\t                  //fallthrough\n\t                } else {\n\t                  params = a1;\n\t                  data = a2;\n\t                  success = a3;\n\t                  break;\n\t                }\n\t              case 1:\n\t                if (isFunction(a1)) success = a1;\n\t                else if (hasBody) data = a1;\n\t                else params = a1;\n\t                break;\n\t              case 0: break;\n\t              default:\n\t                throw $resourceMinErr('badargs',\n\t                  \"Expected up to 4 arguments [params, data, success, error], got {0} arguments\",\n\t                  arguments.length);\n\t            }\n\t            /* jshint +W086 */ /* (purposefully fall through case statements) */\n\t\n\t            var isInstanceCall = this instanceof Resource;\n\t            var value = isInstanceCall ? data : (action.isArray ? [] : new Resource(data));\n\t            var httpConfig = {};\n\t            var responseInterceptor = action.interceptor && action.interceptor.response ||\n\t              defaultResponseInterceptor;\n\t            var responseErrorInterceptor = action.interceptor && action.interceptor.responseError ||\n\t              undefined;\n\t            var timeoutDeferred;\n\t            var numericTimeoutPromise;\n\t\n\t            forEach(action, function(value, key) {\n\t              switch (key) {\n\t                default:\n\t                  httpConfig[key] = copy(value);\n\t                  break;\n\t                case 'params':\n\t                case 'isArray':\n\t                case 'interceptor':\n\t                case 'cancellable':\n\t                  break;\n\t              }\n\t            });\n\t\n\t            if (!isInstanceCall && cancellable) {\n\t              timeoutDeferred = $q.defer();\n\t              httpConfig.timeout = timeoutDeferred.promise;\n\t\n\t              if (numericTimeout) {\n\t                numericTimeoutPromise = $timeout(timeoutDeferred.resolve, numericTimeout);\n\t              }\n\t            }\n\t\n\t            if (hasBody) httpConfig.data = data;\n\t            route.setUrlParams(httpConfig,\n\t              extend({}, extractParams(data, action.params || {}), params),\n\t              action.url);\n\t\n\t            var promise = $http(httpConfig).then(function(response) {\n\t              var data = response.data;\n\t\n\t              if (data) {\n\t                // Need to convert action.isArray to boolean in case it is undefined\n\t                // jshint -W018\n\t                if (angular.isArray(data) !== (!!action.isArray)) {\n\t                  throw $resourceMinErr('badcfg',\n\t                      'Error in resource configuration for action `{0}`. Expected response to ' +\n\t                      'contain an {1} but got an {2} (Request: {3} {4})', name, action.isArray ? 'array' : 'object',\n\t                    angular.isArray(data) ? 'array' : 'object', httpConfig.method, httpConfig.url);\n\t                }\n\t                // jshint +W018\n\t                if (action.isArray) {\n\t                  value.length = 0;\n\t                  forEach(data, function(item) {\n\t                    if (typeof item === \"object\") {\n\t                      value.push(new Resource(item));\n\t                    } else {\n\t                      // Valid JSON values may be string literals, and these should not be converted\n\t                      // into objects. These items will not have access to the Resource prototype\n\t                      // methods, but unfortunately there\n\t                      value.push(item);\n\t                    }\n\t                  });\n\t                } else {\n\t                  var promise = value.$promise;     // Save the promise\n\t                  shallowClearAndCopy(data, value);\n\t                  value.$promise = promise;         // Restore the promise\n\t                }\n\t              }\n\t              response.resource = value;\n\t\n\t              return response;\n\t            }, function(response) {\n\t              (error || noop)(response);\n\t              return $q.reject(response);\n\t            });\n\t\n\t            promise['finally'](function() {\n\t              value.$resolved = true;\n\t              if (!isInstanceCall && cancellable) {\n\t                value.$cancelRequest = angular.noop;\n\t                $timeout.cancel(numericTimeoutPromise);\n\t                timeoutDeferred = numericTimeoutPromise = httpConfig.timeout = null;\n\t              }\n\t            });\n\t\n\t            promise = promise.then(\n\t              function(response) {\n\t                var value = responseInterceptor(response);\n\t                (success || noop)(value, response.headers);\n\t                return value;\n\t              },\n\t              responseErrorInterceptor);\n\t\n\t            if (!isInstanceCall) {\n\t              // we are creating instance / collection\n\t              // - set the initial promise\n\t              // - return the instance / collection\n\t              value.$promise = promise;\n\t              value.$resolved = false;\n\t              if (cancellable) value.$cancelRequest = timeoutDeferred.resolve;\n\t\n\t              return value;\n\t            }\n\t\n\t            // instance call\n\t            return promise;\n\t          };\n\t\n\t\n\t          Resource.prototype['$' + name] = function(params, success, error) {\n\t            if (isFunction(params)) {\n\t              error = success; success = params; params = {};\n\t            }\n\t            var result = Resource[name].call(this, params, this, success, error);\n\t            return result.$promise || result;\n\t          };\n\t        });\n\t\n\t        Resource.bind = function(additionalParamDefaults) {\n\t          return resourceFactory(url, extend({}, paramDefaults, additionalParamDefaults), actions);\n\t        };\n\t\n\t        return Resource;\n\t      }\n\t\n\t      return resourceFactory;\n\t    }];\n\t  });\n\t\n\t\n\t})(window, window.angular);\n\n\n/***/ }\n/******/ ]);\n\n\n/** WEBPACK FOOTER **\n ** vendors.js\n **/"," \t// install a JSONP callback for chunk loading\n \tvar parentJsonpFunction = window[\"webpackJsonp\"];\n \twindow[\"webpackJsonp\"] = function webpackJsonpCallback(chunkIds, moreModules) {\n \t\t// add \"moreModules\" to the modules object,\n \t\t// then flag all \"chunkIds\" as loaded and fire callback\n \t\tvar moduleId, chunkId, i = 0, callbacks = [];\n \t\tfor(;i < chunkIds.length; i++) {\n \t\t\tchunkId = chunkIds[i];\n \t\t\tif(installedChunks[chunkId])\n \t\t\t\tcallbacks.push.apply(callbacks, installedChunks[chunkId]);\n \t\t\tinstalledChunks[chunkId] = 0;\n \t\t}\n \t\tfor(moduleId in moreModules) {\n \t\t\tmodules[moduleId] = moreModules[moduleId];\n \t\t}\n \t\tif(parentJsonpFunction) parentJsonpFunction(chunkIds, moreModules);\n \t\twhile(callbacks.length)\n \t\t\tcallbacks.shift().call(null, __webpack_require__);\n \t\tif(moreModules[0]) {\n \t\t\tinstalledModules[0] = 0;\n \t\t\treturn __webpack_require__(0);\n \t\t}\n \t};\n\n \t// The module cache\n \tvar installedModules = {};\n\n \t// object to store loaded and loading chunks\n \t// \"0\" means \"already loaded\"\n \t// Array means \"loading\", array contains callbacks\n \tvar installedChunks = {\n \t\t2:0\n \t};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n \t// This file contains only the entry chunk.\n \t// The chunk loading function for additional chunks\n \t__webpack_require__.e = function requireEnsure(chunkId, callback) {\n \t\t// \"0\" is the signal for \"already loaded\"\n \t\tif(installedChunks[chunkId] === 0)\n \t\t\treturn callback.call(null, __webpack_require__);\n\n \t\t// an array means \"currently loading\".\n \t\tif(installedChunks[chunkId] !== undefined) {\n \t\t\tinstalledChunks[chunkId].push(callback);\n \t\t} else {\n \t\t\t// start chunk loading\n \t\t\tinstalledChunks[chunkId] = [callback];\n \t\t\tvar head = document.getElementsByTagName('head')[0];\n \t\t\tvar script = document.createElement('script');\n \t\t\tscript.type = 'text/javascript';\n \t\t\tscript.charset = 'utf-8';\n \t\t\tscript.async = true;\n\n \t\t\tscript.src = __webpack_require__.p + \"\" + ({\"0\":\"app\",\"1\":\"core\"}[chunkId]||chunkId) + \".feature.js\";\n \t\t\thead.appendChild(script);\n \t\t}\n \t};\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n\n/** WEBPACK FOOTER **\n ** webpack/bootstrap e60d7c0b1027f6960c45\n **/","\nimport coreCommon from '../../components/core.common.module';\nimport uiRouter from 'angular-ui-router';\nimport translate from 'angular-translate';\nimport cookies from 'angular-cookies';\nimport ngResource from 'angular-resource';\n\nexport default angular.module(\"core.base\", [\n    coreCommon,\n    uiRouter,\n    translate,\n    cookies,\n    ngResource\n]).name;\n\n\n/** WEBPACK FOOTER **\n ** ./core/client/modules/base/core.base.module.js\n **/","import angular from 'angular';\n\nimport svgImage from './svg-image/core.common.svg-image';\nimport StaticLoader from './static-loader/core.common.static-loader';\nimport errSrc from './err-src/core.common.err-src';\n\nexport default angular.module('core.common', [])\n    .directive(svgImage)\n    .directive(errSrc)\n    .provider('staticLoader', StaticLoader)\n    .name;\n\n\n\n/** WEBPACK FOOTER **\n ** ./core/client/components/core.common.module.js\n **/","module.exports = angular;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** external \"angular\"\n ** module id = 3\n ** module chunks = 2\n **/","\nsvgImage.$inject = ['$http'];\nexport default function svgImage($http) {\n    return {\n        restrict: 'E',\n        link: function (scope, element) {\n            var imgURL = element.attr('src');\n            // if you want to use ng-include, then\n            // instead of the above line write the bellow:\n            // var imgURL = element.attr('ng-include');\n            var request = $http.get(\n                imgURL,\n                {'Content-Type': 'application/xml'}\n            );\n\n            scope.manipulateImgNode = function (data, elem) {\n                var $svg = angular.element(data)[4];\n                var imgClass = elem.attr('class');\n                if (typeof(imgClass) !== 'undefined') {\n                    var classes = imgClass.split(' ');\n                    for (var i = 0; i < classes.length; ++i) {\n                        $svg.classList.add(classes[i]);\n                    }\n                }\n                $svg.removeAttribute('xmlns:a');\n                return $svg;\n            };\n\n            request.success(function (data) {\n                element.replaceWith(scope.manipulateImgNode(data, element));\n            });\n        }\n    };\n}\n\n\n/** WEBPACK FOOTER **\n ** ./core/client/components/svg-image/core.common.svg-image.js\n **/","export default class StaticLoader {\n    constructor() {\n        this.rootPath = \"\";\n        this.cacheMap = {};\n    }\n    setRootPath(path) {\n        this.rootPath = path;\n    }\n    $get($http) {\n        var factory = {};\n        var self = this;\n        factory.get = function (path, callback) {\n            if (rootPath) {\n                path = self.rootPath + path;\n            }\n            if (self.cacheMap[self.cacheMap]) {\n                return callback(200, self.cacheMap[self.cacheMap]);\n            }\n            $http.get(path).then(function (res) {\n                if (res.status == 200) {\n                    self.cacheMap[path] = res.data;\n                }\n                callback(res.status, res.data);\n            });\n        };\n        return factory;\n    }\n}\n\n\n\n/** WEBPACK FOOTER **\n ** ./core/client/components/static-loader/core.common.static-loader.js\n **/","\nexport default function errSrc() {\n    return {\n        link: function (scope, element, attrs) {\n            element.bind('error', function () {\n                if (attrs.isHide == true) {\n                    element.css('display', 'block');\n                }\n                if (attrs.src != attrs.errSrc) {\n                    attrs.$set('src', attrs.errSrc);\n                }\n            });\n        }\n    }\n}\n\n\n/** WEBPACK FOOTER **\n ** ./core/client/components/err-src/core.common.err-src.js\n **/","/**\n * State-based routing for AngularJS\n * @version v0.3.1\n * @link http://angular-ui.github.com/\n * @license MIT License, http://www.opensource.org/licenses/MIT\n */\n\n/* commonjs package manager support (eg componentjs) */\nif (typeof module !== \"undefined\" && typeof exports !== \"undefined\" && module.exports === exports){\n  module.exports = 'ui.router';\n}\n\n(function (window, angular, undefined) {\n/*jshint globalstrict:true*/\n/*global angular:false*/\n'use strict';\n\nvar isDefined = angular.isDefined,\n    isFunction = angular.isFunction,\n    isString = angular.isString,\n    isObject = angular.isObject,\n    isArray = angular.isArray,\n    forEach = angular.forEach,\n    extend = angular.extend,\n    copy = angular.copy,\n    toJson = angular.toJson;\n\nfunction inherit(parent, extra) {\n  return extend(new (extend(function() {}, { prototype: parent }))(), extra);\n}\n\nfunction merge(dst) {\n  forEach(arguments, function(obj) {\n    if (obj !== dst) {\n      forEach(obj, function(value, key) {\n        if (!dst.hasOwnProperty(key)) dst[key] = value;\n      });\n    }\n  });\n  return dst;\n}\n\n/**\n * Finds the common ancestor path between two states.\n *\n * @param {Object} first The first state.\n * @param {Object} second The second state.\n * @return {Array} Returns an array of state names in descending order, not including the root.\n */\nfunction ancestors(first, second) {\n  var path = [];\n\n  for (var n in first.path) {\n    if (first.path[n] !== second.path[n]) break;\n    path.push(first.path[n]);\n  }\n  return path;\n}\n\n/**\n * IE8-safe wrapper for `Object.keys()`.\n *\n * @param {Object} object A JavaScript object.\n * @return {Array} Returns the keys of the object as an array.\n */\nfunction objectKeys(object) {\n  if (Object.keys) {\n    return Object.keys(object);\n  }\n  var result = [];\n\n  forEach(object, function(val, key) {\n    result.push(key);\n  });\n  return result;\n}\n\n/**\n * IE8-safe wrapper for `Array.prototype.indexOf()`.\n *\n * @param {Array} array A JavaScript array.\n * @param {*} value A value to search the array for.\n * @return {Number} Returns the array index value of `value`, or `-1` if not present.\n */\nfunction indexOf(array, value) {\n  if (Array.prototype.indexOf) {\n    return array.indexOf(value, Number(arguments[2]) || 0);\n  }\n  var len = array.length >>> 0, from = Number(arguments[2]) || 0;\n  from = (from < 0) ? Math.ceil(from) : Math.floor(from);\n\n  if (from < 0) from += len;\n\n  for (; from < len; from++) {\n    if (from in array && array[from] === value) return from;\n  }\n  return -1;\n}\n\n/**\n * Merges a set of parameters with all parameters inherited between the common parents of the\n * current state and a given destination state.\n *\n * @param {Object} currentParams The value of the current state parameters ($stateParams).\n * @param {Object} newParams The set of parameters which will be composited with inherited params.\n * @param {Object} $current Internal definition of object representing the current state.\n * @param {Object} $to Internal definition of object representing state to transition to.\n */\nfunction inheritParams(currentParams, newParams, $current, $to) {\n  var parents = ancestors($current, $to), parentParams, inherited = {}, inheritList = [];\n\n  for (var i in parents) {\n    if (!parents[i] || !parents[i].params) continue;\n    parentParams = objectKeys(parents[i].params);\n    if (!parentParams.length) continue;\n\n    for (var j in parentParams) {\n      if (indexOf(inheritList, parentParams[j]) >= 0) continue;\n      inheritList.push(parentParams[j]);\n      inherited[parentParams[j]] = currentParams[parentParams[j]];\n    }\n  }\n  return extend({}, inherited, newParams);\n}\n\n/**\n * Performs a non-strict comparison of the subset of two objects, defined by a list of keys.\n *\n * @param {Object} a The first object.\n * @param {Object} b The second object.\n * @param {Array} keys The list of keys within each object to compare. If the list is empty or not specified,\n *                     it defaults to the list of keys in `a`.\n * @return {Boolean} Returns `true` if the keys match, otherwise `false`.\n */\nfunction equalForKeys(a, b, keys) {\n  if (!keys) {\n    keys = [];\n    for (var n in a) keys.push(n); // Used instead of Object.keys() for IE8 compatibility\n  }\n\n  for (var i=0; i<keys.length; i++) {\n    var k = keys[i];\n    if (a[k] != b[k]) return false; // Not '===', values aren't necessarily normalized\n  }\n  return true;\n}\n\n/**\n * Returns the subset of an object, based on a list of keys.\n *\n * @param {Array} keys\n * @param {Object} values\n * @return {Boolean} Returns a subset of `values`.\n */\nfunction filterByKeys(keys, values) {\n  var filtered = {};\n\n  forEach(keys, function (name) {\n    filtered[name] = values[name];\n  });\n  return filtered;\n}\n\n// like _.indexBy\n// when you know that your index values will be unique, or you want last-one-in to win\nfunction indexBy(array, propName) {\n  var result = {};\n  forEach(array, function(item) {\n    result[item[propName]] = item;\n  });\n  return result;\n}\n\n// extracted from underscore.js\n// Return a copy of the object only containing the whitelisted properties.\nfunction pick(obj) {\n  var copy = {};\n  var keys = Array.prototype.concat.apply(Array.prototype, Array.prototype.slice.call(arguments, 1));\n  forEach(keys, function(key) {\n    if (key in obj) copy[key] = obj[key];\n  });\n  return copy;\n}\n\n// extracted from underscore.js\n// Return a copy of the object omitting the blacklisted properties.\nfunction omit(obj) {\n  var copy = {};\n  var keys = Array.prototype.concat.apply(Array.prototype, Array.prototype.slice.call(arguments, 1));\n  for (var key in obj) {\n    if (indexOf(keys, key) == -1) copy[key] = obj[key];\n  }\n  return copy;\n}\n\nfunction pluck(collection, key) {\n  var result = isArray(collection) ? [] : {};\n\n  forEach(collection, function(val, i) {\n    result[i] = isFunction(key) ? key(val) : val[key];\n  });\n  return result;\n}\n\nfunction filter(collection, callback) {\n  var array = isArray(collection);\n  var result = array ? [] : {};\n  forEach(collection, function(val, i) {\n    if (callback(val, i)) {\n      result[array ? result.length : i] = val;\n    }\n  });\n  return result;\n}\n\nfunction map(collection, callback) {\n  var result = isArray(collection) ? [] : {};\n\n  forEach(collection, function(val, i) {\n    result[i] = callback(val, i);\n  });\n  return result;\n}\n\n/**\n * @ngdoc overview\n * @name ui.router.util\n *\n * @description\n * # ui.router.util sub-module\n *\n * This module is a dependency of other sub-modules. Do not include this module as a dependency\n * in your angular app (use {@link ui.router} module instead).\n *\n */\nangular.module('ui.router.util', ['ng']);\n\n/**\n * @ngdoc overview\n * @name ui.router.router\n * \n * @requires ui.router.util\n *\n * @description\n * # ui.router.router sub-module\n *\n * This module is a dependency of other sub-modules. Do not include this module as a dependency\n * in your angular app (use {@link ui.router} module instead).\n */\nangular.module('ui.router.router', ['ui.router.util']);\n\n/**\n * @ngdoc overview\n * @name ui.router.state\n * \n * @requires ui.router.router\n * @requires ui.router.util\n *\n * @description\n * # ui.router.state sub-module\n *\n * This module is a dependency of the main ui.router module. Do not include this module as a dependency\n * in your angular app (use {@link ui.router} module instead).\n * \n */\nangular.module('ui.router.state', ['ui.router.router', 'ui.router.util']);\n\n/**\n * @ngdoc overview\n * @name ui.router\n *\n * @requires ui.router.state\n *\n * @description\n * # ui.router\n * \n * ## The main module for ui.router \n * There are several sub-modules included with the ui.router module, however only this module is needed\n * as a dependency within your angular app. The other modules are for organization purposes. \n *\n * The modules are:\n * * ui.router - the main \"umbrella\" module\n * * ui.router.router - \n * \n * *You'll need to include **only** this module as the dependency within your angular app.*\n * \n * <pre>\n * <!doctype html>\n * <html ng-app=\"myApp\">\n * <head>\n *   <script src=\"js/angular.js\"></script>\n *   <!-- Include the ui-router script -->\n *   <script src=\"js/angular-ui-router.min.js\"></script>\n *   <script>\n *     // ...and add 'ui.router' as a dependency\n *     var myApp = angular.module('myApp', ['ui.router']);\n *   </script>\n * </head>\n * <body>\n * </body>\n * </html>\n * </pre>\n */\nangular.module('ui.router', ['ui.router.state']);\n\nangular.module('ui.router.compat', ['ui.router']);\n\n/**\n * @ngdoc object\n * @name ui.router.util.$resolve\n *\n * @requires $q\n * @requires $injector\n *\n * @description\n * Manages resolution of (acyclic) graphs of promises.\n */\n$Resolve.$inject = ['$q', '$injector'];\nfunction $Resolve(  $q,    $injector) {\n  \n  var VISIT_IN_PROGRESS = 1,\n      VISIT_DONE = 2,\n      NOTHING = {},\n      NO_DEPENDENCIES = [],\n      NO_LOCALS = NOTHING,\n      NO_PARENT = extend($q.when(NOTHING), { $$promises: NOTHING, $$values: NOTHING });\n  \n\n  /**\n   * @ngdoc function\n   * @name ui.router.util.$resolve#study\n   * @methodOf ui.router.util.$resolve\n   *\n   * @description\n   * Studies a set of invocables that are likely to be used multiple times.\n   * <pre>\n   * $resolve.study(invocables)(locals, parent, self)\n   * </pre>\n   * is equivalent to\n   * <pre>\n   * $resolve.resolve(invocables, locals, parent, self)\n   * </pre>\n   * but the former is more efficient (in fact `resolve` just calls `study` \n   * internally).\n   *\n   * @param {object} invocables Invocable objects\n   * @return {function} a function to pass in locals, parent and self\n   */\n  this.study = function (invocables) {\n    if (!isObject(invocables)) throw new Error(\"'invocables' must be an object\");\n    var invocableKeys = objectKeys(invocables || {});\n    \n    // Perform a topological sort of invocables to build an ordered plan\n    var plan = [], cycle = [], visited = {};\n    function visit(value, key) {\n      if (visited[key] === VISIT_DONE) return;\n      \n      cycle.push(key);\n      if (visited[key] === VISIT_IN_PROGRESS) {\n        cycle.splice(0, indexOf(cycle, key));\n        throw new Error(\"Cyclic dependency: \" + cycle.join(\" -> \"));\n      }\n      visited[key] = VISIT_IN_PROGRESS;\n      \n      if (isString(value)) {\n        plan.push(key, [ function() { return $injector.get(value); }], NO_DEPENDENCIES);\n      } else {\n        var params = $injector.annotate(value);\n        forEach(params, function (param) {\n          if (param !== key && invocables.hasOwnProperty(param)) visit(invocables[param], param);\n        });\n        plan.push(key, value, params);\n      }\n      \n      cycle.pop();\n      visited[key] = VISIT_DONE;\n    }\n    forEach(invocables, visit);\n    invocables = cycle = visited = null; // plan is all that's required\n    \n    function isResolve(value) {\n      return isObject(value) && value.then && value.$$promises;\n    }\n    \n    return function (locals, parent, self) {\n      if (isResolve(locals) && self === undefined) {\n        self = parent; parent = locals; locals = null;\n      }\n      if (!locals) locals = NO_LOCALS;\n      else if (!isObject(locals)) {\n        throw new Error(\"'locals' must be an object\");\n      }       \n      if (!parent) parent = NO_PARENT;\n      else if (!isResolve(parent)) {\n        throw new Error(\"'parent' must be a promise returned by $resolve.resolve()\");\n      }\n      \n      // To complete the overall resolution, we have to wait for the parent\n      // promise and for the promise for each invokable in our plan.\n      var resolution = $q.defer(),\n          result = resolution.promise,\n          promises = result.$$promises = {},\n          values = extend({}, locals),\n          wait = 1 + plan.length/3,\n          merged = false;\n          \n      function done() {\n        // Merge parent values we haven't got yet and publish our own $$values\n        if (!--wait) {\n          if (!merged) merge(values, parent.$$values); \n          result.$$values = values;\n          result.$$promises = result.$$promises || true; // keep for isResolve()\n          delete result.$$inheritedValues;\n          resolution.resolve(values);\n        }\n      }\n      \n      function fail(reason) {\n        result.$$failure = reason;\n        resolution.reject(reason);\n      }\n\n      // Short-circuit if parent has already failed\n      if (isDefined(parent.$$failure)) {\n        fail(parent.$$failure);\n        return result;\n      }\n      \n      if (parent.$$inheritedValues) {\n        merge(values, omit(parent.$$inheritedValues, invocableKeys));\n      }\n\n      // Merge parent values if the parent has already resolved, or merge\n      // parent promises and wait if the parent resolve is still in progress.\n      extend(promises, parent.$$promises);\n      if (parent.$$values) {\n        merged = merge(values, omit(parent.$$values, invocableKeys));\n        result.$$inheritedValues = omit(parent.$$values, invocableKeys);\n        done();\n      } else {\n        if (parent.$$inheritedValues) {\n          result.$$inheritedValues = omit(parent.$$inheritedValues, invocableKeys);\n        }        \n        parent.then(done, fail);\n      }\n      \n      // Process each invocable in the plan, but ignore any where a local of the same name exists.\n      for (var i=0, ii=plan.length; i<ii; i+=3) {\n        if (locals.hasOwnProperty(plan[i])) done();\n        else invoke(plan[i], plan[i+1], plan[i+2]);\n      }\n      \n      function invoke(key, invocable, params) {\n        // Create a deferred for this invocation. Failures will propagate to the resolution as well.\n        var invocation = $q.defer(), waitParams = 0;\n        function onfailure(reason) {\n          invocation.reject(reason);\n          fail(reason);\n        }\n        // Wait for any parameter that we have a promise for (either from parent or from this\n        // resolve; in that case study() will have made sure it's ordered before us in the plan).\n        forEach(params, function (dep) {\n          if (promises.hasOwnProperty(dep) && !locals.hasOwnProperty(dep)) {\n            waitParams++;\n            promises[dep].then(function (result) {\n              values[dep] = result;\n              if (!(--waitParams)) proceed();\n            }, onfailure);\n          }\n        });\n        if (!waitParams) proceed();\n        function proceed() {\n          if (isDefined(result.$$failure)) return;\n          try {\n            invocation.resolve($injector.invoke(invocable, self, values));\n            invocation.promise.then(function (result) {\n              values[key] = result;\n              done();\n            }, onfailure);\n          } catch (e) {\n            onfailure(e);\n          }\n        }\n        // Publish promise synchronously; invocations further down in the plan may depend on it.\n        promises[key] = invocation.promise;\n      }\n      \n      return result;\n    };\n  };\n  \n  /**\n   * @ngdoc function\n   * @name ui.router.util.$resolve#resolve\n   * @methodOf ui.router.util.$resolve\n   *\n   * @description\n   * Resolves a set of invocables. An invocable is a function to be invoked via \n   * `$injector.invoke()`, and can have an arbitrary number of dependencies. \n   * An invocable can either return a value directly,\n   * or a `$q` promise. If a promise is returned it will be resolved and the \n   * resulting value will be used instead. Dependencies of invocables are resolved \n   * (in this order of precedence)\n   *\n   * - from the specified `locals`\n   * - from another invocable that is part of this `$resolve` call\n   * - from an invocable that is inherited from a `parent` call to `$resolve` \n   *   (or recursively\n   * - from any ancestor `$resolve` of that parent).\n   *\n   * The return value of `$resolve` is a promise for an object that contains \n   * (in this order of precedence)\n   *\n   * - any `locals` (if specified)\n   * - the resolved return values of all injectables\n   * - any values inherited from a `parent` call to `$resolve` (if specified)\n   *\n   * The promise will resolve after the `parent` promise (if any) and all promises \n   * returned by injectables have been resolved. If any invocable \n   * (or `$injector.invoke`) throws an exception, or if a promise returned by an \n   * invocable is rejected, the `$resolve` promise is immediately rejected with the \n   * same error. A rejection of a `parent` promise (if specified) will likewise be \n   * propagated immediately. Once the `$resolve` promise has been rejected, no \n   * further invocables will be called.\n   * \n   * Cyclic dependencies between invocables are not permitted and will cause `$resolve`\n   * to throw an error. As a special case, an injectable can depend on a parameter \n   * with the same name as the injectable, which will be fulfilled from the `parent` \n   * injectable of the same name. This allows inherited values to be decorated. \n   * Note that in this case any other injectable in the same `$resolve` with the same\n   * dependency would see the decorated value, not the inherited value.\n   *\n   * Note that missing dependencies -- unlike cyclic dependencies -- will cause an \n   * (asynchronous) rejection of the `$resolve` promise rather than a (synchronous) \n   * exception.\n   *\n   * Invocables are invoked eagerly as soon as all dependencies are available. \n   * This is true even for dependencies inherited from a `parent` call to `$resolve`.\n   *\n   * As a special case, an invocable can be a string, in which case it is taken to \n   * be a service name to be passed to `$injector.get()`. This is supported primarily \n   * for backwards-compatibility with the `resolve` property of `$routeProvider` \n   * routes.\n   *\n   * @param {object} invocables functions to invoke or \n   * `$injector` services to fetch.\n   * @param {object} locals  values to make available to the injectables\n   * @param {object} parent  a promise returned by another call to `$resolve`.\n   * @param {object} self  the `this` for the invoked methods\n   * @return {object} Promise for an object that contains the resolved return value\n   * of all invocables, as well as any inherited and local values.\n   */\n  this.resolve = function (invocables, locals, parent, self) {\n    return this.study(invocables)(locals, parent, self);\n  };\n}\n\nangular.module('ui.router.util').service('$resolve', $Resolve);\n\n\n/**\n * @ngdoc object\n * @name ui.router.util.$templateFactory\n *\n * @requires $http\n * @requires $templateCache\n * @requires $injector\n *\n * @description\n * Service. Manages loading of templates.\n */\n$TemplateFactory.$inject = ['$http', '$templateCache', '$injector'];\nfunction $TemplateFactory(  $http,   $templateCache,   $injector) {\n\n  /**\n   * @ngdoc function\n   * @name ui.router.util.$templateFactory#fromConfig\n   * @methodOf ui.router.util.$templateFactory\n   *\n   * @description\n   * Creates a template from a configuration object. \n   *\n   * @param {object} config Configuration object for which to load a template. \n   * The following properties are search in the specified order, and the first one \n   * that is defined is used to create the template:\n   *\n   * @param {string|object} config.template html string template or function to \n   * load via {@link ui.router.util.$templateFactory#fromString fromString}.\n   * @param {string|object} config.templateUrl url to load or a function returning \n   * the url to load via {@link ui.router.util.$templateFactory#fromUrl fromUrl}.\n   * @param {Function} config.templateProvider function to invoke via \n   * {@link ui.router.util.$templateFactory#fromProvider fromProvider}.\n   * @param {object} params  Parameters to pass to the template function.\n   * @param {object} locals Locals to pass to `invoke` if the template is loaded \n   * via a `templateProvider`. Defaults to `{ params: params }`.\n   *\n   * @return {string|object}  The template html as a string, or a promise for \n   * that string,or `null` if no template is configured.\n   */\n  this.fromConfig = function (config, params, locals) {\n    return (\n      isDefined(config.template) ? this.fromString(config.template, params) :\n      isDefined(config.templateUrl) ? this.fromUrl(config.templateUrl, params) :\n      isDefined(config.templateProvider) ? this.fromProvider(config.templateProvider, params, locals) :\n      null\n    );\n  };\n\n  /**\n   * @ngdoc function\n   * @name ui.router.util.$templateFactory#fromString\n   * @methodOf ui.router.util.$templateFactory\n   *\n   * @description\n   * Creates a template from a string or a function returning a string.\n   *\n   * @param {string|object} template html template as a string or function that \n   * returns an html template as a string.\n   * @param {object} params Parameters to pass to the template function.\n   *\n   * @return {string|object} The template html as a string, or a promise for that \n   * string.\n   */\n  this.fromString = function (template, params) {\n    return isFunction(template) ? template(params) : template;\n  };\n\n  /**\n   * @ngdoc function\n   * @name ui.router.util.$templateFactory#fromUrl\n   * @methodOf ui.router.util.$templateFactory\n   * \n   * @description\n   * Loads a template from the a URL via `$http` and `$templateCache`.\n   *\n   * @param {string|Function} url url of the template to load, or a function \n   * that returns a url.\n   * @param {Object} params Parameters to pass to the url function.\n   * @return {string|Promise.<string>} The template html as a string, or a promise \n   * for that string.\n   */\n  this.fromUrl = function (url, params) {\n    if (isFunction(url)) url = url(params);\n    if (url == null) return null;\n    else return $http\n        .get(url, { cache: $templateCache, headers: { Accept: 'text/html' }})\n        .then(function(response) { return response.data; });\n  };\n\n  /**\n   * @ngdoc function\n   * @name ui.router.util.$templateFactory#fromProvider\n   * @methodOf ui.router.util.$templateFactory\n   *\n   * @description\n   * Creates a template by invoking an injectable provider function.\n   *\n   * @param {Function} provider Function to invoke via `$injector.invoke`\n   * @param {Object} params Parameters for the template.\n   * @param {Object} locals Locals to pass to `invoke`. Defaults to \n   * `{ params: params }`.\n   * @return {string|Promise.<string>} The template html as a string, or a promise \n   * for that string.\n   */\n  this.fromProvider = function (provider, params, locals) {\n    return $injector.invoke(provider, null, locals || { params: params });\n  };\n}\n\nangular.module('ui.router.util').service('$templateFactory', $TemplateFactory);\n\nvar $$UMFP; // reference to $UrlMatcherFactoryProvider\n\n/**\n * @ngdoc object\n * @name ui.router.util.type:UrlMatcher\n *\n * @description\n * Matches URLs against patterns and extracts named parameters from the path or the search\n * part of the URL. A URL pattern consists of a path pattern, optionally followed by '?' and a list\n * of search parameters. Multiple search parameter names are separated by '&'. Search parameters\n * do not influence whether or not a URL is matched, but their values are passed through into\n * the matched parameters returned by {@link ui.router.util.type:UrlMatcher#methods_exec exec}.\n *\n * Path parameter placeholders can be specified using simple colon/catch-all syntax or curly brace\n * syntax, which optionally allows a regular expression for the parameter to be specified:\n *\n * * `':'` name - colon placeholder\n * * `'*'` name - catch-all placeholder\n * * `'{' name '}'` - curly placeholder\n * * `'{' name ':' regexp|type '}'` - curly placeholder with regexp or type name. Should the\n *   regexp itself contain curly braces, they must be in matched pairs or escaped with a backslash.\n *\n * Parameter names may contain only word characters (latin letters, digits, and underscore) and\n * must be unique within the pattern (across both path and search parameters). For colon\n * placeholders or curly placeholders without an explicit regexp, a path parameter matches any\n * number of characters other than '/'. For catch-all placeholders the path parameter matches\n * any number of characters.\n *\n * Examples:\n *\n * * `'/hello/'` - Matches only if the path is exactly '/hello/'. There is no special treatment for\n *   trailing slashes, and patterns have to match the entire path, not just a prefix.\n * * `'/user/:id'` - Matches '/user/bob' or '/user/1234!!!' or even '/user/' but not '/user' or\n *   '/user/bob/details'. The second path segment will be captured as the parameter 'id'.\n * * `'/user/{id}'` - Same as the previous example, but using curly brace syntax.\n * * `'/user/{id:[^/]*}'` - Same as the previous example.\n * * `'/user/{id:[0-9a-fA-F]{1,8}}'` - Similar to the previous example, but only matches if the id\n *   parameter consists of 1 to 8 hex digits.\n * * `'/files/{path:.*}'` - Matches any URL starting with '/files/' and captures the rest of the\n *   path into the parameter 'path'.\n * * `'/files/*path'` - ditto.\n * * `'/calendar/{start:date}'` - Matches \"/calendar/2014-11-12\" (because the pattern defined\n *   in the built-in  `date` Type matches `2014-11-12`) and provides a Date object in $stateParams.start\n *\n * @param {string} pattern  The pattern to compile into a matcher.\n * @param {Object} config  A configuration object hash:\n * @param {Object=} parentMatcher Used to concatenate the pattern/config onto\n *   an existing UrlMatcher\n *\n * * `caseInsensitive` - `true` if URL matching should be case insensitive, otherwise `false`, the default value (for backward compatibility) is `false`.\n * * `strict` - `false` if matching against a URL with a trailing slash should be treated as equivalent to a URL without a trailing slash, the default value is `true`.\n *\n * @property {string} prefix  A static prefix of this pattern. The matcher guarantees that any\n *   URL matching this matcher (i.e. any string for which {@link ui.router.util.type:UrlMatcher#methods_exec exec()} returns\n *   non-null) will start with this prefix.\n *\n * @property {string} source  The pattern that was passed into the constructor\n *\n * @property {string} sourcePath  The path portion of the source property\n *\n * @property {string} sourceSearch  The search portion of the source property\n *\n * @property {string} regex  The constructed regex that will be used to match against the url when\n *   it is time to determine which url will match.\n *\n * @returns {Object}  New `UrlMatcher` object\n */\nfunction UrlMatcher(pattern, config, parentMatcher) {\n  config = extend({ params: {} }, isObject(config) ? config : {});\n\n  // Find all placeholders and create a compiled pattern, using either classic or curly syntax:\n  //   '*' name\n  //   ':' name\n  //   '{' name '}'\n  //   '{' name ':' regexp '}'\n  // The regular expression is somewhat complicated due to the need to allow curly braces\n  // inside the regular expression. The placeholder regexp breaks down as follows:\n  //    ([:*])([\\w\\[\\]]+)              - classic placeholder ($1 / $2) (search version has - for snake-case)\n  //    \\{([\\w\\[\\]]+)(?:\\:\\s*( ... ))?\\}  - curly brace placeholder ($3) with optional regexp/type ... ($4) (search version has - for snake-case\n  //    (?: ... | ... | ... )+         - the regexp consists of any number of atoms, an atom being either\n  //    [^{}\\\\]+                       - anything other than curly braces or backslash\n  //    \\\\.                            - a backslash escape\n  //    \\{(?:[^{}\\\\]+|\\\\.)*\\}          - a matched set of curly braces containing other atoms\n  var placeholder       = /([:*])([\\w\\[\\]]+)|\\{([\\w\\[\\]]+)(?:\\:\\s*((?:[^{}\\\\]+|\\\\.|\\{(?:[^{}\\\\]+|\\\\.)*\\})+))?\\}/g,\n      searchPlaceholder = /([:]?)([\\w\\[\\].-]+)|\\{([\\w\\[\\].-]+)(?:\\:\\s*((?:[^{}\\\\]+|\\\\.|\\{(?:[^{}\\\\]+|\\\\.)*\\})+))?\\}/g,\n      compiled = '^', last = 0, m,\n      segments = this.segments = [],\n      parentParams = parentMatcher ? parentMatcher.params : {},\n      params = this.params = parentMatcher ? parentMatcher.params.$$new() : new $$UMFP.ParamSet(),\n      paramNames = [];\n\n  function addParameter(id, type, config, location) {\n    paramNames.push(id);\n    if (parentParams[id]) return parentParams[id];\n    if (!/^\\w+([-.]+\\w+)*(?:\\[\\])?$/.test(id)) throw new Error(\"Invalid parameter name '\" + id + \"' in pattern '\" + pattern + \"'\");\n    if (params[id]) throw new Error(\"Duplicate parameter name '\" + id + \"' in pattern '\" + pattern + \"'\");\n    params[id] = new $$UMFP.Param(id, type, config, location);\n    return params[id];\n  }\n\n  function quoteRegExp(string, pattern, squash, optional) {\n    var surroundPattern = ['',''], result = string.replace(/[\\\\\\[\\]\\^$*+?.()|{}]/g, \"\\\\$&\");\n    if (!pattern) return result;\n    switch(squash) {\n      case false: surroundPattern = ['(', ')' + (optional ? \"?\" : \"\")]; break;\n      case true:\n        result = result.replace(/\\/$/, '');\n        surroundPattern = ['(?:\\/(', ')|\\/)?'];\n      break;\n      default:    surroundPattern = ['(' + squash + \"|\", ')?']; break;\n    }\n    return result + surroundPattern[0] + pattern + surroundPattern[1];\n  }\n\n  this.source = pattern;\n\n  // Split into static segments separated by path parameter placeholders.\n  // The number of segments is always 1 more than the number of parameters.\n  function matchDetails(m, isSearch) {\n    var id, regexp, segment, type, cfg, arrayMode;\n    id          = m[2] || m[3]; // IE[78] returns '' for unmatched groups instead of null\n    cfg         = config.params[id];\n    segment     = pattern.substring(last, m.index);\n    regexp      = isSearch ? m[4] : m[4] || (m[1] == '*' ? '.*' : null);\n\n    if (regexp) {\n      type      = $$UMFP.type(regexp) || inherit($$UMFP.type(\"string\"), { pattern: new RegExp(regexp, config.caseInsensitive ? 'i' : undefined) });\n    }\n\n    return {\n      id: id, regexp: regexp, segment: segment, type: type, cfg: cfg\n    };\n  }\n\n  var p, param, segment;\n  while ((m = placeholder.exec(pattern))) {\n    p = matchDetails(m, false);\n    if (p.segment.indexOf('?') >= 0) break; // we're into the search part\n\n    param = addParameter(p.id, p.type, p.cfg, \"path\");\n    compiled += quoteRegExp(p.segment, param.type.pattern.source, param.squash, param.isOptional);\n    segments.push(p.segment);\n    last = placeholder.lastIndex;\n  }\n  segment = pattern.substring(last);\n\n  // Find any search parameter names and remove them from the last segment\n  var i = segment.indexOf('?');\n\n  if (i >= 0) {\n    var search = this.sourceSearch = segment.substring(i);\n    segment = segment.substring(0, i);\n    this.sourcePath = pattern.substring(0, last + i);\n\n    if (search.length > 0) {\n      last = 0;\n      while ((m = searchPlaceholder.exec(search))) {\n        p = matchDetails(m, true);\n        param = addParameter(p.id, p.type, p.cfg, \"search\");\n        last = placeholder.lastIndex;\n        // check if ?&\n      }\n    }\n  } else {\n    this.sourcePath = pattern;\n    this.sourceSearch = '';\n  }\n\n  compiled += quoteRegExp(segment) + (config.strict === false ? '\\/?' : '') + '$';\n  segments.push(segment);\n\n  this.regexp = new RegExp(compiled, config.caseInsensitive ? 'i' : undefined);\n  this.prefix = segments[0];\n  this.$$paramNames = paramNames;\n}\n\n/**\n * @ngdoc function\n * @name ui.router.util.type:UrlMatcher#concat\n * @methodOf ui.router.util.type:UrlMatcher\n *\n * @description\n * Returns a new matcher for a pattern constructed by appending the path part and adding the\n * search parameters of the specified pattern to this pattern. The current pattern is not\n * modified. This can be understood as creating a pattern for URLs that are relative to (or\n * suffixes of) the current pattern.\n *\n * @example\n * The following two matchers are equivalent:\n * <pre>\n * new UrlMatcher('/user/{id}?q').concat('/details?date');\n * new UrlMatcher('/user/{id}/details?q&date');\n * </pre>\n *\n * @param {string} pattern  The pattern to append.\n * @param {Object} config  An object hash of the configuration for the matcher.\n * @returns {UrlMatcher}  A matcher for the concatenated pattern.\n */\nUrlMatcher.prototype.concat = function (pattern, config) {\n  // Because order of search parameters is irrelevant, we can add our own search\n  // parameters to the end of the new pattern. Parse the new pattern by itself\n  // and then join the bits together, but it's much easier to do this on a string level.\n  var defaultConfig = {\n    caseInsensitive: $$UMFP.caseInsensitive(),\n    strict: $$UMFP.strictMode(),\n    squash: $$UMFP.defaultSquashPolicy()\n  };\n  return new UrlMatcher(this.sourcePath + pattern + this.sourceSearch, extend(defaultConfig, config), this);\n};\n\nUrlMatcher.prototype.toString = function () {\n  return this.source;\n};\n\n/**\n * @ngdoc function\n * @name ui.router.util.type:UrlMatcher#exec\n * @methodOf ui.router.util.type:UrlMatcher\n *\n * @description\n * Tests the specified path against this matcher, and returns an object containing the captured\n * parameter values, or null if the path does not match. The returned object contains the values\n * of any search parameters that are mentioned in the pattern, but their value may be null if\n * they are not present in `searchParams`. This means that search parameters are always treated\n * as optional.\n *\n * @example\n * <pre>\n * new UrlMatcher('/user/{id}?q&r').exec('/user/bob', {\n *   x: '1', q: 'hello'\n * });\n * // returns { id: 'bob', q: 'hello', r: null }\n * </pre>\n *\n * @param {string} path  The URL path to match, e.g. `$location.path()`.\n * @param {Object} searchParams  URL search parameters, e.g. `$location.search()`.\n * @returns {Object}  The captured parameter values.\n */\nUrlMatcher.prototype.exec = function (path, searchParams) {\n  var m = this.regexp.exec(path);\n  if (!m) return null;\n  searchParams = searchParams || {};\n\n  var paramNames = this.parameters(), nTotal = paramNames.length,\n    nPath = this.segments.length - 1,\n    values = {}, i, j, cfg, paramName;\n\n  if (nPath !== m.length - 1) throw new Error(\"Unbalanced capture group in route '\" + this.source + \"'\");\n\n  function decodePathArray(string) {\n    function reverseString(str) { return str.split(\"\").reverse().join(\"\"); }\n    function unquoteDashes(str) { return str.replace(/\\\\-/g, \"-\"); }\n\n    var split = reverseString(string).split(/-(?!\\\\)/);\n    var allReversed = map(split, reverseString);\n    return map(allReversed, unquoteDashes).reverse();\n  }\n\n  var param, paramVal;\n  for (i = 0; i < nPath; i++) {\n    paramName = paramNames[i];\n    param = this.params[paramName];\n    paramVal = m[i+1];\n    // if the param value matches a pre-replace pair, replace the value before decoding.\n    for (j = 0; j < param.replace.length; j++) {\n      if (param.replace[j].from === paramVal) paramVal = param.replace[j].to;\n    }\n    if (paramVal && param.array === true) paramVal = decodePathArray(paramVal);\n    if (isDefined(paramVal)) paramVal = param.type.decode(paramVal);\n    values[paramName] = param.value(paramVal);\n  }\n  for (/**/; i < nTotal; i++) {\n    paramName = paramNames[i];\n    values[paramName] = this.params[paramName].value(searchParams[paramName]);\n    param = this.params[paramName];\n    paramVal = searchParams[paramName];\n    for (j = 0; j < param.replace.length; j++) {\n      if (param.replace[j].from === paramVal) paramVal = param.replace[j].to;\n    }\n    if (isDefined(paramVal)) paramVal = param.type.decode(paramVal);\n    values[paramName] = param.value(paramVal);\n  }\n\n  return values;\n};\n\n/**\n * @ngdoc function\n * @name ui.router.util.type:UrlMatcher#parameters\n * @methodOf ui.router.util.type:UrlMatcher\n *\n * @description\n * Returns the names of all path and search parameters of this pattern in an unspecified order.\n *\n * @returns {Array.<string>}  An array of parameter names. Must be treated as read-only. If the\n *    pattern has no parameters, an empty array is returned.\n */\nUrlMatcher.prototype.parameters = function (param) {\n  if (!isDefined(param)) return this.$$paramNames;\n  return this.params[param] || null;\n};\n\n/**\n * @ngdoc function\n * @name ui.router.util.type:UrlMatcher#validates\n * @methodOf ui.router.util.type:UrlMatcher\n *\n * @description\n * Checks an object hash of parameters to validate their correctness according to the parameter\n * types of this `UrlMatcher`.\n *\n * @param {Object} params The object hash of parameters to validate.\n * @returns {boolean} Returns `true` if `params` validates, otherwise `false`.\n */\nUrlMatcher.prototype.validates = function (params) {\n  return this.params.$$validates(params);\n};\n\n/**\n * @ngdoc function\n * @name ui.router.util.type:UrlMatcher#format\n * @methodOf ui.router.util.type:UrlMatcher\n *\n * @description\n * Creates a URL that matches this pattern by substituting the specified values\n * for the path and search parameters. Null values for path parameters are\n * treated as empty strings.\n *\n * @example\n * <pre>\n * new UrlMatcher('/user/{id}?q').format({ id:'bob', q:'yes' });\n * // returns '/user/bob?q=yes'\n * </pre>\n *\n * @param {Object} values  the values to substitute for the parameters in this pattern.\n * @returns {string}  the formatted URL (path and optionally search part).\n */\nUrlMatcher.prototype.format = function (values) {\n  values = values || {};\n  var segments = this.segments, params = this.parameters(), paramset = this.params;\n  if (!this.validates(values)) return null;\n\n  var i, search = false, nPath = segments.length - 1, nTotal = params.length, result = segments[0];\n\n  function encodeDashes(str) { // Replace dashes with encoded \"\\-\"\n    return encodeURIComponent(str).replace(/-/g, function(c) { return '%5C%' + c.charCodeAt(0).toString(16).toUpperCase(); });\n  }\n\n  for (i = 0; i < nTotal; i++) {\n    var isPathParam = i < nPath;\n    var name = params[i], param = paramset[name], value = param.value(values[name]);\n    var isDefaultValue = param.isOptional && param.type.equals(param.value(), value);\n    var squash = isDefaultValue ? param.squash : false;\n    var encoded = param.type.encode(value);\n\n    if (isPathParam) {\n      var nextSegment = segments[i + 1];\n      var isFinalPathParam = i + 1 === nPath;\n\n      if (squash === false) {\n        if (encoded != null) {\n          if (isArray(encoded)) {\n            result += map(encoded, encodeDashes).join(\"-\");\n          } else {\n            result += encodeURIComponent(encoded);\n          }\n        }\n        result += nextSegment;\n      } else if (squash === true) {\n        var capture = result.match(/\\/$/) ? /\\/?(.*)/ : /(.*)/;\n        result += nextSegment.match(capture)[1];\n      } else if (isString(squash)) {\n        result += squash + nextSegment;\n      }\n\n      if (isFinalPathParam && param.squash === true && result.slice(-1) === '/') result = result.slice(0, -1);\n    } else {\n      if (encoded == null || (isDefaultValue && squash !== false)) continue;\n      if (!isArray(encoded)) encoded = [ encoded ];\n      if (encoded.length === 0) continue;\n      encoded = map(encoded, encodeURIComponent).join('&' + name + '=');\n      result += (search ? '&' : '?') + (name + '=' + encoded);\n      search = true;\n    }\n  }\n\n  return result;\n};\n\n/**\n * @ngdoc object\n * @name ui.router.util.type:Type\n *\n * @description\n * Implements an interface to define custom parameter types that can be decoded from and encoded to\n * string parameters matched in a URL. Used by {@link ui.router.util.type:UrlMatcher `UrlMatcher`}\n * objects when matching or formatting URLs, or comparing or validating parameter values.\n *\n * See {@link ui.router.util.$urlMatcherFactory#methods_type `$urlMatcherFactory#type()`} for more\n * information on registering custom types.\n *\n * @param {Object} config  A configuration object which contains the custom type definition.  The object's\n *        properties will override the default methods and/or pattern in `Type`'s public interface.\n * @example\n * <pre>\n * {\n *   decode: function(val) { return parseInt(val, 10); },\n *   encode: function(val) { return val && val.toString(); },\n *   equals: function(a, b) { return this.is(a) && a === b; },\n *   is: function(val) { return angular.isNumber(val) isFinite(val) && val % 1 === 0; },\n *   pattern: /\\d+/\n * }\n * </pre>\n *\n * @property {RegExp} pattern The regular expression pattern used to match values of this type when\n *           coming from a substring of a URL.\n *\n * @returns {Object}  Returns a new `Type` object.\n */\nfunction Type(config) {\n  extend(this, config);\n}\n\n/**\n * @ngdoc function\n * @name ui.router.util.type:Type#is\n * @methodOf ui.router.util.type:Type\n *\n * @description\n * Detects whether a value is of a particular type. Accepts a native (decoded) value\n * and determines whether it matches the current `Type` object.\n *\n * @param {*} val  The value to check.\n * @param {string} key  Optional. If the type check is happening in the context of a specific\n *        {@link ui.router.util.type:UrlMatcher `UrlMatcher`} object, this is the name of the\n *        parameter in which `val` is stored. Can be used for meta-programming of `Type` objects.\n * @returns {Boolean}  Returns `true` if the value matches the type, otherwise `false`.\n */\nType.prototype.is = function(val, key) {\n  return true;\n};\n\n/**\n * @ngdoc function\n * @name ui.router.util.type:Type#encode\n * @methodOf ui.router.util.type:Type\n *\n * @description\n * Encodes a custom/native type value to a string that can be embedded in a URL. Note that the\n * return value does *not* need to be URL-safe (i.e. passed through `encodeURIComponent()`), it\n * only needs to be a representation of `val` that has been coerced to a string.\n *\n * @param {*} val  The value to encode.\n * @param {string} key  The name of the parameter in which `val` is stored. Can be used for\n *        meta-programming of `Type` objects.\n * @returns {string}  Returns a string representation of `val` that can be encoded in a URL.\n */\nType.prototype.encode = function(val, key) {\n  return val;\n};\n\n/**\n * @ngdoc function\n * @name ui.router.util.type:Type#decode\n * @methodOf ui.router.util.type:Type\n *\n * @description\n * Converts a parameter value (from URL string or transition param) to a custom/native value.\n *\n * @param {string} val  The URL parameter value to decode.\n * @param {string} key  The name of the parameter in which `val` is stored. Can be used for\n *        meta-programming of `Type` objects.\n * @returns {*}  Returns a custom representation of the URL parameter value.\n */\nType.prototype.decode = function(val, key) {\n  return val;\n};\n\n/**\n * @ngdoc function\n * @name ui.router.util.type:Type#equals\n * @methodOf ui.router.util.type:Type\n *\n * @description\n * Determines whether two decoded values are equivalent.\n *\n * @param {*} a  A value to compare against.\n * @param {*} b  A value to compare against.\n * @returns {Boolean}  Returns `true` if the values are equivalent/equal, otherwise `false`.\n */\nType.prototype.equals = function(a, b) {\n  return a == b;\n};\n\nType.prototype.$subPattern = function() {\n  var sub = this.pattern.toString();\n  return sub.substr(1, sub.length - 2);\n};\n\nType.prototype.pattern = /.*/;\n\nType.prototype.toString = function() { return \"{Type:\" + this.name + \"}\"; };\n\n/** Given an encoded string, or a decoded object, returns a decoded object */\nType.prototype.$normalize = function(val) {\n  return this.is(val) ? val : this.decode(val);\n};\n\n/*\n * Wraps an existing custom Type as an array of Type, depending on 'mode'.\n * e.g.:\n * - urlmatcher pattern \"/path?{queryParam[]:int}\"\n * - url: \"/path?queryParam=1&queryParam=2\n * - $stateParams.queryParam will be [1, 2]\n * if `mode` is \"auto\", then\n * - url: \"/path?queryParam=1 will create $stateParams.queryParam: 1\n * - url: \"/path?queryParam=1&queryParam=2 will create $stateParams.queryParam: [1, 2]\n */\nType.prototype.$asArray = function(mode, isSearch) {\n  if (!mode) return this;\n  if (mode === \"auto\" && !isSearch) throw new Error(\"'auto' array mode is for query parameters only\");\n\n  function ArrayType(type, mode) {\n    function bindTo(type, callbackName) {\n      return function() {\n        return type[callbackName].apply(type, arguments);\n      };\n    }\n\n    // Wrap non-array value as array\n    function arrayWrap(val) { return isArray(val) ? val : (isDefined(val) ? [ val ] : []); }\n    // Unwrap array value for \"auto\" mode. Return undefined for empty array.\n    function arrayUnwrap(val) {\n      switch(val.length) {\n        case 0: return undefined;\n        case 1: return mode === \"auto\" ? val[0] : val;\n        default: return val;\n      }\n    }\n    function falsey(val) { return !val; }\n\n    // Wraps type (.is/.encode/.decode) functions to operate on each value of an array\n    function arrayHandler(callback, allTruthyMode) {\n      return function handleArray(val) {\n        if (isArray(val) && val.length === 0) return val;\n        val = arrayWrap(val);\n        var result = map(val, callback);\n        if (allTruthyMode === true)\n          return filter(result, falsey).length === 0;\n        return arrayUnwrap(result);\n      };\n    }\n\n    // Wraps type (.equals) functions to operate on each value of an array\n    function arrayEqualsHandler(callback) {\n      return function handleArray(val1, val2) {\n        var left = arrayWrap(val1), right = arrayWrap(val2);\n        if (left.length !== right.length) return false;\n        for (var i = 0; i < left.length; i++) {\n          if (!callback(left[i], right[i])) return false;\n        }\n        return true;\n      };\n    }\n\n    this.encode = arrayHandler(bindTo(type, 'encode'));\n    this.decode = arrayHandler(bindTo(type, 'decode'));\n    this.is     = arrayHandler(bindTo(type, 'is'), true);\n    this.equals = arrayEqualsHandler(bindTo(type, 'equals'));\n    this.pattern = type.pattern;\n    this.$normalize = arrayHandler(bindTo(type, '$normalize'));\n    this.name = type.name;\n    this.$arrayMode = mode;\n  }\n\n  return new ArrayType(this, mode);\n};\n\n\n\n/**\n * @ngdoc object\n * @name ui.router.util.$urlMatcherFactory\n *\n * @description\n * Factory for {@link ui.router.util.type:UrlMatcher `UrlMatcher`} instances. The factory\n * is also available to providers under the name `$urlMatcherFactoryProvider`.\n */\nfunction $UrlMatcherFactory() {\n  $$UMFP = this;\n\n  var isCaseInsensitive = false, isStrictMode = true, defaultSquashPolicy = false;\n\n  // Use tildes to pre-encode slashes.\n  // If the slashes are simply URLEncoded, the browser can choose to pre-decode them,\n  // and bidirectional encoding/decoding fails.\n  // Tilde was chosen because it's not a RFC 3986 section 2.2 Reserved Character\n  function valToString(val) { return val != null ? val.toString().replace(/~/g, \"~~\").replace(/\\//g, \"~2F\") : val; }\n  function valFromString(val) { return val != null ? val.toString().replace(/~2F/g, \"/\").replace(/~~/g, \"~\") : val; }\n\n  var $types = {}, enqueue = true, typeQueue = [], injector, defaultTypes = {\n    \"string\": {\n      encode: valToString,\n      decode: valFromString,\n      // TODO: in 1.0, make string .is() return false if value is undefined/null by default.\n      // In 0.2.x, string params are optional by default for backwards compat\n      is: function(val) { return val == null || !isDefined(val) || typeof val === \"string\"; },\n      pattern: /[^/]*/\n    },\n    \"int\": {\n      encode: valToString,\n      decode: function(val) { return parseInt(val, 10); },\n      is: function(val) { return isDefined(val) && this.decode(val.toString()) === val; },\n      pattern: /\\d+/\n    },\n    \"bool\": {\n      encode: function(val) { return val ? 1 : 0; },\n      decode: function(val) { return parseInt(val, 10) !== 0; },\n      is: function(val) { return val === true || val === false; },\n      pattern: /0|1/\n    },\n    \"date\": {\n      encode: function (val) {\n        if (!this.is(val))\n          return undefined;\n        return [ val.getFullYear(),\n          ('0' + (val.getMonth() + 1)).slice(-2),\n          ('0' + val.getDate()).slice(-2)\n        ].join(\"-\");\n      },\n      decode: function (val) {\n        if (this.is(val)) return val;\n        var match = this.capture.exec(val);\n        return match ? new Date(match[1], match[2] - 1, match[3]) : undefined;\n      },\n      is: function(val) { return val instanceof Date && !isNaN(val.valueOf()); },\n      equals: function (a, b) { return this.is(a) && this.is(b) && a.toISOString() === b.toISOString(); },\n      pattern: /[0-9]{4}-(?:0[1-9]|1[0-2])-(?:0[1-9]|[1-2][0-9]|3[0-1])/,\n      capture: /([0-9]{4})-(0[1-9]|1[0-2])-(0[1-9]|[1-2][0-9]|3[0-1])/\n    },\n    \"json\": {\n      encode: angular.toJson,\n      decode: angular.fromJson,\n      is: angular.isObject,\n      equals: angular.equals,\n      pattern: /[^/]*/\n    },\n    \"any\": { // does not encode/decode\n      encode: angular.identity,\n      decode: angular.identity,\n      equals: angular.equals,\n      pattern: /.*/\n    }\n  };\n\n  function getDefaultConfig() {\n    return {\n      strict: isStrictMode,\n      caseInsensitive: isCaseInsensitive\n    };\n  }\n\n  function isInjectable(value) {\n    return (isFunction(value) || (isArray(value) && isFunction(value[value.length - 1])));\n  }\n\n  /**\n   * [Internal] Get the default value of a parameter, which may be an injectable function.\n   */\n  $UrlMatcherFactory.$$getDefaultValue = function(config) {\n    if (!isInjectable(config.value)) return config.value;\n    if (!injector) throw new Error(\"Injectable functions cannot be called at configuration time\");\n    return injector.invoke(config.value);\n  };\n\n  /**\n   * @ngdoc function\n   * @name ui.router.util.$urlMatcherFactory#caseInsensitive\n   * @methodOf ui.router.util.$urlMatcherFactory\n   *\n   * @description\n   * Defines whether URL matching should be case sensitive (the default behavior), or not.\n   *\n   * @param {boolean} value `false` to match URL in a case sensitive manner; otherwise `true`;\n   * @returns {boolean} the current value of caseInsensitive\n   */\n  this.caseInsensitive = function(value) {\n    if (isDefined(value))\n      isCaseInsensitive = value;\n    return isCaseInsensitive;\n  };\n\n  /**\n   * @ngdoc function\n   * @name ui.router.util.$urlMatcherFactory#strictMode\n   * @methodOf ui.router.util.$urlMatcherFactory\n   *\n   * @description\n   * Defines whether URLs should match trailing slashes, or not (the default behavior).\n   *\n   * @param {boolean=} value `false` to match trailing slashes in URLs, otherwise `true`.\n   * @returns {boolean} the current value of strictMode\n   */\n  this.strictMode = function(value) {\n    if (isDefined(value))\n      isStrictMode = value;\n    return isStrictMode;\n  };\n\n  /**\n   * @ngdoc function\n   * @name ui.router.util.$urlMatcherFactory#defaultSquashPolicy\n   * @methodOf ui.router.util.$urlMatcherFactory\n   *\n   * @description\n   * Sets the default behavior when generating or matching URLs with default parameter values.\n   *\n   * @param {string} value A string that defines the default parameter URL squashing behavior.\n   *    `nosquash`: When generating an href with a default parameter value, do not squash the parameter value from the URL\n   *    `slash`: When generating an href with a default parameter value, squash (remove) the parameter value, and, if the\n   *             parameter is surrounded by slashes, squash (remove) one slash from the URL\n   *    any other string, e.g. \"~\": When generating an href with a default parameter value, squash (remove)\n   *             the parameter value from the URL and replace it with this string.\n   */\n  this.defaultSquashPolicy = function(value) {\n    if (!isDefined(value)) return defaultSquashPolicy;\n    if (value !== true && value !== false && !isString(value))\n      throw new Error(\"Invalid squash policy: \" + value + \". Valid policies: false, true, arbitrary-string\");\n    defaultSquashPolicy = value;\n    return value;\n  };\n\n  /**\n   * @ngdoc function\n   * @name ui.router.util.$urlMatcherFactory#compile\n   * @methodOf ui.router.util.$urlMatcherFactory\n   *\n   * @description\n   * Creates a {@link ui.router.util.type:UrlMatcher `UrlMatcher`} for the specified pattern.\n   *\n   * @param {string} pattern  The URL pattern.\n   * @param {Object} config  The config object hash.\n   * @returns {UrlMatcher}  The UrlMatcher.\n   */\n  this.compile = function (pattern, config) {\n    return new UrlMatcher(pattern, extend(getDefaultConfig(), config));\n  };\n\n  /**\n   * @ngdoc function\n   * @name ui.router.util.$urlMatcherFactory#isMatcher\n   * @methodOf ui.router.util.$urlMatcherFactory\n   *\n   * @description\n   * Returns true if the specified object is a `UrlMatcher`, or false otherwise.\n   *\n   * @param {Object} object  The object to perform the type check against.\n   * @returns {Boolean}  Returns `true` if the object matches the `UrlMatcher` interface, by\n   *          implementing all the same methods.\n   */\n  this.isMatcher = function (o) {\n    if (!isObject(o)) return false;\n    var result = true;\n\n    forEach(UrlMatcher.prototype, function(val, name) {\n      if (isFunction(val)) {\n        result = result && (isDefined(o[name]) && isFunction(o[name]));\n      }\n    });\n    return result;\n  };\n\n  /**\n   * @ngdoc function\n   * @name ui.router.util.$urlMatcherFactory#type\n   * @methodOf ui.router.util.$urlMatcherFactory\n   *\n   * @description\n   * Registers a custom {@link ui.router.util.type:Type `Type`} object that can be used to\n   * generate URLs with typed parameters.\n   *\n   * @param {string} name  The type name.\n   * @param {Object|Function} definition   The type definition. See\n   *        {@link ui.router.util.type:Type `Type`} for information on the values accepted.\n   * @param {Object|Function} definitionFn (optional) A function that is injected before the app\n   *        runtime starts.  The result of this function is merged into the existing `definition`.\n   *        See {@link ui.router.util.type:Type `Type`} for information on the values accepted.\n   *\n   * @returns {Object}  Returns `$urlMatcherFactoryProvider`.\n   *\n   * @example\n   * This is a simple example of a custom type that encodes and decodes items from an\n   * array, using the array index as the URL-encoded value:\n   *\n   * <pre>\n   * var list = ['John', 'Paul', 'George', 'Ringo'];\n   *\n   * $urlMatcherFactoryProvider.type('listItem', {\n   *   encode: function(item) {\n   *     // Represent the list item in the URL using its corresponding index\n   *     return list.indexOf(item);\n   *   },\n   *   decode: function(item) {\n   *     // Look up the list item by index\n   *     return list[parseInt(item, 10)];\n   *   },\n   *   is: function(item) {\n   *     // Ensure the item is valid by checking to see that it appears\n   *     // in the list\n   *     return list.indexOf(item) > -1;\n   *   }\n   * });\n   *\n   * $stateProvider.state('list', {\n   *   url: \"/list/{item:listItem}\",\n   *   controller: function($scope, $stateParams) {\n   *     console.log($stateParams.item);\n   *   }\n   * });\n   *\n   * // ...\n   *\n   * // Changes URL to '/list/3', logs \"Ringo\" to the console\n   * $state.go('list', { item: \"Ringo\" });\n   * </pre>\n   *\n   * This is a more complex example of a type that relies on dependency injection to\n   * interact with services, and uses the parameter name from the URL to infer how to\n   * handle encoding and decoding parameter values:\n   *\n   * <pre>\n   * // Defines a custom type that gets a value from a service,\n   * // where each service gets different types of values from\n   * // a backend API:\n   * $urlMatcherFactoryProvider.type('dbObject', {}, function(Users, Posts) {\n   *\n   *   // Matches up services to URL parameter names\n   *   var services = {\n   *     user: Users,\n   *     post: Posts\n   *   };\n   *\n   *   return {\n   *     encode: function(object) {\n   *       // Represent the object in the URL using its unique ID\n   *       return object.id;\n   *     },\n   *     decode: function(value, key) {\n   *       // Look up the object by ID, using the parameter\n   *       // name (key) to call the correct service\n   *       return services[key].findById(value);\n   *     },\n   *     is: function(object, key) {\n   *       // Check that object is a valid dbObject\n   *       return angular.isObject(object) && object.id && services[key];\n   *     }\n   *     equals: function(a, b) {\n   *       // Check the equality of decoded objects by comparing\n   *       // their unique IDs\n   *       return a.id === b.id;\n   *     }\n   *   };\n   * });\n   *\n   * // In a config() block, you can then attach URLs with\n   * // type-annotated parameters:\n   * $stateProvider.state('users', {\n   *   url: \"/users\",\n   *   // ...\n   * }).state('users.item', {\n   *   url: \"/{user:dbObject}\",\n   *   controller: function($scope, $stateParams) {\n   *     // $stateParams.user will now be an object returned from\n   *     // the Users service\n   *   },\n   *   // ...\n   * });\n   * </pre>\n   */\n  this.type = function (name, definition, definitionFn) {\n    if (!isDefined(definition)) return $types[name];\n    if ($types.hasOwnProperty(name)) throw new Error(\"A type named '\" + name + \"' has already been defined.\");\n\n    $types[name] = new Type(extend({ name: name }, definition));\n    if (definitionFn) {\n      typeQueue.push({ name: name, def: definitionFn });\n      if (!enqueue) flushTypeQueue();\n    }\n    return this;\n  };\n\n  // `flushTypeQueue()` waits until `$urlMatcherFactory` is injected before invoking the queued `definitionFn`s\n  function flushTypeQueue() {\n    while(typeQueue.length) {\n      var type = typeQueue.shift();\n      if (type.pattern) throw new Error(\"You cannot override a type's .pattern at runtime.\");\n      angular.extend($types[type.name], injector.invoke(type.def));\n    }\n  }\n\n  // Register default types. Store them in the prototype of $types.\n  forEach(defaultTypes, function(type, name) { $types[name] = new Type(extend({name: name}, type)); });\n  $types = inherit($types, {});\n\n  /* No need to document $get, since it returns this */\n  this.$get = ['$injector', function ($injector) {\n    injector = $injector;\n    enqueue = false;\n    flushTypeQueue();\n\n    forEach(defaultTypes, function(type, name) {\n      if (!$types[name]) $types[name] = new Type(type);\n    });\n    return this;\n  }];\n\n  this.Param = function Param(id, type, config, location) {\n    var self = this;\n    config = unwrapShorthand(config);\n    type = getType(config, type, location);\n    var arrayMode = getArrayMode();\n    type = arrayMode ? type.$asArray(arrayMode, location === \"search\") : type;\n    if (type.name === \"string\" && !arrayMode && location === \"path\" && config.value === undefined)\n      config.value = \"\"; // for 0.2.x; in 0.3.0+ do not automatically default to \"\"\n    var isOptional = config.value !== undefined;\n    var squash = getSquashPolicy(config, isOptional);\n    var replace = getReplace(config, arrayMode, isOptional, squash);\n\n    function unwrapShorthand(config) {\n      var keys = isObject(config) ? objectKeys(config) : [];\n      var isShorthand = indexOf(keys, \"value\") === -1 && indexOf(keys, \"type\") === -1 &&\n                        indexOf(keys, \"squash\") === -1 && indexOf(keys, \"array\") === -1;\n      if (isShorthand) config = { value: config };\n      config.$$fn = isInjectable(config.value) ? config.value : function () { return config.value; };\n      return config;\n    }\n\n    function getType(config, urlType, location) {\n      if (config.type && urlType) throw new Error(\"Param '\"+id+\"' has two type configurations.\");\n      if (urlType) return urlType;\n      if (!config.type) return (location === \"config\" ? $types.any : $types.string);\n\n      if (angular.isString(config.type))\n        return $types[config.type];\n      if (config.type instanceof Type)\n        return config.type;\n      return new Type(config.type);\n    }\n\n    // array config: param name (param[]) overrides default settings.  explicit config overrides param name.\n    function getArrayMode() {\n      var arrayDefaults = { array: (location === \"search\" ? \"auto\" : false) };\n      var arrayParamNomenclature = id.match(/\\[\\]$/) ? { array: true } : {};\n      return extend(arrayDefaults, arrayParamNomenclature, config).array;\n    }\n\n    /**\n     * returns false, true, or the squash value to indicate the \"default parameter url squash policy\".\n     */\n    function getSquashPolicy(config, isOptional) {\n      var squash = config.squash;\n      if (!isOptional || squash === false) return false;\n      if (!isDefined(squash) || squash == null) return defaultSquashPolicy;\n      if (squash === true || isString(squash)) return squash;\n      throw new Error(\"Invalid squash policy: '\" + squash + \"'. Valid policies: false, true, or arbitrary string\");\n    }\n\n    function getReplace(config, arrayMode, isOptional, squash) {\n      var replace, configuredKeys, defaultPolicy = [\n        { from: \"\",   to: (isOptional || arrayMode ? undefined : \"\") },\n        { from: null, to: (isOptional || arrayMode ? undefined : \"\") }\n      ];\n      replace = isArray(config.replace) ? config.replace : [];\n      if (isString(squash))\n        replace.push({ from: squash, to: undefined });\n      configuredKeys = map(replace, function(item) { return item.from; } );\n      return filter(defaultPolicy, function(item) { return indexOf(configuredKeys, item.from) === -1; }).concat(replace);\n    }\n\n    /**\n     * [Internal] Get the default value of a parameter, which may be an injectable function.\n     */\n    function $$getDefaultValue() {\n      if (!injector) throw new Error(\"Injectable functions cannot be called at configuration time\");\n      var defaultValue = injector.invoke(config.$$fn);\n      if (defaultValue !== null && defaultValue !== undefined && !self.type.is(defaultValue))\n        throw new Error(\"Default value (\" + defaultValue + \") for parameter '\" + self.id + \"' is not an instance of Type (\" + self.type.name + \")\");\n      return defaultValue;\n    }\n\n    /**\n     * [Internal] Gets the decoded representation of a value if the value is defined, otherwise, returns the\n     * default value, which may be the result of an injectable function.\n     */\n    function $value(value) {\n      function hasReplaceVal(val) { return function(obj) { return obj.from === val; }; }\n      function $replace(value) {\n        var replacement = map(filter(self.replace, hasReplaceVal(value)), function(obj) { return obj.to; });\n        return replacement.length ? replacement[0] : value;\n      }\n      value = $replace(value);\n      return !isDefined(value) ? $$getDefaultValue() : self.type.$normalize(value);\n    }\n\n    function toString() { return \"{Param:\" + id + \" \" + type + \" squash: '\" + squash + \"' optional: \" + isOptional + \"}\"; }\n\n    extend(this, {\n      id: id,\n      type: type,\n      location: location,\n      array: arrayMode,\n      squash: squash,\n      replace: replace,\n      isOptional: isOptional,\n      value: $value,\n      dynamic: undefined,\n      config: config,\n      toString: toString\n    });\n  };\n\n  function ParamSet(params) {\n    extend(this, params || {});\n  }\n\n  ParamSet.prototype = {\n    $$new: function() {\n      return inherit(this, extend(new ParamSet(), { $$parent: this}));\n    },\n    $$keys: function () {\n      var keys = [], chain = [], parent = this,\n        ignore = objectKeys(ParamSet.prototype);\n      while (parent) { chain.push(parent); parent = parent.$$parent; }\n      chain.reverse();\n      forEach(chain, function(paramset) {\n        forEach(objectKeys(paramset), function(key) {\n            if (indexOf(keys, key) === -1 && indexOf(ignore, key) === -1) keys.push(key);\n        });\n      });\n      return keys;\n    },\n    $$values: function(paramValues) {\n      var values = {}, self = this;\n      forEach(self.$$keys(), function(key) {\n        values[key] = self[key].value(paramValues && paramValues[key]);\n      });\n      return values;\n    },\n    $$equals: function(paramValues1, paramValues2) {\n      var equal = true, self = this;\n      forEach(self.$$keys(), function(key) {\n        var left = paramValues1 && paramValues1[key], right = paramValues2 && paramValues2[key];\n        if (!self[key].type.equals(left, right)) equal = false;\n      });\n      return equal;\n    },\n    $$validates: function $$validate(paramValues) {\n      var keys = this.$$keys(), i, param, rawVal, normalized, encoded;\n      for (i = 0; i < keys.length; i++) {\n        param = this[keys[i]];\n        rawVal = paramValues[keys[i]];\n        if ((rawVal === undefined || rawVal === null) && param.isOptional)\n          break; // There was no parameter value, but the param is optional\n        normalized = param.type.$normalize(rawVal);\n        if (!param.type.is(normalized))\n          return false; // The value was not of the correct Type, and could not be decoded to the correct Type\n        encoded = param.type.encode(normalized);\n        if (angular.isString(encoded) && !param.type.pattern.exec(encoded))\n          return false; // The value was of the correct type, but when encoded, did not match the Type's regexp\n      }\n      return true;\n    },\n    $$parent: undefined\n  };\n\n  this.ParamSet = ParamSet;\n}\n\n// Register as a provider so it's available to other providers\nangular.module('ui.router.util').provider('$urlMatcherFactory', $UrlMatcherFactory);\nangular.module('ui.router.util').run(['$urlMatcherFactory', function($urlMatcherFactory) { }]);\n\n/**\n * @ngdoc object\n * @name ui.router.router.$urlRouterProvider\n *\n * @requires ui.router.util.$urlMatcherFactoryProvider\n * @requires $locationProvider\n *\n * @description\n * `$urlRouterProvider` has the responsibility of watching `$location`. \n * When `$location` changes it runs through a list of rules one by one until a \n * match is found. `$urlRouterProvider` is used behind the scenes anytime you specify \n * a url in a state configuration. All urls are compiled into a UrlMatcher object.\n *\n * There are several methods on `$urlRouterProvider` that make it useful to use directly\n * in your module config.\n */\n$UrlRouterProvider.$inject = ['$locationProvider', '$urlMatcherFactoryProvider'];\nfunction $UrlRouterProvider(   $locationProvider,   $urlMatcherFactory) {\n  var rules = [], otherwise = null, interceptDeferred = false, listener;\n\n  // Returns a string that is a prefix of all strings matching the RegExp\n  function regExpPrefix(re) {\n    var prefix = /^\\^((?:\\\\[^a-zA-Z0-9]|[^\\\\\\[\\]\\^$*+?.()|{}]+)*)/.exec(re.source);\n    return (prefix != null) ? prefix[1].replace(/\\\\(.)/g, \"$1\") : '';\n  }\n\n  // Interpolates matched values into a String.replace()-style pattern\n  function interpolate(pattern, match) {\n    return pattern.replace(/\\$(\\$|\\d{1,2})/, function (m, what) {\n      return match[what === '$' ? 0 : Number(what)];\n    });\n  }\n\n  /**\n   * @ngdoc function\n   * @name ui.router.router.$urlRouterProvider#rule\n   * @methodOf ui.router.router.$urlRouterProvider\n   *\n   * @description\n   * Defines rules that are used by `$urlRouterProvider` to find matches for\n   * specific URLs.\n   *\n   * @example\n   * <pre>\n   * var app = angular.module('app', ['ui.router.router']);\n   *\n   * app.config(function ($urlRouterProvider) {\n   *   // Here's an example of how you might allow case insensitive urls\n   *   $urlRouterProvider.rule(function ($injector, $location) {\n   *     var path = $location.path(),\n   *         normalized = path.toLowerCase();\n   *\n   *     if (path !== normalized) {\n   *       return normalized;\n   *     }\n   *   });\n   * });\n   * </pre>\n   *\n   * @param {function} rule Handler function that takes `$injector` and `$location`\n   * services as arguments. You can use them to return a valid path as a string.\n   *\n   * @return {object} `$urlRouterProvider` - `$urlRouterProvider` instance\n   */\n  this.rule = function (rule) {\n    if (!isFunction(rule)) throw new Error(\"'rule' must be a function\");\n    rules.push(rule);\n    return this;\n  };\n\n  /**\n   * @ngdoc object\n   * @name ui.router.router.$urlRouterProvider#otherwise\n   * @methodOf ui.router.router.$urlRouterProvider\n   *\n   * @description\n   * Defines a path that is used when an invalid route is requested.\n   *\n   * @example\n   * <pre>\n   * var app = angular.module('app', ['ui.router.router']);\n   *\n   * app.config(function ($urlRouterProvider) {\n   *   // if the path doesn't match any of the urls you configured\n   *   // otherwise will take care of routing the user to the\n   *   // specified url\n   *   $urlRouterProvider.otherwise('/index');\n   *\n   *   // Example of using function rule as param\n   *   $urlRouterProvider.otherwise(function ($injector, $location) {\n   *     return '/a/valid/url';\n   *   });\n   * });\n   * </pre>\n   *\n   * @param {string|function} rule The url path you want to redirect to or a function \n   * rule that returns the url path. The function version is passed two params: \n   * `$injector` and `$location` services, and must return a url string.\n   *\n   * @return {object} `$urlRouterProvider` - `$urlRouterProvider` instance\n   */\n  this.otherwise = function (rule) {\n    if (isString(rule)) {\n      var redirect = rule;\n      rule = function () { return redirect; };\n    }\n    else if (!isFunction(rule)) throw new Error(\"'rule' must be a function\");\n    otherwise = rule;\n    return this;\n  };\n\n\n  function handleIfMatch($injector, handler, match) {\n    if (!match) return false;\n    var result = $injector.invoke(handler, handler, { $match: match });\n    return isDefined(result) ? result : true;\n  }\n\n  /**\n   * @ngdoc function\n   * @name ui.router.router.$urlRouterProvider#when\n   * @methodOf ui.router.router.$urlRouterProvider\n   *\n   * @description\n   * Registers a handler for a given url matching. \n   * \n   * If the handler is a string, it is\n   * treated as a redirect, and is interpolated according to the syntax of match\n   * (i.e. like `String.replace()` for `RegExp`, or like a `UrlMatcher` pattern otherwise).\n   *\n   * If the handler is a function, it is injectable. It gets invoked if `$location`\n   * matches. You have the option of inject the match object as `$match`.\n   *\n   * The handler can return\n   *\n   * - **falsy** to indicate that the rule didn't match after all, then `$urlRouter`\n   *   will continue trying to find another one that matches.\n   * - **string** which is treated as a redirect and passed to `$location.url()`\n   * - **void** or any **truthy** value tells `$urlRouter` that the url was handled.\n   *\n   * @example\n   * <pre>\n   * var app = angular.module('app', ['ui.router.router']);\n   *\n   * app.config(function ($urlRouterProvider) {\n   *   $urlRouterProvider.when($state.url, function ($match, $stateParams) {\n   *     if ($state.$current.navigable !== state ||\n   *         !equalForKeys($match, $stateParams) {\n   *      $state.transitionTo(state, $match, false);\n   *     }\n   *   });\n   * });\n   * </pre>\n   *\n   * @param {string|object} what The incoming path that you want to redirect.\n   * @param {string|function} handler The path you want to redirect your user to.\n   */\n  this.when = function (what, handler) {\n    var redirect, handlerIsString = isString(handler);\n    if (isString(what)) what = $urlMatcherFactory.compile(what);\n\n    if (!handlerIsString && !isFunction(handler) && !isArray(handler))\n      throw new Error(\"invalid 'handler' in when()\");\n\n    var strategies = {\n      matcher: function (what, handler) {\n        if (handlerIsString) {\n          redirect = $urlMatcherFactory.compile(handler);\n          handler = ['$match', function ($match) { return redirect.format($match); }];\n        }\n        return extend(function ($injector, $location) {\n          return handleIfMatch($injector, handler, what.exec($location.path(), $location.search()));\n        }, {\n          prefix: isString(what.prefix) ? what.prefix : ''\n        });\n      },\n      regex: function (what, handler) {\n        if (what.global || what.sticky) throw new Error(\"when() RegExp must not be global or sticky\");\n\n        if (handlerIsString) {\n          redirect = handler;\n          handler = ['$match', function ($match) { return interpolate(redirect, $match); }];\n        }\n        return extend(function ($injector, $location) {\n          return handleIfMatch($injector, handler, what.exec($location.path()));\n        }, {\n          prefix: regExpPrefix(what)\n        });\n      }\n    };\n\n    var check = { matcher: $urlMatcherFactory.isMatcher(what), regex: what instanceof RegExp };\n\n    for (var n in check) {\n      if (check[n]) return this.rule(strategies[n](what, handler));\n    }\n\n    throw new Error(\"invalid 'what' in when()\");\n  };\n\n  /**\n   * @ngdoc function\n   * @name ui.router.router.$urlRouterProvider#deferIntercept\n   * @methodOf ui.router.router.$urlRouterProvider\n   *\n   * @description\n   * Disables (or enables) deferring location change interception.\n   *\n   * If you wish to customize the behavior of syncing the URL (for example, if you wish to\n   * defer a transition but maintain the current URL), call this method at configuration time.\n   * Then, at run time, call `$urlRouter.listen()` after you have configured your own\n   * `$locationChangeSuccess` event handler.\n   *\n   * @example\n   * <pre>\n   * var app = angular.module('app', ['ui.router.router']);\n   *\n   * app.config(function ($urlRouterProvider) {\n   *\n   *   // Prevent $urlRouter from automatically intercepting URL changes;\n   *   // this allows you to configure custom behavior in between\n   *   // location changes and route synchronization:\n   *   $urlRouterProvider.deferIntercept();\n   *\n   * }).run(function ($rootScope, $urlRouter, UserService) {\n   *\n   *   $rootScope.$on('$locationChangeSuccess', function(e) {\n   *     // UserService is an example service for managing user state\n   *     if (UserService.isLoggedIn()) return;\n   *\n   *     // Prevent $urlRouter's default handler from firing\n   *     e.preventDefault();\n   *\n   *     UserService.handleLogin().then(function() {\n   *       // Once the user has logged in, sync the current URL\n   *       // to the router:\n   *       $urlRouter.sync();\n   *     });\n   *   });\n   *\n   *   // Configures $urlRouter's listener *after* your custom listener\n   *   $urlRouter.listen();\n   * });\n   * </pre>\n   *\n   * @param {boolean} defer Indicates whether to defer location change interception. Passing\n            no parameter is equivalent to `true`.\n   */\n  this.deferIntercept = function (defer) {\n    if (defer === undefined) defer = true;\n    interceptDeferred = defer;\n  };\n\n  /**\n   * @ngdoc object\n   * @name ui.router.router.$urlRouter\n   *\n   * @requires $location\n   * @requires $rootScope\n   * @requires $injector\n   * @requires $browser\n   *\n   * @description\n   *\n   */\n  this.$get = $get;\n  $get.$inject = ['$location', '$rootScope', '$injector', '$browser', '$sniffer'];\n  function $get(   $location,   $rootScope,   $injector,   $browser,   $sniffer) {\n\n    var baseHref = $browser.baseHref(), location = $location.url(), lastPushedUrl;\n\n    function appendBasePath(url, isHtml5, absolute) {\n      if (baseHref === '/') return url;\n      if (isHtml5) return baseHref.slice(0, -1) + url;\n      if (absolute) return baseHref.slice(1) + url;\n      return url;\n    }\n\n    // TODO: Optimize groups of rules with non-empty prefix into some sort of decision tree\n    function update(evt) {\n      if (evt && evt.defaultPrevented) return;\n      var ignoreUpdate = lastPushedUrl && $location.url() === lastPushedUrl;\n      lastPushedUrl = undefined;\n      // TODO: Re-implement this in 1.0 for https://github.com/angular-ui/ui-router/issues/1573\n      //if (ignoreUpdate) return true;\n\n      function check(rule) {\n        var handled = rule($injector, $location);\n\n        if (!handled) return false;\n        if (isString(handled)) $location.replace().url(handled);\n        return true;\n      }\n      var n = rules.length, i;\n\n      for (i = 0; i < n; i++) {\n        if (check(rules[i])) return;\n      }\n      // always check otherwise last to allow dynamic updates to the set of rules\n      if (otherwise) check(otherwise);\n    }\n\n    function listen() {\n      listener = listener || $rootScope.$on('$locationChangeSuccess', update);\n      return listener;\n    }\n\n    if (!interceptDeferred) listen();\n\n    return {\n      /**\n       * @ngdoc function\n       * @name ui.router.router.$urlRouter#sync\n       * @methodOf ui.router.router.$urlRouter\n       *\n       * @description\n       * Triggers an update; the same update that happens when the address bar url changes, aka `$locationChangeSuccess`.\n       * This method is useful when you need to use `preventDefault()` on the `$locationChangeSuccess` event,\n       * perform some custom logic (route protection, auth, config, redirection, etc) and then finally proceed\n       * with the transition by calling `$urlRouter.sync()`.\n       *\n       * @example\n       * <pre>\n       * angular.module('app', ['ui.router'])\n       *   .run(function($rootScope, $urlRouter) {\n       *     $rootScope.$on('$locationChangeSuccess', function(evt) {\n       *       // Halt state change from even starting\n       *       evt.preventDefault();\n       *       // Perform custom logic\n       *       var meetsRequirement = ...\n       *       // Continue with the update and state transition if logic allows\n       *       if (meetsRequirement) $urlRouter.sync();\n       *     });\n       * });\n       * </pre>\n       */\n      sync: function() {\n        update();\n      },\n\n      listen: function() {\n        return listen();\n      },\n\n      update: function(read) {\n        if (read) {\n          location = $location.url();\n          return;\n        }\n        if ($location.url() === location) return;\n\n        $location.url(location);\n        $location.replace();\n      },\n\n      push: function(urlMatcher, params, options) {\n         var url = urlMatcher.format(params || {});\n\n        // Handle the special hash param, if needed\n        if (url !== null && params && params['#']) {\n            url += '#' + params['#'];\n        }\n\n        $location.url(url);\n        lastPushedUrl = options && options.$$avoidResync ? $location.url() : undefined;\n        if (options && options.replace) $location.replace();\n      },\n\n      /**\n       * @ngdoc function\n       * @name ui.router.router.$urlRouter#href\n       * @methodOf ui.router.router.$urlRouter\n       *\n       * @description\n       * A URL generation method that returns the compiled URL for a given\n       * {@link ui.router.util.type:UrlMatcher `UrlMatcher`}, populated with the provided parameters.\n       *\n       * @example\n       * <pre>\n       * $bob = $urlRouter.href(new UrlMatcher(\"/about/:person\"), {\n       *   person: \"bob\"\n       * });\n       * // $bob == \"/about/bob\";\n       * </pre>\n       *\n       * @param {UrlMatcher} urlMatcher The `UrlMatcher` object which is used as the template of the URL to generate.\n       * @param {object=} params An object of parameter values to fill the matcher's required parameters.\n       * @param {object=} options Options object. The options are:\n       *\n       * - **`absolute`** - {boolean=false},  If true will generate an absolute url, e.g. \"http://www.example.com/fullurl\".\n       *\n       * @returns {string} Returns the fully compiled URL, or `null` if `params` fail validation against `urlMatcher`\n       */\n      href: function(urlMatcher, params, options) {\n        if (!urlMatcher.validates(params)) return null;\n\n        var isHtml5 = $locationProvider.html5Mode();\n        if (angular.isObject(isHtml5)) {\n          isHtml5 = isHtml5.enabled;\n        }\n\n        isHtml5 = isHtml5 && $sniffer.history;\n        \n        var url = urlMatcher.format(params);\n        options = options || {};\n\n        if (!isHtml5 && url !== null) {\n          url = \"#\" + $locationProvider.hashPrefix() + url;\n        }\n\n        // Handle special hash param, if needed\n        if (url !== null && params && params['#']) {\n          url += '#' + params['#'];\n        }\n\n        url = appendBasePath(url, isHtml5, options.absolute);\n\n        if (!options.absolute || !url) {\n          return url;\n        }\n\n        var slash = (!isHtml5 && url ? '/' : ''), port = $location.port();\n        port = (port === 80 || port === 443 ? '' : ':' + port);\n\n        return [$location.protocol(), '://', $location.host(), port, slash, url].join('');\n      }\n    };\n  }\n}\n\nangular.module('ui.router.router').provider('$urlRouter', $UrlRouterProvider);\n\n/**\n * @ngdoc object\n * @name ui.router.state.$stateProvider\n *\n * @requires ui.router.router.$urlRouterProvider\n * @requires ui.router.util.$urlMatcherFactoryProvider\n *\n * @description\n * The new `$stateProvider` works similar to Angular's v1 router, but it focuses purely\n * on state.\n *\n * A state corresponds to a \"place\" in the application in terms of the overall UI and\n * navigation. A state describes (via the controller / template / view properties) what\n * the UI looks like and does at that place.\n *\n * States often have things in common, and the primary way of factoring out these\n * commonalities in this model is via the state hierarchy, i.e. parent/child states aka\n * nested states.\n *\n * The `$stateProvider` provides interfaces to declare these states for your app.\n */\n$StateProvider.$inject = ['$urlRouterProvider', '$urlMatcherFactoryProvider'];\nfunction $StateProvider(   $urlRouterProvider,   $urlMatcherFactory) {\n\n  var root, states = {}, $state, queue = {}, abstractKey = 'abstract';\n\n  // Builds state properties from definition passed to registerState()\n  var stateBuilder = {\n\n    // Derive parent state from a hierarchical name only if 'parent' is not explicitly defined.\n    // state.children = [];\n    // if (parent) parent.children.push(state);\n    parent: function(state) {\n      if (isDefined(state.parent) && state.parent) return findState(state.parent);\n      // regex matches any valid composite state name\n      // would match \"contact.list\" but not \"contacts\"\n      var compositeName = /^(.+)\\.[^.]+$/.exec(state.name);\n      return compositeName ? findState(compositeName[1]) : root;\n    },\n\n    // inherit 'data' from parent and override by own values (if any)\n    data: function(state) {\n      if (state.parent && state.parent.data) {\n        state.data = state.self.data = inherit(state.parent.data, state.data);\n      }\n      return state.data;\n    },\n\n    // Build a URLMatcher if necessary, either via a relative or absolute URL\n    url: function(state) {\n      var url = state.url, config = { params: state.params || {} };\n\n      if (isString(url)) {\n        if (url.charAt(0) == '^') return $urlMatcherFactory.compile(url.substring(1), config);\n        return (state.parent.navigable || root).url.concat(url, config);\n      }\n\n      if (!url || $urlMatcherFactory.isMatcher(url)) return url;\n      throw new Error(\"Invalid url '\" + url + \"' in state '\" + state + \"'\");\n    },\n\n    // Keep track of the closest ancestor state that has a URL (i.e. is navigable)\n    navigable: function(state) {\n      return state.url ? state : (state.parent ? state.parent.navigable : null);\n    },\n\n    // Own parameters for this state. state.url.params is already built at this point. Create and add non-url params\n    ownParams: function(state) {\n      var params = state.url && state.url.params || new $$UMFP.ParamSet();\n      forEach(state.params || {}, function(config, id) {\n        if (!params[id]) params[id] = new $$UMFP.Param(id, null, config, \"config\");\n      });\n      return params;\n    },\n\n    // Derive parameters for this state and ensure they're a super-set of parent's parameters\n    params: function(state) {\n      var ownParams = pick(state.ownParams, state.ownParams.$$keys());\n      return state.parent && state.parent.params ? extend(state.parent.params.$$new(), ownParams) : new $$UMFP.ParamSet();\n    },\n\n    // If there is no explicit multi-view configuration, make one up so we don't have\n    // to handle both cases in the view directive later. Note that having an explicit\n    // 'views' property will mean the default unnamed view properties are ignored. This\n    // is also a good time to resolve view names to absolute names, so everything is a\n    // straight lookup at link time.\n    views: function(state) {\n      var views = {};\n\n      forEach(isDefined(state.views) ? state.views : { '': state }, function (view, name) {\n        if (name.indexOf('@') < 0) name += '@' + state.parent.name;\n        view.resolveAs = view.resolveAs || state.resolveAs || '$resolve';\n        views[name] = view;\n      });\n      return views;\n    },\n\n    // Keep a full path from the root down to this state as this is needed for state activation.\n    path: function(state) {\n      return state.parent ? state.parent.path.concat(state) : []; // exclude root from path\n    },\n\n    // Speed up $state.contains() as it's used a lot\n    includes: function(state) {\n      var includes = state.parent ? extend({}, state.parent.includes) : {};\n      includes[state.name] = true;\n      return includes;\n    },\n\n    $delegates: {}\n  };\n\n  function isRelative(stateName) {\n    return stateName.indexOf(\".\") === 0 || stateName.indexOf(\"^\") === 0;\n  }\n\n  function findState(stateOrName, base) {\n    if (!stateOrName) return undefined;\n\n    var isStr = isString(stateOrName),\n        name  = isStr ? stateOrName : stateOrName.name,\n        path  = isRelative(name);\n\n    if (path) {\n      if (!base) throw new Error(\"No reference point given for path '\"  + name + \"'\");\n      base = findState(base);\n      \n      var rel = name.split(\".\"), i = 0, pathLength = rel.length, current = base;\n\n      for (; i < pathLength; i++) {\n        if (rel[i] === \"\" && i === 0) {\n          current = base;\n          continue;\n        }\n        if (rel[i] === \"^\") {\n          if (!current.parent) throw new Error(\"Path '\" + name + \"' not valid for state '\" + base.name + \"'\");\n          current = current.parent;\n          continue;\n        }\n        break;\n      }\n      rel = rel.slice(i).join(\".\");\n      name = current.name + (current.name && rel ? \".\" : \"\") + rel;\n    }\n    var state = states[name];\n\n    if (state && (isStr || (!isStr && (state === stateOrName || state.self === stateOrName)))) {\n      return state;\n    }\n    return undefined;\n  }\n\n  function queueState(parentName, state) {\n    if (!queue[parentName]) {\n      queue[parentName] = [];\n    }\n    queue[parentName].push(state);\n  }\n\n  function flushQueuedChildren(parentName) {\n    var queued = queue[parentName] || [];\n    while(queued.length) {\n      registerState(queued.shift());\n    }\n  }\n\n  function registerState(state) {\n    // Wrap a new object around the state so we can store our private details easily.\n    state = inherit(state, {\n      self: state,\n      resolve: state.resolve || {},\n      toString: function() { return this.name; }\n    });\n\n    var name = state.name;\n    if (!isString(name) || name.indexOf('@') >= 0) throw new Error(\"State must have a valid name\");\n    if (states.hasOwnProperty(name)) throw new Error(\"State '\" + name + \"' is already defined\");\n\n    // Get parent name\n    var parentName = (name.indexOf('.') !== -1) ? name.substring(0, name.lastIndexOf('.'))\n        : (isString(state.parent)) ? state.parent\n        : (isObject(state.parent) && isString(state.parent.name)) ? state.parent.name\n        : '';\n\n    // If parent is not registered yet, add state to queue and register later\n    if (parentName && !states[parentName]) {\n      return queueState(parentName, state.self);\n    }\n\n    for (var key in stateBuilder) {\n      if (isFunction(stateBuilder[key])) state[key] = stateBuilder[key](state, stateBuilder.$delegates[key]);\n    }\n    states[name] = state;\n\n    // Register the state in the global state list and with $urlRouter if necessary.\n    if (!state[abstractKey] && state.url) {\n      $urlRouterProvider.when(state.url, ['$match', '$stateParams', function ($match, $stateParams) {\n        if ($state.$current.navigable != state || !equalForKeys($match, $stateParams)) {\n          $state.transitionTo(state, $match, { inherit: true, location: false });\n        }\n      }]);\n    }\n\n    // Register any queued children\n    flushQueuedChildren(name);\n\n    return state;\n  }\n\n  // Checks text to see if it looks like a glob.\n  function isGlob (text) {\n    return text.indexOf('*') > -1;\n  }\n\n  // Returns true if glob matches current $state name.\n  function doesStateMatchGlob (glob) {\n    var globSegments = glob.split('.'),\n        segments = $state.$current.name.split('.');\n\n    //match single stars\n    for (var i = 0, l = globSegments.length; i < l; i++) {\n      if (globSegments[i] === '*') {\n        segments[i] = '*';\n      }\n    }\n\n    //match greedy starts\n    if (globSegments[0] === '**') {\n       segments = segments.slice(indexOf(segments, globSegments[1]));\n       segments.unshift('**');\n    }\n    //match greedy ends\n    if (globSegments[globSegments.length - 1] === '**') {\n       segments.splice(indexOf(segments, globSegments[globSegments.length - 2]) + 1, Number.MAX_VALUE);\n       segments.push('**');\n    }\n\n    if (globSegments.length != segments.length) {\n      return false;\n    }\n\n    return segments.join('') === globSegments.join('');\n  }\n\n\n  // Implicit root state that is always active\n  root = registerState({\n    name: '',\n    url: '^',\n    views: null,\n    'abstract': true\n  });\n  root.navigable = null;\n\n\n  /**\n   * @ngdoc function\n   * @name ui.router.state.$stateProvider#decorator\n   * @methodOf ui.router.state.$stateProvider\n   *\n   * @description\n   * Allows you to extend (carefully) or override (at your own peril) the \n   * `stateBuilder` object used internally by `$stateProvider`. This can be used \n   * to add custom functionality to ui-router, for example inferring templateUrl \n   * based on the state name.\n   *\n   * When passing only a name, it returns the current (original or decorated) builder\n   * function that matches `name`.\n   *\n   * The builder functions that can be decorated are listed below. Though not all\n   * necessarily have a good use case for decoration, that is up to you to decide.\n   *\n   * In addition, users can attach custom decorators, which will generate new \n   * properties within the state's internal definition. There is currently no clear \n   * use-case for this beyond accessing internal states (i.e. $state.$current), \n   * however, expect this to become increasingly relevant as we introduce additional \n   * meta-programming features.\n   *\n   * **Warning**: Decorators should not be interdependent because the order of \n   * execution of the builder functions in non-deterministic. Builder functions \n   * should only be dependent on the state definition object and super function.\n   *\n   *\n   * Existing builder functions and current return values:\n   *\n   * - **parent** `{object}` - returns the parent state object.\n   * - **data** `{object}` - returns state data, including any inherited data that is not\n   *   overridden by own values (if any).\n   * - **url** `{object}` - returns a {@link ui.router.util.type:UrlMatcher UrlMatcher}\n   *   or `null`.\n   * - **navigable** `{object}` - returns closest ancestor state that has a URL (aka is \n   *   navigable).\n   * - **params** `{object}` - returns an array of state params that are ensured to \n   *   be a super-set of parent's params.\n   * - **views** `{object}` - returns a views object where each key is an absolute view \n   *   name (i.e. \"viewName@stateName\") and each value is the config object \n   *   (template, controller) for the view. Even when you don't use the views object \n   *   explicitly on a state config, one is still created for you internally.\n   *   So by decorating this builder function you have access to decorating template \n   *   and controller properties.\n   * - **ownParams** `{object}` - returns an array of params that belong to the state, \n   *   not including any params defined by ancestor states.\n   * - **path** `{string}` - returns the full path from the root down to this state. \n   *   Needed for state activation.\n   * - **includes** `{object}` - returns an object that includes every state that \n   *   would pass a `$state.includes()` test.\n   *\n   * @example\n   * <pre>\n   * // Override the internal 'views' builder with a function that takes the state\n   * // definition, and a reference to the internal function being overridden:\n   * $stateProvider.decorator('views', function (state, parent) {\n   *   var result = {},\n   *       views = parent(state);\n   *\n   *   angular.forEach(views, function (config, name) {\n   *     var autoName = (state.name + '.' + name).replace('.', '/');\n   *     config.templateUrl = config.templateUrl || '/partials/' + autoName + '.html';\n   *     result[name] = config;\n   *   });\n   *   return result;\n   * });\n   *\n   * $stateProvider.state('home', {\n   *   views: {\n   *     'contact.list': { controller: 'ListController' },\n   *     'contact.item': { controller: 'ItemController' }\n   *   }\n   * });\n   *\n   * // ...\n   *\n   * $state.go('home');\n   * // Auto-populates list and item views with /partials/home/contact/list.html,\n   * // and /partials/home/contact/item.html, respectively.\n   * </pre>\n   *\n   * @param {string} name The name of the builder function to decorate. \n   * @param {object} func A function that is responsible for decorating the original \n   * builder function. The function receives two parameters:\n   *\n   *   - `{object}` - state - The state config object.\n   *   - `{object}` - super - The original builder function.\n   *\n   * @return {object} $stateProvider - $stateProvider instance\n   */\n  this.decorator = decorator;\n  function decorator(name, func) {\n    /*jshint validthis: true */\n    if (isString(name) && !isDefined(func)) {\n      return stateBuilder[name];\n    }\n    if (!isFunction(func) || !isString(name)) {\n      return this;\n    }\n    if (stateBuilder[name] && !stateBuilder.$delegates[name]) {\n      stateBuilder.$delegates[name] = stateBuilder[name];\n    }\n    stateBuilder[name] = func;\n    return this;\n  }\n\n  /**\n   * @ngdoc function\n   * @name ui.router.state.$stateProvider#state\n   * @methodOf ui.router.state.$stateProvider\n   *\n   * @description\n   * Registers a state configuration under a given state name. The stateConfig object\n   * has the following acceptable properties.\n   *\n   * @param {string} name A unique state name, e.g. \"home\", \"about\", \"contacts\".\n   * To create a parent/child state use a dot, e.g. \"about.sales\", \"home.newest\".\n   * @param {object} stateConfig State configuration object.\n   * @param {string|function=} stateConfig.template\n   * <a id='template'></a>\n   *   html template as a string or a function that returns\n   *   an html template as a string which should be used by the uiView directives. This property \n   *   takes precedence over templateUrl.\n   *   \n   *   If `template` is a function, it will be called with the following parameters:\n   *\n   *   - {array.&lt;object&gt;} - state parameters extracted from the current $location.path() by\n   *     applying the current state\n   *\n   * <pre>template:\n   *   \"<h1>inline template definition</h1>\" +\n   *   \"<div ui-view></div>\"</pre>\n   * <pre>template: function(params) {\n   *       return \"<h1>generated template</h1>\"; }</pre>\n   * </div>\n   *\n   * @param {string|function=} stateConfig.templateUrl\n   * <a id='templateUrl'></a>\n   *\n   *   path or function that returns a path to an html\n   *   template that should be used by uiView.\n   *   \n   *   If `templateUrl` is a function, it will be called with the following parameters:\n   *\n   *   - {array.&lt;object&gt;} - state parameters extracted from the current $location.path() by \n   *     applying the current state\n   *\n   * <pre>templateUrl: \"home.html\"</pre>\n   * <pre>templateUrl: function(params) {\n   *     return myTemplates[params.pageId]; }</pre>\n   *\n   * @param {function=} stateConfig.templateProvider\n   * <a id='templateProvider'></a>\n   *    Provider function that returns HTML content string.\n   * <pre> templateProvider:\n   *       function(MyTemplateService, params) {\n   *         return MyTemplateService.getTemplate(params.pageId);\n   *       }</pre>\n   *\n   * @param {string|function=} stateConfig.controller\n   * <a id='controller'></a>\n   *\n   *  Controller fn that should be associated with newly\n   *   related scope or the name of a registered controller if passed as a string.\n   *   Optionally, the ControllerAs may be declared here.\n   * <pre>controller: \"MyRegisteredController\"</pre>\n   * <pre>controller:\n   *     \"MyRegisteredController as fooCtrl\"}</pre>\n   * <pre>controller: function($scope, MyService) {\n   *     $scope.data = MyService.getData(); }</pre>\n   *\n   * @param {function=} stateConfig.controllerProvider\n   * <a id='controllerProvider'></a>\n   *\n   * Injectable provider function that returns the actual controller or string.\n   * <pre>controllerProvider:\n   *   function(MyResolveData) {\n   *     if (MyResolveData.foo)\n   *       return \"FooCtrl\"\n   *     else if (MyResolveData.bar)\n   *       return \"BarCtrl\";\n   *     else return function($scope) {\n   *       $scope.baz = \"Qux\";\n   *     }\n   *   }</pre>\n   *\n   * @param {string=} stateConfig.controllerAs\n   * <a id='controllerAs'></a>\n   * \n   * A controller alias name. If present the controller will be\n   *   published to scope under the controllerAs name.\n   * <pre>controllerAs: \"myCtrl\"</pre>\n   *\n   * @param {string|object=} stateConfig.parent\n   * <a id='parent'></a>\n   * Optionally specifies the parent state of this state.\n   *\n   * <pre>parent: 'parentState'</pre>\n   * <pre>parent: parentState // JS variable</pre>\n   *\n   * @param {object=} stateConfig.resolve\n   * <a id='resolve'></a>\n   *\n   * An optional map&lt;string, function&gt; of dependencies which\n   *   should be injected into the controller. If any of these dependencies are promises, \n   *   the router will wait for them all to be resolved before the controller is instantiated.\n   *   If all the promises are resolved successfully, the $stateChangeSuccess event is fired\n   *   and the values of the resolved promises are injected into any controllers that reference them.\n   *   If any  of the promises are rejected the $stateChangeError event is fired.\n   *\n   *   The map object is:\n   *   \n   *   - key - {string}: name of dependency to be injected into controller\n   *   - factory - {string|function}: If string then it is alias for service. Otherwise if function, \n   *     it is injected and return value it treated as dependency. If result is a promise, it is \n   *     resolved before its value is injected into controller.\n   *\n   * <pre>resolve: {\n   *     myResolve1:\n   *       function($http, $stateParams) {\n   *         return $http.get(\"/api/foos/\"+stateParams.fooID);\n   *       }\n   *     }</pre>\n   *\n   * @param {string=} stateConfig.url\n   * <a id='url'></a>\n   *\n   *   A url fragment with optional parameters. When a state is navigated or\n   *   transitioned to, the `$stateParams` service will be populated with any \n   *   parameters that were passed.\n   *\n   *   (See {@link ui.router.util.type:UrlMatcher UrlMatcher} `UrlMatcher`} for\n   *   more details on acceptable patterns )\n   *\n   * examples:\n   * <pre>url: \"/home\"\n   * url: \"/users/:userid\"\n   * url: \"/books/{bookid:[a-zA-Z_-]}\"\n   * url: \"/books/{categoryid:int}\"\n   * url: \"/books/{publishername:string}/{categoryid:int}\"\n   * url: \"/messages?before&after\"\n   * url: \"/messages?{before:date}&{after:date}\"\n   * url: \"/messages/:mailboxid?{before:date}&{after:date}\"\n   * </pre>\n   *\n   * @param {object=} stateConfig.views\n   * <a id='views'></a>\n   * an optional map&lt;string, object&gt; which defined multiple views, or targets views\n   * manually/explicitly.\n   *\n   * Examples:\n   *\n   * Targets three named `ui-view`s in the parent state's template\n   * <pre>views: {\n   *     header: {\n   *       controller: \"headerCtrl\",\n   *       templateUrl: \"header.html\"\n   *     }, body: {\n   *       controller: \"bodyCtrl\",\n   *       templateUrl: \"body.html\"\n   *     }, footer: {\n   *       controller: \"footCtrl\",\n   *       templateUrl: \"footer.html\"\n   *     }\n   *   }</pre>\n   *\n   * Targets named `ui-view=\"header\"` from grandparent state 'top''s template, and named `ui-view=\"body\" from parent state's template.\n   * <pre>views: {\n   *     'header@top': {\n   *       controller: \"msgHeaderCtrl\",\n   *       templateUrl: \"msgHeader.html\"\n   *     }, 'body': {\n   *       controller: \"messagesCtrl\",\n   *       templateUrl: \"messages.html\"\n   *     }\n   *   }</pre>\n   *\n   * @param {boolean=} [stateConfig.abstract=false]\n   * <a id='abstract'></a>\n   * An abstract state will never be directly activated,\n   *   but can provide inherited properties to its common children states.\n   * <pre>abstract: true</pre>\n   *\n   * @param {function=} stateConfig.onEnter\n   * <a id='onEnter'></a>\n   *\n   * Callback function for when a state is entered. Good way\n   *   to trigger an action or dispatch an event, such as opening a dialog.\n   * If minifying your scripts, make sure to explicitly annotate this function,\n   * because it won't be automatically annotated by your build tools.\n   *\n   * <pre>onEnter: function(MyService, $stateParams) {\n   *     MyService.foo($stateParams.myParam);\n   * }</pre>\n   *\n   * @param {function=} stateConfig.onExit\n   * <a id='onExit'></a>\n   *\n   * Callback function for when a state is exited. Good way to\n   *   trigger an action or dispatch an event, such as opening a dialog.\n   * If minifying your scripts, make sure to explicitly annotate this function,\n   * because it won't be automatically annotated by your build tools.\n   *\n   * <pre>onExit: function(MyService, $stateParams) {\n   *     MyService.cleanup($stateParams.myParam);\n   * }</pre>\n   *\n   * @param {boolean=} [stateConfig.reloadOnSearch=true]\n   * <a id='reloadOnSearch'></a>\n   *\n   * If `false`, will not retrigger the same state\n   *   just because a search/query parameter has changed (via $location.search() or $location.hash()). \n   *   Useful for when you'd like to modify $location.search() without triggering a reload.\n   * <pre>reloadOnSearch: false</pre>\n   *\n   * @param {object=} stateConfig.data\n   * <a id='data'></a>\n   *\n   * Arbitrary data object, useful for custom configuration.  The parent state's `data` is\n   *   prototypally inherited.  In other words, adding a data property to a state adds it to\n   *   the entire subtree via prototypal inheritance.\n   *\n   * <pre>data: {\n   *     requiredRole: 'foo'\n   * } </pre>\n   *\n   * @param {object=} stateConfig.params\n   * <a id='params'></a>\n   *\n   * A map which optionally configures parameters declared in the `url`, or\n   *   defines additional non-url parameters.  For each parameter being\n   *   configured, add a configuration object keyed to the name of the parameter.\n   *\n   *   Each parameter configuration object may contain the following properties:\n   *\n   *   - ** value ** - {object|function=}: specifies the default value for this\n   *     parameter.  This implicitly sets this parameter as optional.\n   *\n   *     When UI-Router routes to a state and no value is\n   *     specified for this parameter in the URL or transition, the\n   *     default value will be used instead.  If `value` is a function,\n   *     it will be injected and invoked, and the return value used.\n   *\n   *     *Note*: `undefined` is treated as \"no default value\" while `null`\n   *     is treated as \"the default value is `null`\".\n   *\n   *     *Shorthand*: If you only need to configure the default value of the\n   *     parameter, you may use a shorthand syntax.   In the **`params`**\n   *     map, instead mapping the param name to a full parameter configuration\n   *     object, simply set map it to the default parameter value, e.g.:\n   *\n   * <pre>// define a parameter's default value\n   * params: {\n   *     param1: { value: \"defaultValue\" }\n   * }\n   * // shorthand default values\n   * params: {\n   *     param1: \"defaultValue\",\n   *     param2: \"param2Default\"\n   * }</pre>\n   *\n   *   - ** array ** - {boolean=}: *(default: false)* If true, the param value will be\n   *     treated as an array of values.  If you specified a Type, the value will be\n   *     treated as an array of the specified Type.  Note: query parameter values\n   *     default to a special `\"auto\"` mode.\n   *\n   *     For query parameters in `\"auto\"` mode, if multiple  values for a single parameter\n   *     are present in the URL (e.g.: `/foo?bar=1&bar=2&bar=3`) then the values\n   *     are mapped to an array (e.g.: `{ foo: [ '1', '2', '3' ] }`).  However, if\n   *     only one value is present (e.g.: `/foo?bar=1`) then the value is treated as single\n   *     value (e.g.: `{ foo: '1' }`).\n   *\n   * <pre>params: {\n   *     param1: { array: true }\n   * }</pre>\n   *\n   *   - ** squash ** - {bool|string=}: `squash` configures how a default parameter value is represented in the URL when\n   *     the current parameter value is the same as the default value. If `squash` is not set, it uses the\n   *     configured default squash policy.\n   *     (See {@link ui.router.util.$urlMatcherFactory#methods_defaultSquashPolicy `defaultSquashPolicy()`})\n   *\n   *   There are three squash settings:\n   *\n   *     - false: The parameter's default value is not squashed.  It is encoded and included in the URL\n   *     - true: The parameter's default value is omitted from the URL.  If the parameter is preceeded and followed\n   *       by slashes in the state's `url` declaration, then one of those slashes are omitted.\n   *       This can allow for cleaner looking URLs.\n   *     - `\"<arbitrary string>\"`: The parameter's default value is replaced with an arbitrary placeholder of  your choice.\n   *\n   * <pre>params: {\n   *     param1: {\n   *       value: \"defaultId\",\n   *       squash: true\n   * } }\n   * // squash \"defaultValue\" to \"~\"\n   * params: {\n   *     param1: {\n   *       value: \"defaultValue\",\n   *       squash: \"~\"\n   * } }\n   * </pre>\n   *\n   *\n   * @example\n   * <pre>\n   * // Some state name examples\n   *\n   * // stateName can be a single top-level name (must be unique).\n   * $stateProvider.state(\"home\", {});\n   *\n   * // Or it can be a nested state name. This state is a child of the\n   * // above \"home\" state.\n   * $stateProvider.state(\"home.newest\", {});\n   *\n   * // Nest states as deeply as needed.\n   * $stateProvider.state(\"home.newest.abc.xyz.inception\", {});\n   *\n   * // state() returns $stateProvider, so you can chain state declarations.\n   * $stateProvider\n   *   .state(\"home\", {})\n   *   .state(\"about\", {})\n   *   .state(\"contacts\", {});\n   * </pre>\n   *\n   */\n  this.state = state;\n  function state(name, definition) {\n    /*jshint validthis: true */\n    if (isObject(name)) definition = name;\n    else definition.name = name;\n    registerState(definition);\n    return this;\n  }\n\n  /**\n   * @ngdoc object\n   * @name ui.router.state.$state\n   *\n   * @requires $rootScope\n   * @requires $q\n   * @requires ui.router.state.$view\n   * @requires $injector\n   * @requires ui.router.util.$resolve\n   * @requires ui.router.state.$stateParams\n   * @requires ui.router.router.$urlRouter\n   *\n   * @property {object} params A param object, e.g. {sectionId: section.id)}, that \n   * you'd like to test against the current active state.\n   * @property {object} current A reference to the state's config object. However \n   * you passed it in. Useful for accessing custom data.\n   * @property {object} transition Currently pending transition. A promise that'll \n   * resolve or reject.\n   *\n   * @description\n   * `$state` service is responsible for representing states as well as transitioning\n   * between them. It also provides interfaces to ask for current state or even states\n   * you're coming from.\n   */\n  this.$get = $get;\n  $get.$inject = ['$rootScope', '$q', '$view', '$injector', '$resolve', '$stateParams', '$urlRouter', '$location', '$urlMatcherFactory'];\n  function $get(   $rootScope,   $q,   $view,   $injector,   $resolve,   $stateParams,   $urlRouter,   $location,   $urlMatcherFactory) {\n\n    var TransitionSuperseded = $q.reject(new Error('transition superseded'));\n    var TransitionPrevented = $q.reject(new Error('transition prevented'));\n    var TransitionAborted = $q.reject(new Error('transition aborted'));\n    var TransitionFailed = $q.reject(new Error('transition failed'));\n\n    // Handles the case where a state which is the target of a transition is not found, and the user\n    // can optionally retry or defer the transition\n    function handleRedirect(redirect, state, params, options) {\n      /**\n       * @ngdoc event\n       * @name ui.router.state.$state#$stateNotFound\n       * @eventOf ui.router.state.$state\n       * @eventType broadcast on root scope\n       * @description\n       * Fired when a requested state **cannot be found** using the provided state name during transition.\n       * The event is broadcast allowing any handlers a single chance to deal with the error (usually by\n       * lazy-loading the unfound state). A special `unfoundState` object is passed to the listener handler,\n       * you can see its three properties in the example. You can use `event.preventDefault()` to abort the\n       * transition and the promise returned from `go` will be rejected with a `'transition aborted'` value.\n       *\n       * @param {Object} event Event object.\n       * @param {Object} unfoundState Unfound State information. Contains: `to, toParams, options` properties.\n       * @param {State} fromState Current state object.\n       * @param {Object} fromParams Current state params.\n       *\n       * @example\n       *\n       * <pre>\n       * // somewhere, assume lazy.state has not been defined\n       * $state.go(\"lazy.state\", {a:1, b:2}, {inherit:false});\n       *\n       * // somewhere else\n       * $scope.$on('$stateNotFound',\n       * function(event, unfoundState, fromState, fromParams){\n       *     console.log(unfoundState.to); // \"lazy.state\"\n       *     console.log(unfoundState.toParams); // {a:1, b:2}\n       *     console.log(unfoundState.options); // {inherit:false} + default options\n       * })\n       * </pre>\n       */\n      var evt = $rootScope.$broadcast('$stateNotFound', redirect, state, params);\n\n      if (evt.defaultPrevented) {\n        $urlRouter.update();\n        return TransitionAborted;\n      }\n\n      if (!evt.retry) {\n        return null;\n      }\n\n      // Allow the handler to return a promise to defer state lookup retry\n      if (options.$retry) {\n        $urlRouter.update();\n        return TransitionFailed;\n      }\n      var retryTransition = $state.transition = $q.when(evt.retry);\n\n      retryTransition.then(function() {\n        if (retryTransition !== $state.transition) return TransitionSuperseded;\n        redirect.options.$retry = true;\n        return $state.transitionTo(redirect.to, redirect.toParams, redirect.options);\n      }, function() {\n        return TransitionAborted;\n      });\n      $urlRouter.update();\n\n      return retryTransition;\n    }\n\n    root.locals = { resolve: null, globals: { $stateParams: {} } };\n\n    $state = {\n      params: {},\n      current: root.self,\n      $current: root,\n      transition: null\n    };\n\n    /**\n     * @ngdoc function\n     * @name ui.router.state.$state#reload\n     * @methodOf ui.router.state.$state\n     *\n     * @description\n     * A method that force reloads the current state. All resolves are re-resolved,\n     * controllers reinstantiated, and events re-fired.\n     *\n     * @example\n     * <pre>\n     * var app angular.module('app', ['ui.router']);\n     *\n     * app.controller('ctrl', function ($scope, $state) {\n     *   $scope.reload = function(){\n     *     $state.reload();\n     *   }\n     * });\n     * </pre>\n     *\n     * `reload()` is just an alias for:\n     * <pre>\n     * $state.transitionTo($state.current, $stateParams, { \n     *   reload: true, inherit: false, notify: true\n     * });\n     * </pre>\n     *\n     * @param {string=|object=} state - A state name or a state object, which is the root of the resolves to be re-resolved.\n     * @example\n     * <pre>\n     * //assuming app application consists of 3 states: 'contacts', 'contacts.detail', 'contacts.detail.item' \n     * //and current state is 'contacts.detail.item'\n     * var app angular.module('app', ['ui.router']);\n     *\n     * app.controller('ctrl', function ($scope, $state) {\n     *   $scope.reload = function(){\n     *     //will reload 'contact.detail' and 'contact.detail.item' states\n     *     $state.reload('contact.detail');\n     *   }\n     * });\n     * </pre>\n     *\n     * `reload()` is just an alias for:\n     * <pre>\n     * $state.transitionTo($state.current, $stateParams, { \n     *   reload: true, inherit: false, notify: true\n     * });\n     * </pre>\n\n     * @returns {promise} A promise representing the state of the new transition. See\n     * {@link ui.router.state.$state#methods_go $state.go}.\n     */\n    $state.reload = function reload(state) {\n      return $state.transitionTo($state.current, $stateParams, { reload: state || true, inherit: false, notify: true});\n    };\n\n    /**\n     * @ngdoc function\n     * @name ui.router.state.$state#go\n     * @methodOf ui.router.state.$state\n     *\n     * @description\n     * Convenience method for transitioning to a new state. `$state.go` calls \n     * `$state.transitionTo` internally but automatically sets options to \n     * `{ location: true, inherit: true, relative: $state.$current, notify: true }`. \n     * This allows you to easily use an absolute or relative to path and specify \n     * only the parameters you'd like to update (while letting unspecified parameters \n     * inherit from the currently active ancestor states).\n     *\n     * @example\n     * <pre>\n     * var app = angular.module('app', ['ui.router']);\n     *\n     * app.controller('ctrl', function ($scope, $state) {\n     *   $scope.changeState = function () {\n     *     $state.go('contact.detail');\n     *   };\n     * });\n     * </pre>\n     * <img src='../ngdoc_assets/StateGoExamples.png'/>\n     *\n     * @param {string} to Absolute state name or relative state path. Some examples:\n     *\n     * - `$state.go('contact.detail')` - will go to the `contact.detail` state\n     * - `$state.go('^')` - will go to a parent state\n     * - `$state.go('^.sibling')` - will go to a sibling state\n     * - `$state.go('.child.grandchild')` - will go to grandchild state\n     *\n     * @param {object=} params A map of the parameters that will be sent to the state, \n     * will populate $stateParams. Any parameters that are not specified will be inherited from currently \n     * defined parameters. Only parameters specified in the state definition can be overridden, new \n     * parameters will be ignored. This allows, for example, going to a sibling state that shares parameters\n     * specified in a parent state. Parameter inheritance only works between common ancestor states, I.e.\n     * transitioning to a sibling will get you the parameters for all parents, transitioning to a child\n     * will get you all current parameters, etc.\n     * @param {object=} options Options object. The options are:\n     *\n     * - **`location`** - {boolean=true|string=} - If `true` will update the url in the location bar, if `false`\n     *    will not. If string, must be `\"replace\"`, which will update url and also replace last history record.\n     * - **`inherit`** - {boolean=true}, If `true` will inherit url parameters from current url.\n     * - **`relative`** - {object=$state.$current}, When transitioning with relative path (e.g '^'), \n     *    defines which state to be relative from.\n     * - **`notify`** - {boolean=true}, If `true` will broadcast $stateChangeStart and $stateChangeSuccess events.\n     * - **`reload`** (v0.2.5) - {boolean=false|string|object}, If `true` will force transition even if no state or params\n     *    have changed.  It will reload the resolves and views of the current state and parent states.\n     *    If `reload` is a string (or state object), the state object is fetched (by name, or object reference); and \\\n     *    the transition reloads the resolves and views for that matched state, and all its children states.\n     *\n     * @returns {promise} A promise representing the state of the new transition.\n     *\n     * Possible success values:\n     *\n     * - $state.current\n     *\n     * <br/>Possible rejection values:\n     *\n     * - 'transition superseded' - when a newer transition has been started after this one\n     * - 'transition prevented' - when `event.preventDefault()` has been called in a `$stateChangeStart` listener\n     * - 'transition aborted' - when `event.preventDefault()` has been called in a `$stateNotFound` listener or\n     *   when a `$stateNotFound` `event.retry` promise errors.\n     * - 'transition failed' - when a state has been unsuccessfully found after 2 tries.\n     * - *resolve error* - when an error has occurred with a `resolve`\n     *\n     */\n    $state.go = function go(to, params, options) {\n      return $state.transitionTo(to, params, extend({ inherit: true, relative: $state.$current }, options));\n    };\n\n    /**\n     * @ngdoc function\n     * @name ui.router.state.$state#transitionTo\n     * @methodOf ui.router.state.$state\n     *\n     * @description\n     * Low-level method for transitioning to a new state. {@link ui.router.state.$state#methods_go $state.go}\n     * uses `transitionTo` internally. `$state.go` is recommended in most situations.\n     *\n     * @example\n     * <pre>\n     * var app = angular.module('app', ['ui.router']);\n     *\n     * app.controller('ctrl', function ($scope, $state) {\n     *   $scope.changeState = function () {\n     *     $state.transitionTo('contact.detail');\n     *   };\n     * });\n     * </pre>\n     *\n     * @param {string} to State name.\n     * @param {object=} toParams A map of the parameters that will be sent to the state,\n     * will populate $stateParams.\n     * @param {object=} options Options object. The options are:\n     *\n     * - **`location`** - {boolean=true|string=} - If `true` will update the url in the location bar, if `false`\n     *    will not. If string, must be `\"replace\"`, which will update url and also replace last history record.\n     * - **`inherit`** - {boolean=false}, If `true` will inherit url parameters from current url.\n     * - **`relative`** - {object=}, When transitioning with relative path (e.g '^'), \n     *    defines which state to be relative from.\n     * - **`notify`** - {boolean=true}, If `true` will broadcast $stateChangeStart and $stateChangeSuccess events.\n     * - **`reload`** (v0.2.5) - {boolean=false|string=|object=}, If `true` will force transition even if the state or params \n     *    have not changed, aka a reload of the same state. It differs from reloadOnSearch because you'd\n     *    use this when you want to force a reload when *everything* is the same, including search params.\n     *    if String, then will reload the state with the name given in reload, and any children.\n     *    if Object, then a stateObj is expected, will reload the state found in stateObj, and any children.\n     *\n     * @returns {promise} A promise representing the state of the new transition. See\n     * {@link ui.router.state.$state#methods_go $state.go}.\n     */\n    $state.transitionTo = function transitionTo(to, toParams, options) {\n      toParams = toParams || {};\n      options = extend({\n        location: true, inherit: false, relative: null, notify: true, reload: false, $retry: false\n      }, options || {});\n\n      var from = $state.$current, fromParams = $state.params, fromPath = from.path;\n      var evt, toState = findState(to, options.relative);\n\n      // Store the hash param for later (since it will be stripped out by various methods)\n      var hash = toParams['#'];\n\n      if (!isDefined(toState)) {\n        var redirect = { to: to, toParams: toParams, options: options };\n        var redirectResult = handleRedirect(redirect, from.self, fromParams, options);\n\n        if (redirectResult) {\n          return redirectResult;\n        }\n\n        // Always retry once if the $stateNotFound was not prevented\n        // (handles either redirect changed or state lazy-definition)\n        to = redirect.to;\n        toParams = redirect.toParams;\n        options = redirect.options;\n        toState = findState(to, options.relative);\n\n        if (!isDefined(toState)) {\n          if (!options.relative) throw new Error(\"No such state '\" + to + \"'\");\n          throw new Error(\"Could not resolve '\" + to + \"' from state '\" + options.relative + \"'\");\n        }\n      }\n      if (toState[abstractKey]) throw new Error(\"Cannot transition to abstract state '\" + to + \"'\");\n      if (options.inherit) toParams = inheritParams($stateParams, toParams || {}, $state.$current, toState);\n      if (!toState.params.$$validates(toParams)) return TransitionFailed;\n\n      toParams = toState.params.$$values(toParams);\n      to = toState;\n\n      var toPath = to.path;\n\n      // Starting from the root of the path, keep all levels that haven't changed\n      var keep = 0, state = toPath[keep], locals = root.locals, toLocals = [];\n\n      if (!options.reload) {\n        while (state && state === fromPath[keep] && state.ownParams.$$equals(toParams, fromParams)) {\n          locals = toLocals[keep] = state.locals;\n          keep++;\n          state = toPath[keep];\n        }\n      } else if (isString(options.reload) || isObject(options.reload)) {\n        if (isObject(options.reload) && !options.reload.name) {\n          throw new Error('Invalid reload state object');\n        }\n        \n        var reloadState = options.reload === true ? fromPath[0] : findState(options.reload);\n        if (options.reload && !reloadState) {\n          throw new Error(\"No such reload state '\" + (isString(options.reload) ? options.reload : options.reload.name) + \"'\");\n        }\n\n        while (state && state === fromPath[keep] && state !== reloadState) {\n          locals = toLocals[keep] = state.locals;\n          keep++;\n          state = toPath[keep];\n        }\n      }\n\n      // If we're going to the same state and all locals are kept, we've got nothing to do.\n      // But clear 'transition', as we still want to cancel any other pending transitions.\n      // TODO: We may not want to bump 'transition' if we're called from a location change\n      // that we've initiated ourselves, because we might accidentally abort a legitimate\n      // transition initiated from code?\n      if (shouldSkipReload(to, toParams, from, fromParams, locals, options)) {\n        if (hash) toParams['#'] = hash;\n        $state.params = toParams;\n        copy($state.params, $stateParams);\n        copy(filterByKeys(to.params.$$keys(), $stateParams), to.locals.globals.$stateParams);\n        if (options.location && to.navigable && to.navigable.url) {\n          $urlRouter.push(to.navigable.url, toParams, {\n            $$avoidResync: true, replace: options.location === 'replace'\n          });\n          $urlRouter.update(true);\n        }\n        $state.transition = null;\n        return $q.when($state.current);\n      }\n\n      // Filter parameters before we pass them to event handlers etc.\n      toParams = filterByKeys(to.params.$$keys(), toParams || {});\n      \n      // Re-add the saved hash before we start returning things or broadcasting $stateChangeStart\n      if (hash) toParams['#'] = hash;\n      \n      // Broadcast start event and cancel the transition if requested\n      if (options.notify) {\n        /**\n         * @ngdoc event\n         * @name ui.router.state.$state#$stateChangeStart\n         * @eventOf ui.router.state.$state\n         * @eventType broadcast on root scope\n         * @description\n         * Fired when the state transition **begins**. You can use `event.preventDefault()`\n         * to prevent the transition from happening and then the transition promise will be\n         * rejected with a `'transition prevented'` value.\n         *\n         * @param {Object} event Event object.\n         * @param {State} toState The state being transitioned to.\n         * @param {Object} toParams The params supplied to the `toState`.\n         * @param {State} fromState The current state, pre-transition.\n         * @param {Object} fromParams The params supplied to the `fromState`.\n         *\n         * @example\n         *\n         * <pre>\n         * $rootScope.$on('$stateChangeStart',\n         * function(event, toState, toParams, fromState, fromParams){\n         *     event.preventDefault();\n         *     // transitionTo() promise will be rejected with\n         *     // a 'transition prevented' error\n         * })\n         * </pre>\n         */\n        if ($rootScope.$broadcast('$stateChangeStart', to.self, toParams, from.self, fromParams, options).defaultPrevented) {\n          $rootScope.$broadcast('$stateChangeCancel', to.self, toParams, from.self, fromParams);\n          //Don't update and resync url if there's been a new transition started. see issue #2238, #600\n          if ($state.transition == null) $urlRouter.update();\n          return TransitionPrevented;\n        }\n      }\n\n      // Resolve locals for the remaining states, but don't update any global state just\n      // yet -- if anything fails to resolve the current state needs to remain untouched.\n      // We also set up an inheritance chain for the locals here. This allows the view directive\n      // to quickly look up the correct definition for each view in the current state. Even\n      // though we create the locals object itself outside resolveState(), it is initially\n      // empty and gets filled asynchronously. We need to keep track of the promise for the\n      // (fully resolved) current locals, and pass this down the chain.\n      var resolved = $q.when(locals);\n\n      for (var l = keep; l < toPath.length; l++, state = toPath[l]) {\n        locals = toLocals[l] = inherit(locals);\n        resolved = resolveState(state, toParams, state === to, resolved, locals, options);\n      }\n\n      // Once everything is resolved, we are ready to perform the actual transition\n      // and return a promise for the new state. We also keep track of what the\n      // current promise is, so that we can detect overlapping transitions and\n      // keep only the outcome of the last transition.\n      var transition = $state.transition = resolved.then(function () {\n        var l, entering, exiting;\n\n        if ($state.transition !== transition) return TransitionSuperseded;\n\n        // Exit 'from' states not kept\n        for (l = fromPath.length - 1; l >= keep; l--) {\n          exiting = fromPath[l];\n          if (exiting.self.onExit) {\n            $injector.invoke(exiting.self.onExit, exiting.self, exiting.locals.globals);\n          }\n          exiting.locals = null;\n        }\n\n        // Enter 'to' states not kept\n        for (l = keep; l < toPath.length; l++) {\n          entering = toPath[l];\n          entering.locals = toLocals[l];\n          if (entering.self.onEnter) {\n            $injector.invoke(entering.self.onEnter, entering.self, entering.locals.globals);\n          }\n        }\n\n        // Run it again, to catch any transitions in callbacks\n        if ($state.transition !== transition) return TransitionSuperseded;\n\n        // Update globals in $state\n        $state.$current = to;\n        $state.current = to.self;\n        $state.params = toParams;\n        copy($state.params, $stateParams);\n        $state.transition = null;\n\n        if (options.location && to.navigable) {\n          $urlRouter.push(to.navigable.url, to.navigable.locals.globals.$stateParams, {\n            $$avoidResync: true, replace: options.location === 'replace'\n          });\n        }\n\n        if (options.notify) {\n        /**\n         * @ngdoc event\n         * @name ui.router.state.$state#$stateChangeSuccess\n         * @eventOf ui.router.state.$state\n         * @eventType broadcast on root scope\n         * @description\n         * Fired once the state transition is **complete**.\n         *\n         * @param {Object} event Event object.\n         * @param {State} toState The state being transitioned to.\n         * @param {Object} toParams The params supplied to the `toState`.\n         * @param {State} fromState The current state, pre-transition.\n         * @param {Object} fromParams The params supplied to the `fromState`.\n         */\n          $rootScope.$broadcast('$stateChangeSuccess', to.self, toParams, from.self, fromParams);\n        }\n        $urlRouter.update(true);\n\n        return $state.current;\n      }).then(null, function (error) {\n        if ($state.transition !== transition) return TransitionSuperseded;\n\n        $state.transition = null;\n        /**\n         * @ngdoc event\n         * @name ui.router.state.$state#$stateChangeError\n         * @eventOf ui.router.state.$state\n         * @eventType broadcast on root scope\n         * @description\n         * Fired when an **error occurs** during transition. It's important to note that if you\n         * have any errors in your resolve functions (javascript errors, non-existent services, etc)\n         * they will not throw traditionally. You must listen for this $stateChangeError event to\n         * catch **ALL** errors.\n         *\n         * @param {Object} event Event object.\n         * @param {State} toState The state being transitioned to.\n         * @param {Object} toParams The params supplied to the `toState`.\n         * @param {State} fromState The current state, pre-transition.\n         * @param {Object} fromParams The params supplied to the `fromState`.\n         * @param {Error} error The resolve error object.\n         */\n        evt = $rootScope.$broadcast('$stateChangeError', to.self, toParams, from.self, fromParams, error);\n\n        if (!evt.defaultPrevented) {\n            $urlRouter.update();\n        }\n\n        return $q.reject(error);\n      });\n\n      return transition;\n    };\n\n    /**\n     * @ngdoc function\n     * @name ui.router.state.$state#is\n     * @methodOf ui.router.state.$state\n     *\n     * @description\n     * Similar to {@link ui.router.state.$state#methods_includes $state.includes},\n     * but only checks for the full state name. If params is supplied then it will be\n     * tested for strict equality against the current active params object, so all params\n     * must match with none missing and no extras.\n     *\n     * @example\n     * <pre>\n     * $state.$current.name = 'contacts.details.item';\n     *\n     * // absolute name\n     * $state.is('contact.details.item'); // returns true\n     * $state.is(contactDetailItemStateObject); // returns true\n     *\n     * // relative name (. and ^), typically from a template\n     * // E.g. from the 'contacts.details' template\n     * <div ng-class=\"{highlighted: $state.is('.item')}\">Item</div>\n     * </pre>\n     *\n     * @param {string|object} stateOrName The state name (absolute or relative) or state object you'd like to check.\n     * @param {object=} params A param object, e.g. `{sectionId: section.id}`, that you'd like\n     * to test against the current active state.\n     * @param {object=} options An options object.  The options are:\n     *\n     * - **`relative`** - {string|object} -  If `stateOrName` is a relative state name and `options.relative` is set, .is will\n     * test relative to `options.relative` state (or name).\n     *\n     * @returns {boolean} Returns true if it is the state.\n     */\n    $state.is = function is(stateOrName, params, options) {\n      options = extend({ relative: $state.$current }, options || {});\n      var state = findState(stateOrName, options.relative);\n\n      if (!isDefined(state)) { return undefined; }\n      if ($state.$current !== state) { return false; }\n      return params ? equalForKeys(state.params.$$values(params), $stateParams) : true;\n    };\n\n    /**\n     * @ngdoc function\n     * @name ui.router.state.$state#includes\n     * @methodOf ui.router.state.$state\n     *\n     * @description\n     * A method to determine if the current active state is equal to or is the child of the\n     * state stateName. If any params are passed then they will be tested for a match as well.\n     * Not all the parameters need to be passed, just the ones you'd like to test for equality.\n     *\n     * @example\n     * Partial and relative names\n     * <pre>\n     * $state.$current.name = 'contacts.details.item';\n     *\n     * // Using partial names\n     * $state.includes(\"contacts\"); // returns true\n     * $state.includes(\"contacts.details\"); // returns true\n     * $state.includes(\"contacts.details.item\"); // returns true\n     * $state.includes(\"contacts.list\"); // returns false\n     * $state.includes(\"about\"); // returns false\n     *\n     * // Using relative names (. and ^), typically from a template\n     * // E.g. from the 'contacts.details' template\n     * <div ng-class=\"{highlighted: $state.includes('.item')}\">Item</div>\n     * </pre>\n     *\n     * Basic globbing patterns\n     * <pre>\n     * $state.$current.name = 'contacts.details.item.url';\n     *\n     * $state.includes(\"*.details.*.*\"); // returns true\n     * $state.includes(\"*.details.**\"); // returns true\n     * $state.includes(\"**.item.**\"); // returns true\n     * $state.includes(\"*.details.item.url\"); // returns true\n     * $state.includes(\"*.details.*.url\"); // returns true\n     * $state.includes(\"*.details.*\"); // returns false\n     * $state.includes(\"item.**\"); // returns false\n     * </pre>\n     *\n     * @param {string} stateOrName A partial name, relative name, or glob pattern\n     * to be searched for within the current state name.\n     * @param {object=} params A param object, e.g. `{sectionId: section.id}`,\n     * that you'd like to test against the current active state.\n     * @param {object=} options An options object.  The options are:\n     *\n     * - **`relative`** - {string|object=} -  If `stateOrName` is a relative state reference and `options.relative` is set,\n     * .includes will test relative to `options.relative` state (or name).\n     *\n     * @returns {boolean} Returns true if it does include the state\n     */\n    $state.includes = function includes(stateOrName, params, options) {\n      options = extend({ relative: $state.$current }, options || {});\n      if (isString(stateOrName) && isGlob(stateOrName)) {\n        if (!doesStateMatchGlob(stateOrName)) {\n          return false;\n        }\n        stateOrName = $state.$current.name;\n      }\n\n      var state = findState(stateOrName, options.relative);\n      if (!isDefined(state)) { return undefined; }\n      if (!isDefined($state.$current.includes[state.name])) { return false; }\n      return params ? equalForKeys(state.params.$$values(params), $stateParams, objectKeys(params)) : true;\n    };\n\n\n    /**\n     * @ngdoc function\n     * @name ui.router.state.$state#href\n     * @methodOf ui.router.state.$state\n     *\n     * @description\n     * A url generation method that returns the compiled url for the given state populated with the given params.\n     *\n     * @example\n     * <pre>\n     * expect($state.href(\"about.person\", { person: \"bob\" })).toEqual(\"/about/bob\");\n     * </pre>\n     *\n     * @param {string|object} stateOrName The state name or state object you'd like to generate a url from.\n     * @param {object=} params An object of parameter values to fill the state's required parameters.\n     * @param {object=} options Options object. The options are:\n     *\n     * - **`lossy`** - {boolean=true} -  If true, and if there is no url associated with the state provided in the\n     *    first parameter, then the constructed href url will be built from the first navigable ancestor (aka\n     *    ancestor with a valid url).\n     * - **`inherit`** - {boolean=true}, If `true` will inherit url parameters from current url.\n     * - **`relative`** - {object=$state.$current}, When transitioning with relative path (e.g '^'), \n     *    defines which state to be relative from.\n     * - **`absolute`** - {boolean=false},  If true will generate an absolute url, e.g. \"http://www.example.com/fullurl\".\n     * \n     * @returns {string} compiled state url\n     */\n    $state.href = function href(stateOrName, params, options) {\n      options = extend({\n        lossy:    true,\n        inherit:  true,\n        absolute: false,\n        relative: $state.$current\n      }, options || {});\n\n      var state = findState(stateOrName, options.relative);\n\n      if (!isDefined(state)) return null;\n      if (options.inherit) params = inheritParams($stateParams, params || {}, $state.$current, state);\n      \n      var nav = (state && options.lossy) ? state.navigable : state;\n\n      if (!nav || nav.url === undefined || nav.url === null) {\n        return null;\n      }\n      return $urlRouter.href(nav.url, filterByKeys(state.params.$$keys().concat('#'), params || {}), {\n        absolute: options.absolute\n      });\n    };\n\n    /**\n     * @ngdoc function\n     * @name ui.router.state.$state#get\n     * @methodOf ui.router.state.$state\n     *\n     * @description\n     * Returns the state configuration object for any specific state or all states.\n     *\n     * @param {string|object=} stateOrName (absolute or relative) If provided, will only get the config for\n     * the requested state. If not provided, returns an array of ALL state configs.\n     * @param {string|object=} context When stateOrName is a relative state reference, the state will be retrieved relative to context.\n     * @returns {Object|Array} State configuration object or array of all objects.\n     */\n    $state.get = function (stateOrName, context) {\n      if (arguments.length === 0) return map(objectKeys(states), function(name) { return states[name].self; });\n      var state = findState(stateOrName, context || $state.$current);\n      return (state && state.self) ? state.self : null;\n    };\n\n    function resolveState(state, params, paramsAreFiltered, inherited, dst, options) {\n      // Make a restricted $stateParams with only the parameters that apply to this state if\n      // necessary. In addition to being available to the controller and onEnter/onExit callbacks,\n      // we also need $stateParams to be available for any $injector calls we make during the\n      // dependency resolution process.\n      var $stateParams = (paramsAreFiltered) ? params : filterByKeys(state.params.$$keys(), params);\n      var locals = { $stateParams: $stateParams };\n\n      // Resolve 'global' dependencies for the state, i.e. those not specific to a view.\n      // We're also including $stateParams in this; that way the parameters are restricted\n      // to the set that should be visible to the state, and are independent of when we update\n      // the global $state and $stateParams values.\n      dst.resolve = $resolve.resolve(state.resolve, locals, dst.resolve, state);\n      var promises = [dst.resolve.then(function (globals) {\n        dst.globals = globals;\n      })];\n      if (inherited) promises.push(inherited);\n\n      function resolveViews() {\n        var viewsPromises = [];\n\n        // Resolve template and dependencies for all views.\n        forEach(state.views, function (view, name) {\n          var injectables = (view.resolve && view.resolve !== state.resolve ? view.resolve : {});\n          injectables.$template = [ function () {\n            return $view.load(name, { view: view, locals: dst.globals, params: $stateParams, notify: options.notify }) || '';\n          }];\n\n          viewsPromises.push($resolve.resolve(injectables, dst.globals, dst.resolve, state).then(function (result) {\n            // References to the controller (only instantiated at link time)\n            if (isFunction(view.controllerProvider) || isArray(view.controllerProvider)) {\n              var injectLocals = angular.extend({}, injectables, dst.globals);\n              result.$$controller = $injector.invoke(view.controllerProvider, null, injectLocals);\n            } else {\n              result.$$controller = view.controller;\n            }\n            // Provide access to the state itself for internal use\n            result.$$state = state;\n            result.$$controllerAs = view.controllerAs;\n            result.$$resolveAs = view.resolveAs;\n            dst[name] = result;\n          }));\n        });\n\n        return $q.all(viewsPromises).then(function(){\n          return dst.globals;\n        });\n      }\n\n      // Wait for all the promises and then return the activation object\n      return $q.all(promises).then(resolveViews).then(function (values) {\n        return dst;\n      });\n    }\n\n    return $state;\n  }\n\n  function shouldSkipReload(to, toParams, from, fromParams, locals, options) {\n    // Return true if there are no differences in non-search (path/object) params, false if there are differences\n    function nonSearchParamsEqual(fromAndToState, fromParams, toParams) {\n      // Identify whether all the parameters that differ between `fromParams` and `toParams` were search params.\n      function notSearchParam(key) {\n        return fromAndToState.params[key].location != \"search\";\n      }\n      var nonQueryParamKeys = fromAndToState.params.$$keys().filter(notSearchParam);\n      var nonQueryParams = pick.apply({}, [fromAndToState.params].concat(nonQueryParamKeys));\n      var nonQueryParamSet = new $$UMFP.ParamSet(nonQueryParams);\n      return nonQueryParamSet.$$equals(fromParams, toParams);\n    }\n\n    // If reload was not explicitly requested\n    // and we're transitioning to the same state we're already in\n    // and    the locals didn't change\n    //     or they changed in a way that doesn't merit reloading\n    //        (reloadOnParams:false, or reloadOnSearch.false and only search params changed)\n    // Then return true.\n    if (!options.reload && to === from &&\n      (locals === from.locals || (to.self.reloadOnSearch === false && nonSearchParamsEqual(from, fromParams, toParams)))) {\n      return true;\n    }\n  }\n}\n\nangular.module('ui.router.state')\n  .factory('$stateParams', function () { return {}; })\n  .constant(\"$state.runtime\", { autoinject: true })\n  .provider('$state', $StateProvider)\n  // Inject $state to initialize when entering runtime. #2574\n  .run(['$injector', function ($injector) {\n    // Allow tests (stateSpec.js) to turn this off by defining this constant\n    if ($injector.get(\"$state.runtime\").autoinject) {\n      $injector.get('$state');\n    }\n  }]);\n\n\n$ViewProvider.$inject = [];\nfunction $ViewProvider() {\n\n  this.$get = $get;\n  /**\n   * @ngdoc object\n   * @name ui.router.state.$view\n   *\n   * @requires ui.router.util.$templateFactory\n   * @requires $rootScope\n   *\n   * @description\n   *\n   */\n  $get.$inject = ['$rootScope', '$templateFactory'];\n  function $get(   $rootScope,   $templateFactory) {\n    return {\n      // $view.load('full.viewName', { template: ..., controller: ..., resolve: ..., async: false, params: ... })\n      /**\n       * @ngdoc function\n       * @name ui.router.state.$view#load\n       * @methodOf ui.router.state.$view\n       *\n       * @description\n       *\n       * @param {string} name name\n       * @param {object} options option object.\n       */\n      load: function load(name, options) {\n        var result, defaults = {\n          template: null, controller: null, view: null, locals: null, notify: true, async: true, params: {}\n        };\n        options = extend(defaults, options);\n\n        if (options.view) {\n          result = $templateFactory.fromConfig(options.view, options.params, options.locals);\n        }\n        return result;\n      }\n    };\n  }\n}\n\nangular.module('ui.router.state').provider('$view', $ViewProvider);\n\n/**\n * @ngdoc object\n * @name ui.router.state.$uiViewScrollProvider\n *\n * @description\n * Provider that returns the {@link ui.router.state.$uiViewScroll} service function.\n */\nfunction $ViewScrollProvider() {\n\n  var useAnchorScroll = false;\n\n  /**\n   * @ngdoc function\n   * @name ui.router.state.$uiViewScrollProvider#useAnchorScroll\n   * @methodOf ui.router.state.$uiViewScrollProvider\n   *\n   * @description\n   * Reverts back to using the core [`$anchorScroll`](http://docs.angularjs.org/api/ng.$anchorScroll) service for\n   * scrolling based on the url anchor.\n   */\n  this.useAnchorScroll = function () {\n    useAnchorScroll = true;\n  };\n\n  /**\n   * @ngdoc object\n   * @name ui.router.state.$uiViewScroll\n   *\n   * @requires $anchorScroll\n   * @requires $timeout\n   *\n   * @description\n   * When called with a jqLite element, it scrolls the element into view (after a\n   * `$timeout` so the DOM has time to refresh).\n   *\n   * If you prefer to rely on `$anchorScroll` to scroll the view to the anchor,\n   * this can be enabled by calling {@link ui.router.state.$uiViewScrollProvider#methods_useAnchorScroll `$uiViewScrollProvider.useAnchorScroll()`}.\n   */\n  this.$get = ['$anchorScroll', '$timeout', function ($anchorScroll, $timeout) {\n    if (useAnchorScroll) {\n      return $anchorScroll;\n    }\n\n    return function ($element) {\n      return $timeout(function () {\n        $element[0].scrollIntoView();\n      }, 0, false);\n    };\n  }];\n}\n\nangular.module('ui.router.state').provider('$uiViewScroll', $ViewScrollProvider);\n\n/**\n * @ngdoc directive\n * @name ui.router.state.directive:ui-view\n *\n * @requires ui.router.state.$state\n * @requires $compile\n * @requires $controller\n * @requires $injector\n * @requires ui.router.state.$uiViewScroll\n * @requires $document\n *\n * @restrict ECA\n *\n * @description\n * The ui-view directive tells $state where to place your templates.\n *\n * @param {string=} name A view name. The name should be unique amongst the other views in the\n * same state. You can have views of the same name that live in different states.\n *\n * @param {string=} autoscroll It allows you to set the scroll behavior of the browser window\n * when a view is populated. By default, $anchorScroll is overridden by ui-router's custom scroll\n * service, {@link ui.router.state.$uiViewScroll}. This custom service let's you\n * scroll ui-view elements into view when they are populated during a state activation.\n *\n * *Note: To revert back to old [`$anchorScroll`](http://docs.angularjs.org/api/ng.$anchorScroll)\n * functionality, call `$uiViewScrollProvider.useAnchorScroll()`.*\n *\n * @param {string=} onload Expression to evaluate whenever the view updates.\n *\n * @example\n * A view can be unnamed or named.\n * <pre>\n * <!-- Unnamed -->\n * <div ui-view></div>\n *\n * <!-- Named -->\n * <div ui-view=\"viewName\"></div>\n * </pre>\n *\n * You can only have one unnamed view within any template (or root html). If you are only using a\n * single view and it is unnamed then you can populate it like so:\n * <pre>\n * <div ui-view></div>\n * $stateProvider.state(\"home\", {\n *   template: \"<h1>HELLO!</h1>\"\n * })\n * </pre>\n *\n * The above is a convenient shortcut equivalent to specifying your view explicitly with the {@link ui.router.state.$stateProvider#methods_state `views`}\n * config property, by name, in this case an empty name:\n * <pre>\n * $stateProvider.state(\"home\", {\n *   views: {\n *     \"\": {\n *       template: \"<h1>HELLO!</h1>\"\n *     }\n *   }    \n * })\n * </pre>\n *\n * But typically you'll only use the views property if you name your view or have more than one view\n * in the same template. There's not really a compelling reason to name a view if its the only one,\n * but you could if you wanted, like so:\n * <pre>\n * <div ui-view=\"main\"></div>\n * </pre>\n * <pre>\n * $stateProvider.state(\"home\", {\n *   views: {\n *     \"main\": {\n *       template: \"<h1>HELLO!</h1>\"\n *     }\n *   }    \n * })\n * </pre>\n *\n * Really though, you'll use views to set up multiple views:\n * <pre>\n * <div ui-view></div>\n * <div ui-view=\"chart\"></div>\n * <div ui-view=\"data\"></div>\n * </pre>\n *\n * <pre>\n * $stateProvider.state(\"home\", {\n *   views: {\n *     \"\": {\n *       template: \"<h1>HELLO!</h1>\"\n *     },\n *     \"chart\": {\n *       template: \"<chart_thing/>\"\n *     },\n *     \"data\": {\n *       template: \"<data_thing/>\"\n *     }\n *   }    \n * })\n * </pre>\n *\n * Examples for `autoscroll`:\n *\n * <pre>\n * <!-- If autoscroll present with no expression,\n *      then scroll ui-view into view -->\n * <ui-view autoscroll/>\n *\n * <!-- If autoscroll present with valid expression,\n *      then scroll ui-view into view if expression evaluates to true -->\n * <ui-view autoscroll='true'/>\n * <ui-view autoscroll='false'/>\n * <ui-view autoscroll='scopeVariable'/>\n * </pre>\n *\n * Resolve data:\n *\n * The resolved data from the state's `resolve` block is placed on the scope as `$resolve` (this\n * can be customized using [[ViewDeclaration.resolveAs]]).  This can be then accessed from the template.\n *\n * Note that when `controllerAs` is being used, `$resolve` is set on the controller instance *after* the\n * controller is instantiated.  The `$onInit()` hook can be used to perform initialization code which\n * depends on `$resolve` data.\n *\n * Example usage of $resolve in a view template\n * <pre>\n * $stateProvider.state('home', {\n *   template: '<my-component user=\"$resolve.user\"></my-component>',\n *   resolve: {\n *     user: function(UserService) { return UserService.fetchUser(); }\n *   }\n * });\n * </pre>\n */\n$ViewDirective.$inject = ['$state', '$injector', '$uiViewScroll', '$interpolate', '$q'];\nfunction $ViewDirective(   $state,   $injector,   $uiViewScroll,   $interpolate,   $q) {\n\n  function getService() {\n    return ($injector.has) ? function(service) {\n      return $injector.has(service) ? $injector.get(service) : null;\n    } : function(service) {\n      try {\n        return $injector.get(service);\n      } catch (e) {\n        return null;\n      }\n    };\n  }\n\n  var service = getService(),\n      $animator = service('$animator'),\n      $animate = service('$animate');\n\n  // Returns a set of DOM manipulation functions based on which Angular version\n  // it should use\n  function getRenderer(attrs, scope) {\n    var statics = function() {\n      return {\n        enter: function (element, target, cb) { target.after(element); cb(); },\n        leave: function (element, cb) { element.remove(); cb(); }\n      };\n    };\n\n    if ($animate) {\n      return {\n        enter: function(element, target, cb) {\n          if (angular.version.minor > 2) {\n            $animate.enter(element, null, target).then(cb);\n          } else {\n            $animate.enter(element, null, target, cb);\n          }\n        },\n        leave: function(element, cb) {\n          if (angular.version.minor > 2) {\n            $animate.leave(element).then(cb);\n          } else {\n            $animate.leave(element, cb);\n          }\n        }\n      };\n    }\n\n    if ($animator) {\n      var animate = $animator && $animator(scope, attrs);\n\n      return {\n        enter: function(element, target, cb) {animate.enter(element, null, target); cb(); },\n        leave: function(element, cb) { animate.leave(element); cb(); }\n      };\n    }\n\n    return statics();\n  }\n\n  var directive = {\n    restrict: 'ECA',\n    terminal: true,\n    priority: 400,\n    transclude: 'element',\n    compile: function (tElement, tAttrs, $transclude) {\n      return function (scope, $element, attrs) {\n        var previousEl, currentEl, currentScope, latestLocals,\n            onloadExp     = attrs.onload || '',\n            autoScrollExp = attrs.autoscroll,\n            renderer      = getRenderer(attrs, scope),\n            inherited     = $element.inheritedData('$uiView');\n\n        scope.$on('$stateChangeSuccess', function() {\n          updateView(false);\n        });\n\n        updateView(true);\n\n        function cleanupLastView() {\n          if (previousEl) {\n            previousEl.remove();\n            previousEl = null;\n          }\n\n          if (currentScope) {\n            currentScope.$destroy();\n            currentScope = null;\n          }\n\n          if (currentEl) {\n            var $uiViewData = currentEl.data('$uiViewAnim');\n            renderer.leave(currentEl, function() {\n              $uiViewData.$$animLeave.resolve();\n              previousEl = null;\n            });\n\n            previousEl = currentEl;\n            currentEl = null;\n          }\n        }\n\n        function updateView(firstTime) {\n          var newScope,\n              name            = getUiViewName(scope, attrs, $element, $interpolate),\n              previousLocals  = name && $state.$current && $state.$current.locals[name];\n\n          if (!firstTime && previousLocals === latestLocals) return; // nothing to do\n          newScope = scope.$new();\n          latestLocals = $state.$current.locals[name];\n\n          /**\n           * @ngdoc event\n           * @name ui.router.state.directive:ui-view#$viewContentLoading\n           * @eventOf ui.router.state.directive:ui-view\n           * @eventType emits on ui-view directive scope\n           * @description\n           *\n           * Fired once the view **begins loading**, *before* the DOM is rendered.\n           *\n           * @param {Object} event Event object.\n           * @param {string} viewName Name of the view.\n           */\n          newScope.$emit('$viewContentLoading', name);\n\n          var clone = $transclude(newScope, function(clone) {\n            var animEnter = $q.defer(), animLeave = $q.defer();\n            var viewAnimData = {\n              $animEnter: animEnter.promise,\n              $animLeave: animLeave.promise,\n              $$animLeave: animLeave\n            };\n\n            clone.data('$uiViewAnim', viewAnimData);\n            renderer.enter(clone, $element, function onUiViewEnter() {\n              animEnter.resolve();\n              if(currentScope) {\n                currentScope.$emit('$viewContentAnimationEnded');\n              }\n\n              if (angular.isDefined(autoScrollExp) && !autoScrollExp || scope.$eval(autoScrollExp)) {\n                $uiViewScroll(clone);\n              }\n            });\n            cleanupLastView();\n          });\n\n          currentEl = clone;\n          currentScope = newScope;\n          /**\n           * @ngdoc event\n           * @name ui.router.state.directive:ui-view#$viewContentLoaded\n           * @eventOf ui.router.state.directive:ui-view\n           * @eventType emits on ui-view directive scope\n           * @description\n           * Fired once the view is **loaded**, *after* the DOM is rendered.\n           *\n           * @param {Object} event Event object.\n           * @param {string} viewName Name of the view.\n           */\n          currentScope.$emit('$viewContentLoaded', name);\n          currentScope.$eval(onloadExp);\n        }\n      };\n    }\n  };\n\n  return directive;\n}\n\n$ViewDirectiveFill.$inject = ['$compile', '$controller', '$state', '$interpolate'];\nfunction $ViewDirectiveFill (  $compile,   $controller,   $state,   $interpolate) {\n  return {\n    restrict: 'ECA',\n    priority: -400,\n    compile: function (tElement) {\n      var initial = tElement.html();\n      return function (scope, $element, attrs) {\n        var current = $state.$current,\n            name = getUiViewName(scope, attrs, $element, $interpolate),\n            locals  = current && current.locals[name];\n\n        if (! locals) {\n          return;\n        }\n\n        $element.data('$uiView', { name: name, state: locals.$$state });\n        $element.html(locals.$template ? locals.$template : initial);\n\n        var resolveData = angular.extend({}, locals);\n        scope[locals.$$resolveAs] = resolveData;\n\n        var link = $compile($element.contents());\n\n        if (locals.$$controller) {\n          locals.$scope = scope;\n          locals.$element = $element;\n          var controller = $controller(locals.$$controller, locals);\n          if (locals.$$controllerAs) {\n            scope[locals.$$controllerAs] = controller;\n            scope[locals.$$controllerAs][locals.$$resolveAs] = resolveData;\n          }\n          if (isFunction(controller.$onInit)) controller.$onInit();\n          $element.data('$ngControllerController', controller);\n          $element.children().data('$ngControllerController', controller);\n        }\n\n        link(scope);\n      };\n    }\n  };\n}\n\n/**\n * Shared ui-view code for both directives:\n * Given scope, element, and its attributes, return the view's name\n */\nfunction getUiViewName(scope, attrs, element, $interpolate) {\n  var name = $interpolate(attrs.uiView || attrs.name || '')(scope);\n  var uiViewCreatedBy = element.inheritedData('$uiView');\n  return name.indexOf('@') >= 0 ?  name :  (name + '@' + (uiViewCreatedBy ? uiViewCreatedBy.state.name : ''));\n}\n\nangular.module('ui.router.state').directive('uiView', $ViewDirective);\nangular.module('ui.router.state').directive('uiView', $ViewDirectiveFill);\n\nfunction parseStateRef(ref, current) {\n  var preparsed = ref.match(/^\\s*({[^}]*})\\s*$/), parsed;\n  if (preparsed) ref = current + '(' + preparsed[1] + ')';\n  parsed = ref.replace(/\\n/g, \" \").match(/^([^(]+?)\\s*(\\((.*)\\))?$/);\n  if (!parsed || parsed.length !== 4) throw new Error(\"Invalid state ref '\" + ref + \"'\");\n  return { state: parsed[1], paramExpr: parsed[3] || null };\n}\n\nfunction stateContext(el) {\n  var stateData = el.parent().inheritedData('$uiView');\n\n  if (stateData && stateData.state && stateData.state.name) {\n    return stateData.state;\n  }\n}\n\nfunction getTypeInfo(el) {\n  // SVGAElement does not use the href attribute, but rather the 'xlinkHref' attribute.\n  var isSvg = Object.prototype.toString.call(el.prop('href')) === '[object SVGAnimatedString]';\n  var isForm = el[0].nodeName === \"FORM\";\n\n  return {\n    attr: isForm ? \"action\" : (isSvg ? 'xlink:href' : 'href'),\n    isAnchor: el.prop(\"tagName\").toUpperCase() === \"A\",\n    clickable: !isForm\n  };\n}\n\nfunction clickHook(el, $state, $timeout, type, current) {\n  return function(e) {\n    var button = e.which || e.button, target = current();\n\n    if (!(button > 1 || e.ctrlKey || e.metaKey || e.shiftKey || el.attr('target'))) {\n      // HACK: This is to allow ng-clicks to be processed before the transition is initiated:\n      var transition = $timeout(function() {\n        $state.go(target.state, target.params, target.options);\n      });\n      e.preventDefault();\n\n      // if the state has no URL, ignore one preventDefault from the <a> directive.\n      var ignorePreventDefaultCount = type.isAnchor && !target.href ? 1: 0;\n\n      e.preventDefault = function() {\n        if (ignorePreventDefaultCount-- <= 0) $timeout.cancel(transition);\n      };\n    }\n  };\n}\n\nfunction defaultOpts(el, $state) {\n  return { relative: stateContext(el) || $state.$current, inherit: true };\n}\n\n/**\n * @ngdoc directive\n * @name ui.router.state.directive:ui-sref\n *\n * @requires ui.router.state.$state\n * @requires $timeout\n *\n * @restrict A\n *\n * @description\n * A directive that binds a link (`<a>` tag) to a state. If the state has an associated\n * URL, the directive will automatically generate & update the `href` attribute via\n * the {@link ui.router.state.$state#methods_href $state.href()} method. Clicking\n * the link will trigger a state transition with optional parameters.\n *\n * Also middle-clicking, right-clicking, and ctrl-clicking on the link will be\n * handled natively by the browser.\n *\n * You can also use relative state paths within ui-sref, just like the relative\n * paths passed to `$state.go()`. You just need to be aware that the path is relative\n * to the state that the link lives in, in other words the state that loaded the\n * template containing the link.\n *\n * You can specify options to pass to {@link ui.router.state.$state#methods_go $state.go()}\n * using the `ui-sref-opts` attribute. Options are restricted to `location`, `inherit`,\n * and `reload`.\n *\n * @example\n * Here's an example of how you'd use ui-sref and how it would compile. If you have the\n * following template:\n * <pre>\n * <a ui-sref=\"home\">Home</a> | <a ui-sref=\"about\">About</a> | <a ui-sref=\"{page: 2}\">Next page</a>\n *\n * <ul>\n *     <li ng-repeat=\"contact in contacts\">\n *         <a ui-sref=\"contacts.detail({ id: contact.id })\">{{ contact.name }}</a>\n *     </li>\n * </ul>\n * </pre>\n *\n * Then the compiled html would be (assuming Html5Mode is off and current state is contacts):\n * <pre>\n * <a href=\"#/home\" ui-sref=\"home\">Home</a> | <a href=\"#/about\" ui-sref=\"about\">About</a> | <a href=\"#/contacts?page=2\" ui-sref=\"{page: 2}\">Next page</a>\n *\n * <ul>\n *     <li ng-repeat=\"contact in contacts\">\n *         <a href=\"#/contacts/1\" ui-sref=\"contacts.detail({ id: contact.id })\">Joe</a>\n *     </li>\n *     <li ng-repeat=\"contact in contacts\">\n *         <a href=\"#/contacts/2\" ui-sref=\"contacts.detail({ id: contact.id })\">Alice</a>\n *     </li>\n *     <li ng-repeat=\"contact in contacts\">\n *         <a href=\"#/contacts/3\" ui-sref=\"contacts.detail({ id: contact.id })\">Bob</a>\n *     </li>\n * </ul>\n *\n * <a ui-sref=\"home\" ui-sref-opts=\"{reload: true}\">Home</a>\n * </pre>\n *\n * @param {string} ui-sref 'stateName' can be any valid absolute or relative state\n * @param {Object} ui-sref-opts options to pass to {@link ui.router.state.$state#methods_go $state.go()}\n */\n$StateRefDirective.$inject = ['$state', '$timeout'];\nfunction $StateRefDirective($state, $timeout) {\n  return {\n    restrict: 'A',\n    require: ['?^uiSrefActive', '?^uiSrefActiveEq'],\n    link: function(scope, element, attrs, uiSrefActive) {\n      var ref    = parseStateRef(attrs.uiSref, $state.current.name);\n      var def    = { state: ref.state, href: null, params: null };\n      var type   = getTypeInfo(element);\n      var active = uiSrefActive[1] || uiSrefActive[0];\n      var unlinkInfoFn = null;\n      var hookFn;\n\n      def.options = extend(defaultOpts(element, $state), attrs.uiSrefOpts ? scope.$eval(attrs.uiSrefOpts) : {});\n\n      var update = function(val) {\n        if (val) def.params = angular.copy(val);\n        def.href = $state.href(ref.state, def.params, def.options);\n\n        if (unlinkInfoFn) unlinkInfoFn();\n        if (active) unlinkInfoFn = active.$$addStateInfo(ref.state, def.params);\n        if (def.href !== null) attrs.$set(type.attr, def.href);\n      };\n\n      if (ref.paramExpr) {\n        scope.$watch(ref.paramExpr, function(val) { if (val !== def.params) update(val); }, true);\n        def.params = angular.copy(scope.$eval(ref.paramExpr));\n      }\n      update();\n\n      if (!type.clickable) return;\n      hookFn = clickHook(element, $state, $timeout, type, function() { return def; });\n      element.bind(\"click\", hookFn);\n      scope.$on('$destroy', function() {\n        element.unbind(\"click\", hookFn);\n      });\n    }\n  };\n}\n\n/**\n * @ngdoc directive\n * @name ui.router.state.directive:ui-state\n *\n * @requires ui.router.state.uiSref\n *\n * @restrict A\n *\n * @description\n * Much like ui-sref, but will accept named $scope properties to evaluate for a state definition,\n * params and override options.\n *\n * @param {string} ui-state 'stateName' can be any valid absolute or relative state\n * @param {Object} ui-state-params params to pass to {@link ui.router.state.$state#methods_href $state.href()}\n * @param {Object} ui-state-opts options to pass to {@link ui.router.state.$state#methods_go $state.go()}\n */\n$StateRefDynamicDirective.$inject = ['$state', '$timeout'];\nfunction $StateRefDynamicDirective($state, $timeout) {\n  return {\n    restrict: 'A',\n    require: ['?^uiSrefActive', '?^uiSrefActiveEq'],\n    link: function(scope, element, attrs, uiSrefActive) {\n      var type   = getTypeInfo(element);\n      var active = uiSrefActive[1] || uiSrefActive[0];\n      var group  = [attrs.uiState, attrs.uiStateParams || null, attrs.uiStateOpts || null];\n      var watch  = '[' + group.map(function(val) { return val || 'null'; }).join(', ') + ']';\n      var def    = { state: null, params: null, options: null, href: null };\n      var unlinkInfoFn = null;\n      var hookFn;\n\n      function runStateRefLink (group) {\n        def.state = group[0]; def.params = group[1]; def.options = group[2];\n        def.href = $state.href(def.state, def.params, def.options);\n\n        if (unlinkInfoFn) unlinkInfoFn();\n        if (active) unlinkInfoFn = active.$$addStateInfo(def.state, def.params);\n        if (def.href) attrs.$set(type.attr, def.href);\n      }\n\n      scope.$watch(watch, runStateRefLink, true);\n      runStateRefLink(scope.$eval(watch));\n\n      if (!type.clickable) return;\n      hookFn = clickHook(element, $state, $timeout, type, function() { return def; });\n      element.bind(\"click\", hookFn);\n      scope.$on('$destroy', function() {\n        element.unbind(\"click\", hookFn);\n      });\n    }\n  };\n}\n\n\n/**\n * @ngdoc directive\n * @name ui.router.state.directive:ui-sref-active\n *\n * @requires ui.router.state.$state\n * @requires ui.router.state.$stateParams\n * @requires $interpolate\n *\n * @restrict A\n *\n * @description\n * A directive working alongside ui-sref to add classes to an element when the\n * related ui-sref directive's state is active, and removing them when it is inactive.\n * The primary use-case is to simplify the special appearance of navigation menus\n * relying on `ui-sref`, by having the \"active\" state's menu button appear different,\n * distinguishing it from the inactive menu items.\n *\n * ui-sref-active can live on the same element as ui-sref or on a parent element. The first\n * ui-sref-active found at the same level or above the ui-sref will be used.\n *\n * Will activate when the ui-sref's target state or any child state is active. If you\n * need to activate only when the ui-sref target state is active and *not* any of\n * it's children, then you will use\n * {@link ui.router.state.directive:ui-sref-active-eq ui-sref-active-eq}\n *\n * @example\n * Given the following template:\n * <pre>\n * <ul>\n *   <li ui-sref-active=\"active\" class=\"item\">\n *     <a href ui-sref=\"app.user({user: 'bilbobaggins'})\">@bilbobaggins</a>\n *   </li>\n * </ul>\n * </pre>\n *\n *\n * When the app state is \"app.user\" (or any children states), and contains the state parameter \"user\" with value \"bilbobaggins\",\n * the resulting HTML will appear as (note the 'active' class):\n * <pre>\n * <ul>\n *   <li ui-sref-active=\"active\" class=\"item active\">\n *     <a ui-sref=\"app.user({user: 'bilbobaggins'})\" href=\"/users/bilbobaggins\">@bilbobaggins</a>\n *   </li>\n * </ul>\n * </pre>\n *\n * The class name is interpolated **once** during the directives link time (any further changes to the\n * interpolated value are ignored).\n *\n * Multiple classes may be specified in a space-separated format:\n * <pre>\n * <ul>\n *   <li ui-sref-active='class1 class2 class3'>\n *     <a ui-sref=\"app.user\">link</a>\n *   </li>\n * </ul>\n * </pre>\n *\n * It is also possible to pass ui-sref-active an expression that evaluates\n * to an object hash, whose keys represent active class names and whose\n * values represent the respective state names/globs.\n * ui-sref-active will match if the current active state **includes** any of\n * the specified state names/globs, even the abstract ones.\n *\n * @Example\n * Given the following template, with \"admin\" being an abstract state:\n * <pre>\n * <div ui-sref-active=\"{'active': 'admin.*'}\">\n *   <a ui-sref-active=\"active\" ui-sref=\"admin.roles\">Roles</a>\n * </div>\n * </pre>\n *\n * When the current state is \"admin.roles\" the \"active\" class will be applied\n * to both the <div> and <a> elements. It is important to note that the state\n * names/globs passed to ui-sref-active shadow the state provided by ui-sref.\n */\n\n/**\n * @ngdoc directive\n * @name ui.router.state.directive:ui-sref-active-eq\n *\n * @requires ui.router.state.$state\n * @requires ui.router.state.$stateParams\n * @requires $interpolate\n *\n * @restrict A\n *\n * @description\n * The same as {@link ui.router.state.directive:ui-sref-active ui-sref-active} but will only activate\n * when the exact target state used in the `ui-sref` is active; no child states.\n *\n */\n$StateRefActiveDirective.$inject = ['$state', '$stateParams', '$interpolate'];\nfunction $StateRefActiveDirective($state, $stateParams, $interpolate) {\n  return  {\n    restrict: \"A\",\n    controller: ['$scope', '$element', '$attrs', '$timeout', function ($scope, $element, $attrs, $timeout) {\n      var states = [], activeClasses = {}, activeEqClass, uiSrefActive;\n\n      // There probably isn't much point in $observing this\n      // uiSrefActive and uiSrefActiveEq share the same directive object with some\n      // slight difference in logic routing\n      activeEqClass = $interpolate($attrs.uiSrefActiveEq || '', false)($scope);\n\n      try {\n        uiSrefActive = $scope.$eval($attrs.uiSrefActive);\n      } catch (e) {\n        // Do nothing. uiSrefActive is not a valid expression.\n        // Fall back to using $interpolate below\n      }\n      uiSrefActive = uiSrefActive || $interpolate($attrs.uiSrefActive || '', false)($scope);\n      if (isObject(uiSrefActive)) {\n        forEach(uiSrefActive, function(stateOrName, activeClass) {\n          if (isString(stateOrName)) {\n            var ref = parseStateRef(stateOrName, $state.current.name);\n            addState(ref.state, $scope.$eval(ref.paramExpr), activeClass);\n          }\n        });\n      }\n\n      // Allow uiSref to communicate with uiSrefActive[Equals]\n      this.$$addStateInfo = function (newState, newParams) {\n        // we already got an explicit state provided by ui-sref-active, so we\n        // shadow the one that comes from ui-sref\n        if (isObject(uiSrefActive) && states.length > 0) {\n          return;\n        }\n        var deregister = addState(newState, newParams, uiSrefActive);\n        update();\n        return deregister;\n      };\n\n      $scope.$on('$stateChangeSuccess', update);\n\n      function addState(stateName, stateParams, activeClass) {\n        var state = $state.get(stateName, stateContext($element));\n        var stateHash = createStateHash(stateName, stateParams);\n\n        var stateInfo = {\n          state: state || { name: stateName },\n          params: stateParams,\n          hash: stateHash\n        };\n\n        states.push(stateInfo);\n        activeClasses[stateHash] = activeClass;\n\n        return function removeState() {\n          var idx = states.indexOf(stateInfo);\n          if (idx !== -1) states.splice(idx, 1);\n        };\n      }\n\n      /**\n       * @param {string} state\n       * @param {Object|string} [params]\n       * @return {string}\n       */\n      function createStateHash(state, params) {\n        if (!isString(state)) {\n          throw new Error('state should be a string');\n        }\n        if (isObject(params)) {\n          return state + toJson(params);\n        }\n        params = $scope.$eval(params);\n        if (isObject(params)) {\n          return state + toJson(params);\n        }\n        return state;\n      }\n\n      // Update route state\n      function update() {\n        for (var i = 0; i < states.length; i++) {\n          if (anyMatch(states[i].state, states[i].params)) {\n            addClass($element, activeClasses[states[i].hash]);\n          } else {\n            removeClass($element, activeClasses[states[i].hash]);\n          }\n\n          if (exactMatch(states[i].state, states[i].params)) {\n            addClass($element, activeEqClass);\n          } else {\n            removeClass($element, activeEqClass);\n          }\n        }\n      }\n\n      function addClass(el, className) { $timeout(function () { el.addClass(className); }); }\n      function removeClass(el, className) { el.removeClass(className); }\n      function anyMatch(state, params) { return $state.includes(state.name, params); }\n      function exactMatch(state, params) { return $state.is(state.name, params); }\n\n      update();\n    }]\n  };\n}\n\nangular.module('ui.router.state')\n  .directive('uiSref', $StateRefDirective)\n  .directive('uiSrefActive', $StateRefActiveDirective)\n  .directive('uiSrefActiveEq', $StateRefActiveDirective)\n  .directive('uiState', $StateRefDynamicDirective);\n\n/**\n * @ngdoc filter\n * @name ui.router.state.filter:isState\n *\n * @requires ui.router.state.$state\n *\n * @description\n * Translates to {@link ui.router.state.$state#methods_is $state.is(\"stateName\")}.\n */\n$IsStateFilter.$inject = ['$state'];\nfunction $IsStateFilter($state) {\n  var isFilter = function (state, params) {\n    return $state.is(state, params);\n  };\n  isFilter.$stateful = true;\n  return isFilter;\n}\n\n/**\n * @ngdoc filter\n * @name ui.router.state.filter:includedByState\n *\n * @requires ui.router.state.$state\n *\n * @description\n * Translates to {@link ui.router.state.$state#methods_includes $state.includes('fullOrPartialStateName')}.\n */\n$IncludedByStateFilter.$inject = ['$state'];\nfunction $IncludedByStateFilter($state) {\n  var includesFilter = function (state, params, options) {\n    return $state.includes(state, params, options);\n  };\n  includesFilter.$stateful = true;\n  return  includesFilter;\n}\n\nangular.module('ui.router.state')\n  .filter('isState', $IsStateFilter)\n  .filter('includedByState', $IncludedByStateFilter);\n})(window, window.angular);\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/angular-ui-router/release/angular-ui-router.js\n ** module id = 7\n ** module chunks = 2\n **/","/*!\n * angular-translate - v2.11.1 - 2016-07-17\n * \n * Copyright (c) 2016 The angular-translate team, Pascal Precht; Licensed MIT\n */\n(function (root, factory) {\n  if (typeof define === 'function' && define.amd) {\n    // AMD. Register as an anonymous module unless amdModuleId is set\n    define([], function () {\n      return (factory());\n    });\n  } else if (typeof exports === 'object') {\n    // Node. Does not work with strict CommonJS, but\n    // only CommonJS-like environments that support module.exports,\n    // like Node.\n    module.exports = factory();\n  } else {\n    factory();\n  }\n}(this, function () {\n\n/**\n * @ngdoc overview\n * @name pascalprecht.translate\n *\n * @description\n * The main module which holds everything together.\n */\nrunTranslate.$inject = ['$translate'];\n$translate.$inject = ['$STORAGE_KEY', '$windowProvider', '$translateSanitizationProvider', 'pascalprechtTranslateOverrider'];\n$translateDefaultInterpolation.$inject = ['$interpolate', '$translateSanitization'];\ntranslateDirective.$inject = ['$translate', '$q', '$interpolate', '$compile', '$parse', '$rootScope'];\ntranslateCloakDirective.$inject = ['$translate', '$rootScope'];\ntranslateFilterFactory.$inject = ['$parse', '$translate'];\n$translationCache.$inject = ['$cacheFactory'];\nangular.module('pascalprecht.translate', ['ng'])\n  .run(runTranslate);\n\nfunction runTranslate($translate) {\n\n  'use strict';\n\n  var key = $translate.storageKey(),\n    storage = $translate.storage();\n\n  var fallbackFromIncorrectStorageValue = function () {\n    var preferred = $translate.preferredLanguage();\n    if (angular.isString(preferred)) {\n      $translate.use(preferred);\n      // $translate.use() will also remember the language.\n      // So, we don't need to call storage.put() here.\n    } else {\n      storage.put(key, $translate.use());\n    }\n  };\n\n  fallbackFromIncorrectStorageValue.displayName = 'fallbackFromIncorrectStorageValue';\n\n  if (storage) {\n    if (!storage.get(key)) {\n      fallbackFromIncorrectStorageValue();\n    } else {\n      $translate.use(storage.get(key))['catch'](fallbackFromIncorrectStorageValue);\n    }\n  } else if (angular.isString($translate.preferredLanguage())) {\n    $translate.use($translate.preferredLanguage());\n  }\n}\n\nrunTranslate.displayName = 'runTranslate';\n\n/**\n * @ngdoc object\n * @name pascalprecht.translate.$translateSanitizationProvider\n *\n * @description\n *\n * Configurations for $translateSanitization\n */\nangular.module('pascalprecht.translate').provider('$translateSanitization', $translateSanitizationProvider);\n\nfunction $translateSanitizationProvider () {\n\n  'use strict';\n\n  var $sanitize,\n      currentStrategy = null, // TODO change to either 'sanitize', 'escape' or ['sanitize', 'escapeParameters'] in 3.0.\n      hasConfiguredStrategy = false,\n      hasShownNoStrategyConfiguredWarning = false,\n      strategies;\n\n  /**\n   * Definition of a sanitization strategy function\n   * @callback StrategyFunction\n   * @param {string|object} value - value to be sanitized (either a string or an interpolated value map)\n   * @param {string} mode - either 'text' for a string (translation) or 'params' for the interpolated params\n   * @return {string|object}\n   */\n\n  /**\n   * @ngdoc property\n   * @name strategies\n   * @propertyOf pascalprecht.translate.$translateSanitizationProvider\n   *\n   * @description\n   * Following strategies are built-in:\n   * <dl>\n   *   <dt>sanitize</dt>\n   *   <dd>Sanitizes HTML in the translation text using $sanitize</dd>\n   *   <dt>escape</dt>\n   *   <dd>Escapes HTML in the translation</dd>\n   *   <dt>sanitizeParameters</dt>\n   *   <dd>Sanitizes HTML in the values of the interpolation parameters using $sanitize</dd>\n   *   <dt>escapeParameters</dt>\n   *   <dd>Escapes HTML in the values of the interpolation parameters</dd>\n   *   <dt>escaped</dt>\n   *   <dd>Support legacy strategy name 'escaped' for backwards compatibility (will be removed in 3.0)</dd>\n   * </dl>\n   *\n   */\n\n  strategies = {\n    sanitize: function (value, mode) {\n      if (mode === 'text') {\n        value = htmlSanitizeValue(value);\n      }\n      return value;\n    },\n    escape: function (value, mode) {\n      if (mode === 'text') {\n        value = htmlEscapeValue(value);\n      }\n      return value;\n    },\n    sanitizeParameters: function (value, mode) {\n      if (mode === 'params') {\n        value = mapInterpolationParameters(value, htmlSanitizeValue);\n      }\n      return value;\n    },\n    escapeParameters: function (value, mode) {\n      if (mode === 'params') {\n        value = mapInterpolationParameters(value, htmlEscapeValue);\n      }\n      return value;\n    }\n  };\n  // Support legacy strategy name 'escaped' for backwards compatibility.\n  // TODO should be removed in 3.0\n  strategies.escaped = strategies.escapeParameters;\n\n  /**\n   * @ngdoc function\n   * @name pascalprecht.translate.$translateSanitizationProvider#addStrategy\n   * @methodOf pascalprecht.translate.$translateSanitizationProvider\n   *\n   * @description\n   * Adds a sanitization strategy to the list of known strategies.\n   *\n   * @param {string} strategyName - unique key for a strategy\n   * @param {StrategyFunction} strategyFunction - strategy function\n   * @returns {object} this\n   */\n  this.addStrategy = function (strategyName, strategyFunction) {\n    strategies[strategyName] = strategyFunction;\n    return this;\n  };\n\n  /**\n   * @ngdoc function\n   * @name pascalprecht.translate.$translateSanitizationProvider#removeStrategy\n   * @methodOf pascalprecht.translate.$translateSanitizationProvider\n   *\n   * @description\n   * Removes a sanitization strategy from the list of known strategies.\n   *\n   * @param {string} strategyName - unique key for a strategy\n   * @returns {object} this\n   */\n  this.removeStrategy = function (strategyName) {\n    delete strategies[strategyName];\n    return this;\n  };\n\n  /**\n   * @ngdoc function\n   * @name pascalprecht.translate.$translateSanitizationProvider#useStrategy\n   * @methodOf pascalprecht.translate.$translateSanitizationProvider\n   *\n   * @description\n   * Selects a sanitization strategy. When an array is provided the strategies will be executed in order.\n   *\n   * @param {string|StrategyFunction|array} strategy The sanitization strategy / strategies which should be used. Either a name of an existing strategy, a custom strategy function, or an array consisting of multiple names and / or custom functions.\n   * @returns {object} this\n   */\n  this.useStrategy = function (strategy) {\n    hasConfiguredStrategy = true;\n    currentStrategy = strategy;\n    return this;\n  };\n\n  /**\n   * @ngdoc object\n   * @name pascalprecht.translate.$translateSanitization\n   * @requires $injector\n   * @requires $log\n   *\n   * @description\n   * Sanitizes interpolation parameters and translated texts.\n   *\n   */\n  this.$get = ['$injector', '$log', function ($injector, $log) {\n\n    var cachedStrategyMap = {};\n\n    var applyStrategies = function (value, mode, selectedStrategies) {\n      angular.forEach(selectedStrategies, function (selectedStrategy) {\n        if (angular.isFunction(selectedStrategy)) {\n          value = selectedStrategy(value, mode);\n        } else if (angular.isFunction(strategies[selectedStrategy])) {\n          value = strategies[selectedStrategy](value, mode);\n        } else if (angular.isString(strategies[selectedStrategy])) {\n          if (!cachedStrategyMap[strategies[selectedStrategy]]) {\n            try {\n              cachedStrategyMap[strategies[selectedStrategy]] = $injector.get(strategies[selectedStrategy]);\n            } catch (e) {\n              cachedStrategyMap[strategies[selectedStrategy]] = function() {};\n              throw new Error('pascalprecht.translate.$translateSanitization: Unknown sanitization strategy: \\'' + selectedStrategy + '\\'');\n            }\n          }\n          value = cachedStrategyMap[strategies[selectedStrategy]](value, mode);\n        } else {\n          throw new Error('pascalprecht.translate.$translateSanitization: Unknown sanitization strategy: \\'' + selectedStrategy + '\\'');\n        }\n      });\n      return value;\n    };\n\n    // TODO: should be removed in 3.0\n    var showNoStrategyConfiguredWarning = function () {\n      if (!hasConfiguredStrategy && !hasShownNoStrategyConfiguredWarning) {\n        $log.warn('pascalprecht.translate.$translateSanitization: No sanitization strategy has been configured. This can have serious security implications. See http://angular-translate.github.io/docs/#/guide/19_security for details.');\n        hasShownNoStrategyConfiguredWarning = true;\n      }\n    };\n\n    if ($injector.has('$sanitize')) {\n      $sanitize = $injector.get('$sanitize');\n    }\n\n    return {\n      /**\n       * @ngdoc function\n       * @name pascalprecht.translate.$translateSanitization#useStrategy\n       * @methodOf pascalprecht.translate.$translateSanitization\n       *\n       * @description\n       * Selects a sanitization strategy. When an array is provided the strategies will be executed in order.\n       *\n       * @param {string|StrategyFunction|array} strategy The sanitization strategy / strategies which should be used. Either a name of an existing strategy, a custom strategy function, or an array consisting of multiple names and / or custom functions.\n       */\n      useStrategy: (function (self) {\n        return function (strategy) {\n          self.useStrategy(strategy);\n        };\n      })(this),\n\n      /**\n       * @ngdoc function\n       * @name pascalprecht.translate.$translateSanitization#sanitize\n       * @methodOf pascalprecht.translate.$translateSanitization\n       *\n       * @description\n       * Sanitizes a value.\n       *\n       * @param {string|object} value The value which should be sanitized.\n       * @param {string} mode The current sanitization mode, either 'params' or 'text'.\n       * @param {string|StrategyFunction|array} [strategy] Optional custom strategy which should be used instead of the currently selected strategy.\n       * @returns {string|object} sanitized value\n       */\n      sanitize: function (value, mode, strategy) {\n        if (!currentStrategy) {\n          showNoStrategyConfiguredWarning();\n        }\n\n        if (arguments.length < 3) {\n          strategy = currentStrategy;\n        }\n\n        if (!strategy) {\n          return value;\n        }\n\n        var selectedStrategies = angular.isArray(strategy) ? strategy : [strategy];\n        return applyStrategies(value, mode, selectedStrategies);\n      }\n    };\n  }];\n\n  var htmlEscapeValue = function (value) {\n    var element = angular.element('<div></div>');\n    element.text(value); // not chainable, see #1044\n    return element.html();\n  };\n\n  var htmlSanitizeValue = function (value) {\n    if (!$sanitize) {\n      throw new Error('pascalprecht.translate.$translateSanitization: Error cannot find $sanitize service. Either include the ngSanitize module (https://docs.angularjs.org/api/ngSanitize) or use a sanitization strategy which does not depend on $sanitize, such as \\'escape\\'.');\n    }\n    return $sanitize(value);\n  };\n\n  var mapInterpolationParameters = function (value, iteratee, stack) {\n    if (angular.isObject(value)) {\n      var result = angular.isArray(value) ? [] : {};\n\n      if (!stack) {\n        stack = [];\n      } else {\n        if (stack.indexOf(value) > -1) {\n          throw new Error('pascalprecht.translate.$translateSanitization: Error cannot interpolate parameter due recursive object');\n        }\n      }\n\n      stack.push(value);\n      angular.forEach(value, function (propertyValue, propertyKey) {\n\n        /* Skipping function properties. */\n        if (angular.isFunction(propertyValue)) {\n          return;\n        }\n\n        result[propertyKey] = mapInterpolationParameters(propertyValue, iteratee, stack);\n      });\n      stack.splice(-1, 1); // remove last\n\n      return result;\n    } else if (angular.isNumber(value)) {\n      return value;\n    } else {\n      return iteratee(value);\n    }\n  };\n}\n\n/**\n * @ngdoc object\n * @name pascalprecht.translate.$translateProvider\n * @description\n *\n * $translateProvider allows developers to register translation-tables, asynchronous loaders\n * and similar to configure translation behavior directly inside of a module.\n *\n */\nangular.module('pascalprecht.translate')\n.constant('pascalprechtTranslateOverrider', {})\n.provider('$translate', $translate);\n\nfunction $translate($STORAGE_KEY, $windowProvider, $translateSanitizationProvider, pascalprechtTranslateOverrider) {\n\n  'use strict';\n\n  var $translationTable = {},\n      $preferredLanguage,\n      $availableLanguageKeys = [],\n      $languageKeyAliases,\n      $fallbackLanguage,\n      $fallbackWasString,\n      $uses,\n      $nextLang,\n      $storageFactory,\n      $storageKey = $STORAGE_KEY,\n      $storagePrefix,\n      $missingTranslationHandlerFactory,\n      $interpolationFactory,\n      $interpolatorFactories = [],\n      $loaderFactory,\n      $cloakClassName = 'translate-cloak',\n      $loaderOptions,\n      $notFoundIndicatorLeft,\n      $notFoundIndicatorRight,\n      $postCompilingEnabled = false,\n      $forceAsyncReloadEnabled = false,\n      $nestedObjectDelimeter = '.',\n      $isReady = false,\n      $keepContent = false,\n      loaderCache,\n      directivePriority = 0,\n      statefulFilter = true,\n      postProcessFn,\n      uniformLanguageTagResolver = 'default',\n      languageTagResolver = {\n        'default': function (tag) {\n          return (tag || '').split('-').join('_');\n        },\n        java: function (tag) {\n          var temp = (tag || '').split('-').join('_');\n          var parts = temp.split('_');\n          return parts.length > 1 ? (parts[0].toLowerCase() + '_' + parts[1].toUpperCase()) : temp;\n        },\n        bcp47: function (tag) {\n          var temp = (tag || '').split('_').join('-');\n          var parts = temp.split('-');\n          return parts.length > 1 ? (parts[0].toLowerCase() + '-' + parts[1].toUpperCase()) : temp;\n        },\n        'iso639-1': function (tag) {\n          var temp = (tag || '').split('_').join('-');\n          var parts = temp.split('-');\n          return parts[0].toLowerCase();\n        }\n      };\n\n  var version = '2.11.1';\n\n  // tries to determine the browsers language\n  var getFirstBrowserLanguage = function () {\n\n    // internal purpose only\n    if (angular.isFunction(pascalprechtTranslateOverrider.getLocale)) {\n      return pascalprechtTranslateOverrider.getLocale();\n    }\n\n    var nav = $windowProvider.$get().navigator,\n        browserLanguagePropertyKeys = ['language', 'browserLanguage', 'systemLanguage', 'userLanguage'],\n        i,\n        language;\n\n    // support for HTML 5.1 \"navigator.languages\"\n    if (angular.isArray(nav.languages)) {\n      for (i = 0; i < nav.languages.length; i++) {\n        language = nav.languages[i];\n        if (language && language.length) {\n          return language;\n        }\n      }\n    }\n\n    // support for other well known properties in browsers\n    for (i = 0; i < browserLanguagePropertyKeys.length; i++) {\n      language = nav[browserLanguagePropertyKeys[i]];\n      if (language && language.length) {\n        return language;\n      }\n    }\n\n    return null;\n  };\n  getFirstBrowserLanguage.displayName = 'angular-translate/service: getFirstBrowserLanguage';\n\n  // tries to determine the browsers locale\n  var getLocale = function () {\n    var locale = getFirstBrowserLanguage() || '';\n    if (languageTagResolver[uniformLanguageTagResolver]) {\n      locale = languageTagResolver[uniformLanguageTagResolver](locale);\n    }\n    return locale;\n  };\n  getLocale.displayName = 'angular-translate/service: getLocale';\n\n  /**\n   * @name indexOf\n   * @private\n   *\n   * @description\n   * indexOf polyfill. Kinda sorta.\n   *\n   * @param {array} array Array to search in.\n   * @param {string} searchElement Element to search for.\n   *\n   * @returns {int} Index of search element.\n   */\n  var indexOf = function(array, searchElement) {\n    for (var i = 0, len = array.length; i < len; i++) {\n      if (array[i] === searchElement) {\n        return i;\n      }\n    }\n    return -1;\n  };\n\n  /**\n   * @name trim\n   * @private\n   *\n   * @description\n   * trim polyfill\n   *\n   * @returns {string} The string stripped of whitespace from both ends\n   */\n  var trim = function() {\n    return this.toString().replace(/^\\s+|\\s+$/g, '');\n  };\n\n  var negotiateLocale = function (preferred) {\n    if(!preferred) {\n      return;\n    }\n\n    var avail = [],\n        locale = angular.lowercase(preferred),\n        i = 0,\n        n = $availableLanguageKeys.length;\n\n    for (; i < n; i++) {\n      avail.push(angular.lowercase($availableLanguageKeys[i]));\n    }\n\n    // Check for an exact match in our list of available keys\n    if (indexOf(avail, locale) > -1) {\n      return preferred;\n    }\n\n    if ($languageKeyAliases) {\n      var alias;\n      for (var langKeyAlias in $languageKeyAliases) {\n        if ($languageKeyAliases.hasOwnProperty(langKeyAlias)) {\n          var hasWildcardKey = false;\n          var hasExactKey = Object.prototype.hasOwnProperty.call($languageKeyAliases, langKeyAlias) &&\n            angular.lowercase(langKeyAlias) === angular.lowercase(preferred);\n\n          if (langKeyAlias.slice(-1) === '*') {\n            hasWildcardKey = langKeyAlias.slice(0, -1) === preferred.slice(0, langKeyAlias.length - 1);\n          }\n          if (hasExactKey || hasWildcardKey) {\n            alias = $languageKeyAliases[langKeyAlias];\n            if (indexOf(avail, angular.lowercase(alias)) > -1) {\n              return alias;\n            }\n          }\n        }\n      }\n    }\n\n    // Check for a language code without region\n    var parts = preferred.split('_');\n\n    if (parts.length > 1 && indexOf(avail, angular.lowercase(parts[0])) > -1) {\n      return parts[0];\n    }\n\n    // If everything fails, return undefined.\n    return;\n  };\n\n  /**\n   * @ngdoc function\n   * @name pascalprecht.translate.$translateProvider#translations\n   * @methodOf pascalprecht.translate.$translateProvider\n   *\n   * @description\n   * Registers a new translation table for specific language key.\n   *\n   * To register a translation table for specific language, pass a defined language\n   * key as first parameter.\n   *\n   * <pre>\n   *  // register translation table for language: 'de_DE'\n   *  $translateProvider.translations('de_DE', {\n   *    'GREETING': 'Hallo Welt!'\n   *  });\n   *\n   *  // register another one\n   *  $translateProvider.translations('en_US', {\n   *    'GREETING': 'Hello world!'\n   *  });\n   * </pre>\n   *\n   * When registering multiple translation tables for for the same language key,\n   * the actual translation table gets extended. This allows you to define module\n   * specific translation which only get added, once a specific module is loaded in\n   * your app.\n   *\n   * Invoking this method with no arguments returns the translation table which was\n   * registered with no language key. Invoking it with a language key returns the\n   * related translation table.\n   *\n   * @param {string} langKey A language key.\n   * @param {object} translationTable A plain old JavaScript object that represents a translation table.\n   *\n   */\n  var translations = function (langKey, translationTable) {\n\n    if (!langKey && !translationTable) {\n      return $translationTable;\n    }\n\n    if (langKey && !translationTable) {\n      if (angular.isString(langKey)) {\n        return $translationTable[langKey];\n      }\n    } else {\n      if (!angular.isObject($translationTable[langKey])) {\n        $translationTable[langKey] = {};\n      }\n      angular.extend($translationTable[langKey], flatObject(translationTable));\n    }\n    return this;\n  };\n\n  this.translations = translations;\n\n  /**\n   * @ngdoc function\n   * @name pascalprecht.translate.$translateProvider#cloakClassName\n   * @methodOf pascalprecht.translate.$translateProvider\n   *\n   * @description\n   *\n   * Let's you change the class name for `translate-cloak` directive.\n   * Default class name is `translate-cloak`.\n   *\n   * @param {string} name translate-cloak class name\n   */\n  this.cloakClassName = function (name) {\n    if (!name) {\n      return $cloakClassName;\n    }\n    $cloakClassName = name;\n    return this;\n  };\n\n  /**\n   * @ngdoc function\n   * @name pascalprecht.translate.$translateProvider#nestedObjectDelimeter\n   * @methodOf pascalprecht.translate.$translateProvider\n   *\n   * @description\n   *\n   * Let's you change the delimiter for namespaced translations.\n   * Default delimiter is `.`.\n   *\n   * @param {string} delimiter namespace separator\n   */\n  this.nestedObjectDelimeter = function (delimiter) {\n    if (!delimiter) {\n      return $nestedObjectDelimeter;\n    }\n    $nestedObjectDelimeter = delimiter;\n    return this;\n  };\n\n  /**\n   * @name flatObject\n   * @private\n   *\n   * @description\n   * Flats an object. This function is used to flatten given translation data with\n   * namespaces, so they are later accessible via dot notation.\n   */\n  var flatObject = function (data, path, result, prevKey) {\n    var key, keyWithPath, keyWithShortPath, val;\n\n    if (!path) {\n      path = [];\n    }\n    if (!result) {\n      result = {};\n    }\n    for (key in data) {\n      if (!Object.prototype.hasOwnProperty.call(data, key)) {\n        continue;\n      }\n      val = data[key];\n      if (angular.isObject(val)) {\n        flatObject(val, path.concat(key), result, key);\n      } else {\n        keyWithPath = path.length ? ('' + path.join($nestedObjectDelimeter) + $nestedObjectDelimeter + key) : key;\n        if(path.length && key === prevKey){\n          // Create shortcut path (foo.bar == foo.bar.bar)\n          keyWithShortPath = '' + path.join($nestedObjectDelimeter);\n          // Link it to original path\n          result[keyWithShortPath] = '@:' + keyWithPath;\n        }\n        result[keyWithPath] = val;\n      }\n    }\n    return result;\n  };\n  flatObject.displayName = 'flatObject';\n\n  /**\n   * @ngdoc function\n   * @name pascalprecht.translate.$translateProvider#addInterpolation\n   * @methodOf pascalprecht.translate.$translateProvider\n   *\n   * @description\n   * Adds interpolation services to angular-translate, so it can manage them.\n   *\n   * @param {object} factory Interpolation service factory\n   */\n  this.addInterpolation = function (factory) {\n    $interpolatorFactories.push(factory);\n    return this;\n  };\n\n  /**\n   * @ngdoc function\n   * @name pascalprecht.translate.$translateProvider#useMessageFormatInterpolation\n   * @methodOf pascalprecht.translate.$translateProvider\n   *\n   * @description\n   * Tells angular-translate to use interpolation functionality of messageformat.js.\n   * This is useful when having high level pluralization and gender selection.\n   */\n  this.useMessageFormatInterpolation = function () {\n    return this.useInterpolation('$translateMessageFormatInterpolation');\n  };\n\n  /**\n   * @ngdoc function\n   * @name pascalprecht.translate.$translateProvider#useInterpolation\n   * @methodOf pascalprecht.translate.$translateProvider\n   *\n   * @description\n   * Tells angular-translate which interpolation style to use as default, application-wide.\n   * Simply pass a factory/service name. The interpolation service has to implement\n   * the correct interface.\n   *\n   * @param {string} factory Interpolation service name.\n   */\n  this.useInterpolation = function (factory) {\n    $interpolationFactory = factory;\n    return this;\n  };\n\n  /**\n   * @ngdoc function\n   * @name pascalprecht.translate.$translateProvider#useSanitizeStrategy\n   * @methodOf pascalprecht.translate.$translateProvider\n   *\n   * @description\n   * Simply sets a sanitation strategy type.\n   *\n   * @param {string} value Strategy type.\n   */\n  this.useSanitizeValueStrategy = function (value) {\n    $translateSanitizationProvider.useStrategy(value);\n    return this;\n  };\n\n /**\n   * @ngdoc function\n   * @name pascalprecht.translate.$translateProvider#preferredLanguage\n   * @methodOf pascalprecht.translate.$translateProvider\n   *\n   * @description\n   * Tells the module which of the registered translation tables to use for translation\n   * at initial startup by passing a language key. Similar to `$translateProvider#use`\n   * only that it says which language to **prefer**.\n   *\n   * @param {string} langKey A language key.\n   */\n  this.preferredLanguage = function(langKey) {\n    if (langKey) {\n      setupPreferredLanguage(langKey);\n      return this;\n    }\n    return $preferredLanguage;\n  };\n  var setupPreferredLanguage = function (langKey) {\n    if (langKey) {\n      $preferredLanguage = langKey;\n    }\n    return $preferredLanguage;\n  };\n  /**\n   * @ngdoc function\n   * @name pascalprecht.translate.$translateProvider#translationNotFoundIndicator\n   * @methodOf pascalprecht.translate.$translateProvider\n   *\n   * @description\n   * Sets an indicator which is used when a translation isn't found. E.g. when\n   * setting the indicator as 'X' and one tries to translate a translation id\n   * called `NOT_FOUND`, this will result in `X NOT_FOUND X`.\n   *\n   * Internally this methods sets a left indicator and a right indicator using\n   * `$translateProvider.translationNotFoundIndicatorLeft()` and\n   * `$translateProvider.translationNotFoundIndicatorRight()`.\n   *\n   * **Note**: These methods automatically add a whitespace between the indicators\n   * and the translation id.\n   *\n   * @param {string} indicator An indicator, could be any string.\n   */\n  this.translationNotFoundIndicator = function (indicator) {\n    this.translationNotFoundIndicatorLeft(indicator);\n    this.translationNotFoundIndicatorRight(indicator);\n    return this;\n  };\n\n  /**\n   * ngdoc function\n   * @name pascalprecht.translate.$translateProvider#translationNotFoundIndicatorLeft\n   * @methodOf pascalprecht.translate.$translateProvider\n   *\n   * @description\n   * Sets an indicator which is used when a translation isn't found left to the\n   * translation id.\n   *\n   * @param {string} indicator An indicator.\n   */\n  this.translationNotFoundIndicatorLeft = function (indicator) {\n    if (!indicator) {\n      return $notFoundIndicatorLeft;\n    }\n    $notFoundIndicatorLeft = indicator;\n    return this;\n  };\n\n  /**\n   * ngdoc function\n   * @name pascalprecht.translate.$translateProvider#translationNotFoundIndicatorLeft\n   * @methodOf pascalprecht.translate.$translateProvider\n   *\n   * @description\n   * Sets an indicator which is used when a translation isn't found right to the\n   * translation id.\n   *\n   * @param {string} indicator An indicator.\n   */\n  this.translationNotFoundIndicatorRight = function (indicator) {\n    if (!indicator) {\n      return $notFoundIndicatorRight;\n    }\n    $notFoundIndicatorRight = indicator;\n    return this;\n  };\n\n  /**\n   * @ngdoc function\n   * @name pascalprecht.translate.$translateProvider#fallbackLanguage\n   * @methodOf pascalprecht.translate.$translateProvider\n   *\n   * @description\n   * Tells the module which of the registered translation tables to use when missing translations\n   * at initial startup by passing a language key. Similar to `$translateProvider#use`\n   * only that it says which language to **fallback**.\n   *\n   * @param {string||array} langKey A language key.\n   *\n   */\n  this.fallbackLanguage = function (langKey) {\n    fallbackStack(langKey);\n    return this;\n  };\n\n  var fallbackStack = function (langKey) {\n    if (langKey) {\n      if (angular.isString(langKey)) {\n        $fallbackWasString = true;\n        $fallbackLanguage = [ langKey ];\n      } else if (angular.isArray(langKey)) {\n        $fallbackWasString = false;\n        $fallbackLanguage = langKey;\n      }\n      if (angular.isString($preferredLanguage)  && indexOf($fallbackLanguage, $preferredLanguage) < 0) {\n        $fallbackLanguage.push($preferredLanguage);\n      }\n\n      return this;\n    } else {\n      if ($fallbackWasString) {\n        return $fallbackLanguage[0];\n      } else {\n        return $fallbackLanguage;\n      }\n    }\n  };\n\n  /**\n   * @ngdoc function\n   * @name pascalprecht.translate.$translateProvider#use\n   * @methodOf pascalprecht.translate.$translateProvider\n   *\n   * @description\n   * Set which translation table to use for translation by given language key. When\n   * trying to 'use' a language which isn't provided, it'll throw an error.\n   *\n   * You actually don't have to use this method since `$translateProvider#preferredLanguage`\n   * does the job too.\n   *\n   * @param {string} langKey A language key.\n   */\n  this.use = function (langKey) {\n    if (langKey) {\n      if (!$translationTable[langKey] && (!$loaderFactory)) {\n        // only throw an error, when not loading translation data asynchronously\n        throw new Error('$translateProvider couldn\\'t find translationTable for langKey: \\'' + langKey + '\\'');\n      }\n      $uses = langKey;\n      return this;\n    }\n    return $uses;\n  };\n\n  /**\n   * @ngdoc function\n   * @name pascalprecht.translate.$translateProvider#resolveClientLocale\n   * @methodOf pascalprecht.translate.$translateProvider\n   *\n   * @description\n   * This returns the current browser/client's language key. The result is processed with the configured uniform tag resolver.\n   *\n   * @returns {string} the current client/browser language key\n   */\n  this.resolveClientLocale = function () {\n    return getLocale();\n  };\n\n /**\n   * @ngdoc function\n   * @name pascalprecht.translate.$translateProvider#storageKey\n   * @methodOf pascalprecht.translate.$translateProvider\n   *\n   * @description\n   * Tells the module which key must represent the choosed language by a user in the storage.\n   *\n   * @param {string} key A key for the storage.\n   */\n  var storageKey = function(key) {\n    if (!key) {\n      if ($storagePrefix) {\n        return $storagePrefix + $storageKey;\n      }\n      return $storageKey;\n    }\n    $storageKey = key;\n    return this;\n  };\n\n  this.storageKey = storageKey;\n\n  /**\n   * @ngdoc function\n   * @name pascalprecht.translate.$translateProvider#useUrlLoader\n   * @methodOf pascalprecht.translate.$translateProvider\n   *\n   * @description\n   * Tells angular-translate to use `$translateUrlLoader` extension service as loader.\n   *\n   * @param {string} url Url\n   * @param {Object=} options Optional configuration object\n   */\n  this.useUrlLoader = function (url, options) {\n    return this.useLoader('$translateUrlLoader', angular.extend({ url: url }, options));\n  };\n\n  /**\n   * @ngdoc function\n   * @name pascalprecht.translate.$translateProvider#useStaticFilesLoader\n   * @methodOf pascalprecht.translate.$translateProvider\n   *\n   * @description\n   * Tells angular-translate to use `$translateStaticFilesLoader` extension service as loader.\n   *\n   * @param {Object=} options Optional configuration object\n   */\n  this.useStaticFilesLoader = function (options) {\n    return this.useLoader('$translateStaticFilesLoader', options);\n  };\n\n  /**\n   * @ngdoc function\n   * @name pascalprecht.translate.$translateProvider#useLoader\n   * @methodOf pascalprecht.translate.$translateProvider\n   *\n   * @description\n   * Tells angular-translate to use any other service as loader.\n   *\n   * @param {string} loaderFactory Factory name to use\n   * @param {Object=} options Optional configuration object\n   */\n  this.useLoader = function (loaderFactory, options) {\n    $loaderFactory = loaderFactory;\n    $loaderOptions = options || {};\n    return this;\n  };\n\n  /**\n   * @ngdoc function\n   * @name pascalprecht.translate.$translateProvider#useLocalStorage\n   * @methodOf pascalprecht.translate.$translateProvider\n   *\n   * @description\n   * Tells angular-translate to use `$translateLocalStorage` service as storage layer.\n   *\n   */\n  this.useLocalStorage = function () {\n    return this.useStorage('$translateLocalStorage');\n  };\n\n  /**\n   * @ngdoc function\n   * @name pascalprecht.translate.$translateProvider#useCookieStorage\n   * @methodOf pascalprecht.translate.$translateProvider\n   *\n   * @description\n   * Tells angular-translate to use `$translateCookieStorage` service as storage layer.\n   */\n  this.useCookieStorage = function () {\n    return this.useStorage('$translateCookieStorage');\n  };\n\n  /**\n   * @ngdoc function\n   * @name pascalprecht.translate.$translateProvider#useStorage\n   * @methodOf pascalprecht.translate.$translateProvider\n   *\n   * @description\n   * Tells angular-translate to use custom service as storage layer.\n   */\n  this.useStorage = function (storageFactory) {\n    $storageFactory = storageFactory;\n    return this;\n  };\n\n  /**\n   * @ngdoc function\n   * @name pascalprecht.translate.$translateProvider#storagePrefix\n   * @methodOf pascalprecht.translate.$translateProvider\n   *\n   * @description\n   * Sets prefix for storage key.\n   *\n   * @param {string} prefix Storage key prefix\n   */\n  this.storagePrefix = function (prefix) {\n    if (!prefix) {\n      return prefix;\n    }\n    $storagePrefix = prefix;\n    return this;\n  };\n\n  /**\n   * @ngdoc function\n   * @name pascalprecht.translate.$translateProvider#useMissingTranslationHandlerLog\n   * @methodOf pascalprecht.translate.$translateProvider\n   *\n   * @description\n   * Tells angular-translate to use built-in log handler when trying to translate\n   * a translation Id which doesn't exist.\n   *\n   * This is actually a shortcut method for `useMissingTranslationHandler()`.\n   *\n   */\n  this.useMissingTranslationHandlerLog = function () {\n    return this.useMissingTranslationHandler('$translateMissingTranslationHandlerLog');\n  };\n\n  /**\n   * @ngdoc function\n   * @name pascalprecht.translate.$translateProvider#useMissingTranslationHandler\n   * @methodOf pascalprecht.translate.$translateProvider\n   *\n   * @description\n   * Expects a factory name which later gets instantiated with `$injector`.\n   * This method can be used to tell angular-translate to use a custom\n   * missingTranslationHandler. Just build a factory which returns a function\n   * and expects a translation id as argument.\n   *\n   * Example:\n   * <pre>\n   *  app.config(function ($translateProvider) {\n   *    $translateProvider.useMissingTranslationHandler('customHandler');\n   *  });\n   *\n   *  app.factory('customHandler', function (dep1, dep2) {\n   *    return function (translationId) {\n   *      // something with translationId and dep1 and dep2\n   *    };\n   *  });\n   * </pre>\n   *\n   * @param {string} factory Factory name\n   */\n  this.useMissingTranslationHandler = function (factory) {\n    $missingTranslationHandlerFactory = factory;\n    return this;\n  };\n\n  /**\n   * @ngdoc function\n   * @name pascalprecht.translate.$translateProvider#usePostCompiling\n   * @methodOf pascalprecht.translate.$translateProvider\n   *\n   * @description\n   * If post compiling is enabled, all translated values will be processed\n   * again with AngularJS' $compile.\n   *\n   * Example:\n   * <pre>\n   *  app.config(function ($translateProvider) {\n   *    $translateProvider.usePostCompiling(true);\n   *  });\n   * </pre>\n   *\n   * @param {string} factory Factory name\n   */\n  this.usePostCompiling = function (value) {\n    $postCompilingEnabled = !(!value);\n    return this;\n  };\n\n  /**\n   * @ngdoc function\n   * @name pascalprecht.translate.$translateProvider#forceAsyncReload\n   * @methodOf pascalprecht.translate.$translateProvider\n   *\n   * @description\n   * If force async reload is enabled, async loader will always be called\n   * even if $translationTable already contains the language key, adding\n   * possible new entries to the $translationTable.\n   *\n   * Example:\n   * <pre>\n   *  app.config(function ($translateProvider) {\n   *    $translateProvider.forceAsyncReload(true);\n   *  });\n   * </pre>\n   *\n   * @param {boolean} value - valid values are true or false\n   */\n  this.forceAsyncReload = function (value) {\n    $forceAsyncReloadEnabled = !(!value);\n    return this;\n  };\n\n  /**\n   * @ngdoc function\n   * @name pascalprecht.translate.$translateProvider#uniformLanguageTag\n   * @methodOf pascalprecht.translate.$translateProvider\n   *\n   * @description\n   * Tells angular-translate which language tag should be used as a result when determining\n   * the current browser language.\n   *\n   * This setting must be set before invoking {@link pascalprecht.translate.$translateProvider#methods_determinePreferredLanguage determinePreferredLanguage()}.\n   *\n   * <pre>\n   * $translateProvider\n   *   .uniformLanguageTag('bcp47')\n   *   .determinePreferredLanguage()\n   * </pre>\n   *\n   * The resolver currently supports:\n   * * default\n   *     (traditionally: hyphens will be converted into underscores, i.e. en-US => en_US)\n   *     en-US => en_US\n   *     en_US => en_US\n   *     en-us => en_us\n   * * java\n   *     like default, but the second part will be always in uppercase\n   *     en-US => en_US\n   *     en_US => en_US\n   *     en-us => en_US\n   * * BCP 47 (RFC 4646 & 4647)\n   *     en-US => en-US\n   *     en_US => en-US\n   *     en-us => en-US\n   *\n   * See also:\n   * * http://en.wikipedia.org/wiki/IETF_language_tag\n   * * http://www.w3.org/International/core/langtags/\n   * * http://tools.ietf.org/html/bcp47\n   *\n   * @param {string|object} options - options (or standard)\n   * @param {string} options.standard - valid values are 'default', 'bcp47', 'java'\n   */\n  this.uniformLanguageTag = function (options) {\n\n    if (!options) {\n      options = {};\n    } else if (angular.isString(options)) {\n      options = {\n        standard: options\n      };\n    }\n\n    uniformLanguageTagResolver = options.standard;\n\n    return this;\n  };\n\n  /**\n   * @ngdoc function\n   * @name pascalprecht.translate.$translateProvider#determinePreferredLanguage\n   * @methodOf pascalprecht.translate.$translateProvider\n   *\n   * @description\n   * Tells angular-translate to try to determine on its own which language key\n   * to set as preferred language. When `fn` is given, angular-translate uses it\n   * to determine a language key, otherwise it uses the built-in `getLocale()`\n   * method.\n   *\n   * The `getLocale()` returns a language key in the format `[lang]_[country]` or\n   * `[lang]` depending on what the browser provides.\n   *\n   * Use this method at your own risk, since not all browsers return a valid\n   * locale (see {@link pascalprecht.translate.$translateProvider#methods_uniformLanguageTag uniformLanguageTag()}).\n   *\n   * @param {Function=} fn Function to determine a browser's locale\n   */\n  this.determinePreferredLanguage = function (fn) {\n\n    var locale = (fn && angular.isFunction(fn)) ? fn() : getLocale();\n\n    if (!$availableLanguageKeys.length) {\n      $preferredLanguage = locale;\n    } else {\n      $preferredLanguage = negotiateLocale(locale) || locale;\n    }\n\n    return this;\n  };\n\n  /**\n   * @ngdoc function\n   * @name pascalprecht.translate.$translateProvider#registerAvailableLanguageKeys\n   * @methodOf pascalprecht.translate.$translateProvider\n   *\n   * @description\n   * Registers a set of language keys the app will work with. Use this method in\n   * combination with\n   * {@link pascalprecht.translate.$translateProvider#determinePreferredLanguage determinePreferredLanguage}.\n   * When available languages keys are registered, angular-translate\n   * tries to find the best fitting language key depending on the browsers locale,\n   * considering your language key convention.\n   *\n   * @param {object} languageKeys Array of language keys the your app will use\n   * @param {object=} aliases Alias map.\n   */\n  this.registerAvailableLanguageKeys = function (languageKeys, aliases) {\n    if (languageKeys) {\n      $availableLanguageKeys = languageKeys;\n      if (aliases) {\n        $languageKeyAliases = aliases;\n      }\n      return this;\n    }\n    return $availableLanguageKeys;\n  };\n\n  /**\n   * @ngdoc function\n   * @name pascalprecht.translate.$translateProvider#useLoaderCache\n   * @methodOf pascalprecht.translate.$translateProvider\n   *\n   * @description\n   * Registers a cache for internal $http based loaders.\n   * {@link pascalprecht.translate.$translationCache $translationCache}.\n   * When false the cache will be disabled (default). When true or undefined\n   * the cache will be a default (see $cacheFactory). When an object it will\n   * be treat as a cache object itself: the usage is $http({cache: cache})\n   *\n   * @param {object} cache boolean, string or cache-object\n   */\n  this.useLoaderCache = function (cache) {\n    if (cache === false) {\n      // disable cache\n      loaderCache = undefined;\n    } else if (cache === true) {\n      // enable cache using AJS defaults\n      loaderCache = true;\n    } else if (typeof(cache) === 'undefined') {\n      // enable cache using default\n      loaderCache = '$translationCache';\n    } else if (cache) {\n      // enable cache using given one (see $cacheFactory)\n      loaderCache = cache;\n    }\n    return this;\n  };\n\n  /**\n   * @ngdoc function\n   * @name pascalprecht.translate.$translateProvider#directivePriority\n   * @methodOf pascalprecht.translate.$translateProvider\n   *\n   * @description\n   * Sets the default priority of the translate directive. The standard value is `0`.\n   * Calling this function without an argument will return the current value.\n   *\n   * @param {number} priority for the translate-directive\n   */\n  this.directivePriority = function (priority) {\n    if (priority === undefined) {\n      // getter\n      return directivePriority;\n    } else {\n      // setter with chaining\n      directivePriority = priority;\n      return this;\n    }\n  };\n\n  /**\n   * @ngdoc function\n   * @name pascalprecht.translate.$translateProvider#statefulFilter\n   * @methodOf pascalprecht.translate.$translateProvider\n   *\n   * @description\n   * Since AngularJS 1.3, filters which are not stateless (depending at the scope)\n   * have to explicit define this behavior.\n   * Sets whether the translate filter should be stateful or stateless. The standard value is `true`\n   * meaning being stateful.\n   * Calling this function without an argument will return the current value.\n   *\n   * @param {boolean} state - defines the state of the filter\n   */\n  this.statefulFilter = function (state) {\n    if (state === undefined) {\n      // getter\n      return statefulFilter;\n    } else {\n      // setter with chaining\n      statefulFilter = state;\n      return this;\n    }\n  };\n\n  /**\n   * @ngdoc function\n   * @name pascalprecht.translate.$translateProvider#postProcess\n   * @methodOf pascalprecht.translate.$translateProvider\n   *\n   * @description\n   * The post processor will be intercept right after the translation result. It can modify the result.\n   *\n   * @param {object} fn Function or service name (string) to be called after the translation value has been set / resolved. The function itself will enrich every value being processed and then continue the normal resolver process\n   */\n  this.postProcess = function (fn) {\n    if (fn) {\n      postProcessFn = fn;\n    } else {\n      postProcessFn = undefined;\n    }\n    return this;\n  };\n\n  /**\n   * @ngdoc function\n   * @name pascalprecht.translate.$translateProvider#keepContent\n   * @methodOf pascalprecht.translate.$translateProvider\n   *\n   * @description\n   * If keepContent is set to true than translate directive will always use innerHTML\n   * as a default translation\n   *\n   * Example:\n   * <pre>\n   *  app.config(function ($translateProvider) {\n   *    $translateProvider.keepContent(true);\n   *  });\n   * </pre>\n   *\n   * @param {boolean} value - valid values are true or false\n   */\n  this.keepContent = function (value) {\n    $keepContent = !(!value);\n    return this;\n  };\n\n  /**\n   * @ngdoc object\n   * @name pascalprecht.translate.$translate\n   * @requires $interpolate\n   * @requires $log\n   * @requires $rootScope\n   * @requires $q\n   *\n   * @description\n   * The `$translate` service is the actual core of angular-translate. It expects a translation id\n   * and optional interpolate parameters to translate contents.\n   *\n   * <pre>\n   *  $translate('HEADLINE_TEXT').then(function (translation) {\n   *    $scope.translatedText = translation;\n   *  });\n   * </pre>\n   *\n   * @param {string|array} translationId A token which represents a translation id\n   *                                     This can be optionally an array of translation ids which\n   *                                     results that the function returns an object where each key\n   *                                     is the translation id and the value the translation.\n   * @param {object=} interpolateParams An object hash for dynamic values\n   * @param {string} interpolationId The id of the interpolation to use\n   * @param {string} defaultTranslationText the optional default translation text that is written as\n   *                                        as default text in case it is not found in any configured language\n   * @param {string} forceLanguage A language to be used instead of the current language\n   * @returns {object} promise\n   */\n  this.$get = [\n    '$log',\n    '$injector',\n    '$rootScope',\n    '$q',\n    function ($log, $injector, $rootScope, $q) {\n\n      var Storage,\n          defaultInterpolator = $injector.get($interpolationFactory || '$translateDefaultInterpolation'),\n          pendingLoader = false,\n          interpolatorHashMap = {},\n          langPromises = {},\n          fallbackIndex,\n          startFallbackIteration;\n\n      var $translate = function (translationId, interpolateParams, interpolationId, defaultTranslationText, forceLanguage) {\n        if (!$uses && $preferredLanguage) {\n          $uses = $preferredLanguage;\n        }\n        var uses = (forceLanguage && forceLanguage !== $uses) ? // we don't want to re-negotiate $uses\n              (negotiateLocale(forceLanguage) || forceLanguage) : $uses;\n\n        // Check forceLanguage is present\n        if (forceLanguage) {\n          loadTranslationsIfMissing(forceLanguage);\n        }\n\n        // Duck detection: If the first argument is an array, a bunch of translations was requested.\n        // The result is an object.\n        if (angular.isArray(translationId)) {\n          // Inspired by Q.allSettled by Kris Kowal\n          // https://github.com/kriskowal/q/blob/b0fa72980717dc202ffc3cbf03b936e10ebbb9d7/q.js#L1553-1563\n          // This transforms all promises regardless resolved or rejected\n          var translateAll = function (translationIds) {\n            var results = {}; // storing the actual results\n            var promises = []; // promises to wait for\n            // Wraps the promise a) being always resolved and b) storing the link id->value\n            var translate = function (translationId) {\n              var deferred = $q.defer();\n              var regardless = function (value) {\n                results[translationId] = value;\n                deferred.resolve([translationId, value]);\n              };\n              // we don't care whether the promise was resolved or rejected; just store the values\n              $translate(translationId, interpolateParams, interpolationId, defaultTranslationText, forceLanguage).then(regardless, regardless);\n              return deferred.promise;\n            };\n            for (var i = 0, c = translationIds.length; i < c; i++) {\n              promises.push(translate(translationIds[i]));\n            }\n            // wait for all (including storing to results)\n            return $q.all(promises).then(function () {\n              // return the results\n              return results;\n            });\n          };\n          return translateAll(translationId);\n        }\n\n        var deferred = $q.defer();\n\n        // trim off any whitespace\n        if (translationId) {\n          translationId = trim.apply(translationId);\n        }\n\n        var promiseToWaitFor = (function () {\n          var promise = $preferredLanguage ?\n            langPromises[$preferredLanguage] :\n            langPromises[uses];\n\n          fallbackIndex = 0;\n\n          if ($storageFactory && !promise) {\n            // looks like there's no pending promise for $preferredLanguage or\n            // $uses. Maybe there's one pending for a language that comes from\n            // storage.\n            var langKey = Storage.get($storageKey);\n            promise = langPromises[langKey];\n\n            if ($fallbackLanguage && $fallbackLanguage.length) {\n                var index = indexOf($fallbackLanguage, langKey);\n                // maybe the language from storage is also defined as fallback language\n                // we increase the fallback language index to not search in that language\n                // as fallback, since it's probably the first used language\n                // in that case the index starts after the first element\n                fallbackIndex = (index === 0) ? 1 : 0;\n\n                // but we can make sure to ALWAYS fallback to preferred language at least\n                if (indexOf($fallbackLanguage, $preferredLanguage) < 0) {\n                  $fallbackLanguage.push($preferredLanguage);\n                }\n            }\n          }\n          return promise;\n        }());\n\n        if (!promiseToWaitFor) {\n          // no promise to wait for? okay. Then there's no loader registered\n          // nor is a one pending for language that comes from storage.\n          // We can just translate.\n          determineTranslation(translationId, interpolateParams, interpolationId, defaultTranslationText, uses).then(deferred.resolve, deferred.reject);\n        } else {\n          var promiseResolved = function () {\n            // $uses may have changed while waiting\n            if (!forceLanguage) {\n              uses = $uses;\n            }\n            determineTranslation(translationId, interpolateParams, interpolationId, defaultTranslationText, uses).then(deferred.resolve, deferred.reject);\n          };\n          promiseResolved.displayName = 'promiseResolved';\n\n          promiseToWaitFor['finally'](promiseResolved);\n        }\n        return deferred.promise;\n      };\n\n      /**\n       * @name applyNotFoundIndicators\n       * @private\n       *\n       * @description\n       * Applies not fount indicators to given translation id, if needed.\n       * This function gets only executed, if a translation id doesn't exist,\n       * which is why a translation id is expected as argument.\n       *\n       * @param {string} translationId Translation id.\n       * @returns {string} Same as given translation id but applied with not found\n       * indicators.\n       */\n      var applyNotFoundIndicators = function (translationId) {\n        // applying notFoundIndicators\n        if ($notFoundIndicatorLeft) {\n          translationId = [$notFoundIndicatorLeft, translationId].join(' ');\n        }\n        if ($notFoundIndicatorRight) {\n          translationId = [translationId, $notFoundIndicatorRight].join(' ');\n        }\n        return translationId;\n      };\n\n      /**\n       * @name useLanguage\n       * @private\n       *\n       * @description\n       * Makes actual use of a language by setting a given language key as used\n       * language and informs registered interpolators to also use the given\n       * key as locale.\n       *\n       * @param {string} key Locale key.\n       */\n      var useLanguage = function (key) {\n        $uses = key;\n\n        // make sure to store new language key before triggering success event\n        if ($storageFactory) {\n          Storage.put($translate.storageKey(), $uses);\n        }\n\n        $rootScope.$emit('$translateChangeSuccess', {language: key});\n\n        // inform default interpolator\n        defaultInterpolator.setLocale($uses);\n\n        var eachInterpolator = function (interpolator, id) {\n          interpolatorHashMap[id].setLocale($uses);\n        };\n        eachInterpolator.displayName = 'eachInterpolatorLocaleSetter';\n\n        // inform all others too!\n        angular.forEach(interpolatorHashMap, eachInterpolator);\n        $rootScope.$emit('$translateChangeEnd', {language: key});\n      };\n\n      /**\n       * @name loadAsync\n       * @private\n       *\n       * @description\n       * Kicks of registered async loader using `$injector` and applies existing\n       * loader options. When resolved, it updates translation tables accordingly\n       * or rejects with given language key.\n       *\n       * @param {string} key Language key.\n       * @return {Promise} A promise.\n       */\n      var loadAsync = function (key) {\n        if (!key) {\n          throw 'No language key specified for loading.';\n        }\n\n        var deferred = $q.defer();\n\n        $rootScope.$emit('$translateLoadingStart', {language: key});\n        pendingLoader = true;\n\n        var cache = loaderCache;\n        if (typeof(cache) === 'string') {\n          // getting on-demand instance of loader\n          cache = $injector.get(cache);\n        }\n\n        var loaderOptions = angular.extend({}, $loaderOptions, {\n          key: key,\n          $http: angular.extend({}, {\n            cache: cache\n          }, $loaderOptions.$http)\n        });\n\n        var onLoaderSuccess = function (data) {\n          var translationTable = {};\n          $rootScope.$emit('$translateLoadingSuccess', {language: key});\n\n          if (angular.isArray(data)) {\n            angular.forEach(data, function (table) {\n              angular.extend(translationTable, flatObject(table));\n            });\n          } else {\n            angular.extend(translationTable, flatObject(data));\n          }\n          pendingLoader = false;\n          deferred.resolve({\n            key: key,\n            table: translationTable\n          });\n          $rootScope.$emit('$translateLoadingEnd', {language: key});\n        };\n        onLoaderSuccess.displayName = 'onLoaderSuccess';\n\n        var onLoaderError = function (key) {\n          $rootScope.$emit('$translateLoadingError', {language: key});\n          deferred.reject(key);\n          $rootScope.$emit('$translateLoadingEnd', {language: key});\n        };\n        onLoaderError.displayName = 'onLoaderError';\n\n        $injector.get($loaderFactory)(loaderOptions)\n          .then(onLoaderSuccess, onLoaderError);\n\n        return deferred.promise;\n      };\n\n      if ($storageFactory) {\n        Storage = $injector.get($storageFactory);\n\n        if (!Storage.get || !Storage.put) {\n          throw new Error('Couldn\\'t use storage \\'' + $storageFactory + '\\', missing get() or put() method!');\n        }\n      }\n\n      // if we have additional interpolations that were added via\n      // $translateProvider.addInterpolation(), we have to map'em\n      if ($interpolatorFactories.length) {\n        var eachInterpolationFactory = function (interpolatorFactory) {\n          var interpolator = $injector.get(interpolatorFactory);\n          // setting initial locale for each interpolation service\n          interpolator.setLocale($preferredLanguage || $uses);\n          // make'em recognizable through id\n          interpolatorHashMap[interpolator.getInterpolationIdentifier()] = interpolator;\n        };\n        eachInterpolationFactory.displayName = 'interpolationFactoryAdder';\n\n        angular.forEach($interpolatorFactories, eachInterpolationFactory);\n      }\n\n      /**\n       * @name getTranslationTable\n       * @private\n       *\n       * @description\n       * Returns a promise that resolves to the translation table\n       * or is rejected if an error occurred.\n       *\n       * @param langKey\n       * @returns {Q.promise}\n       */\n      var getTranslationTable = function (langKey) {\n        var deferred = $q.defer();\n        if (Object.prototype.hasOwnProperty.call($translationTable, langKey)) {\n          deferred.resolve($translationTable[langKey]);\n        } else if (langPromises[langKey]) {\n          var onResolve = function (data) {\n            translations(data.key, data.table);\n            deferred.resolve(data.table);\n          };\n          onResolve.displayName = 'translationTableResolver';\n          langPromises[langKey].then(onResolve, deferred.reject);\n        } else {\n          deferred.reject();\n        }\n        return deferred.promise;\n      };\n\n      /**\n       * @name getFallbackTranslation\n       * @private\n       *\n       * @description\n       * Returns a promise that will resolve to the translation\n       * or be rejected if no translation was found for the language.\n       * This function is currently only used for fallback language translation.\n       *\n       * @param langKey The language to translate to.\n       * @param translationId\n       * @param interpolateParams\n       * @param Interpolator\n       * @returns {Q.promise}\n       */\n      var getFallbackTranslation = function (langKey, translationId, interpolateParams, Interpolator) {\n        var deferred = $q.defer();\n\n        var onResolve = function (translationTable) {\n          if (Object.prototype.hasOwnProperty.call(translationTable, translationId)) {\n            Interpolator.setLocale(langKey);\n            var translation = translationTable[translationId];\n            if (translation.substr(0, 2) === '@:') {\n              getFallbackTranslation(langKey, translation.substr(2), interpolateParams, Interpolator)\n                .then(deferred.resolve, deferred.reject);\n            } else {\n              var interpolatedValue = Interpolator.interpolate(translationTable[translationId], interpolateParams);\n              interpolatedValue = applyPostProcessing(translationId, translationTable[translationId], interpolatedValue, interpolateParams, langKey);\n\n              deferred.resolve(interpolatedValue);\n\n            }\n            Interpolator.setLocale($uses);\n          } else {\n            deferred.reject();\n          }\n        };\n        onResolve.displayName = 'fallbackTranslationResolver';\n\n        getTranslationTable(langKey).then(onResolve, deferred.reject);\n\n        return deferred.promise;\n      };\n\n      /**\n       * @name getFallbackTranslationInstant\n       * @private\n       *\n       * @description\n       * Returns a translation\n       * This function is currently only used for fallback language translation.\n       *\n       * @param langKey The language to translate to.\n       * @param translationId\n       * @param interpolateParams\n       * @param Interpolator\n       * @returns {string} translation\n       */\n      var getFallbackTranslationInstant = function (langKey, translationId, interpolateParams, Interpolator) {\n        var result, translationTable = $translationTable[langKey];\n\n        if (translationTable && Object.prototype.hasOwnProperty.call(translationTable, translationId)) {\n          Interpolator.setLocale(langKey);\n          result = Interpolator.interpolate(translationTable[translationId], interpolateParams);\n          result = applyPostProcessing(translationId, translationTable[translationId], result, interpolateParams, langKey);\n          if (result.substr(0, 2) === '@:') {\n            return getFallbackTranslationInstant(langKey, result.substr(2), interpolateParams, Interpolator);\n          }\n          Interpolator.setLocale($uses);\n        }\n\n        return result;\n      };\n\n\n      /**\n       * @name translateByHandler\n       * @private\n       *\n       * Translate by missing translation handler.\n       *\n       * @param translationId\n       * @param interpolateParams\n       * @param defaultTranslationText\n       * @returns translation created by $missingTranslationHandler or translationId is $missingTranslationHandler is\n       * absent\n       */\n      var translateByHandler = function (translationId, interpolateParams, defaultTranslationText) {\n        // If we have a handler factory - we might also call it here to determine if it provides\n        // a default text for a translationid that can't be found anywhere in our tables\n        if ($missingTranslationHandlerFactory) {\n          var resultString = $injector.get($missingTranslationHandlerFactory)(translationId, $uses, interpolateParams, defaultTranslationText);\n          if (resultString !== undefined) {\n            return resultString;\n          } else {\n            return translationId;\n          }\n        } else {\n          return translationId;\n        }\n      };\n\n      /**\n       * @name resolveForFallbackLanguage\n       * @private\n       *\n       * Recursive helper function for fallbackTranslation that will sequentially look\n       * for a translation in the fallbackLanguages starting with fallbackLanguageIndex.\n       *\n       * @param fallbackLanguageIndex\n       * @param translationId\n       * @param interpolateParams\n       * @param Interpolator\n       * @returns {Q.promise} Promise that will resolve to the translation.\n       */\n      var resolveForFallbackLanguage = function (fallbackLanguageIndex, translationId, interpolateParams, Interpolator, defaultTranslationText) {\n        var deferred = $q.defer();\n\n        if (fallbackLanguageIndex < $fallbackLanguage.length) {\n          var langKey = $fallbackLanguage[fallbackLanguageIndex];\n          getFallbackTranslation(langKey, translationId, interpolateParams, Interpolator).then(\n            function (data) {\n                deferred.resolve(data);\n            },\n            function () {\n              // Look in the next fallback language for a translation.\n              // It delays the resolving by passing another promise to resolve.\n              return resolveForFallbackLanguage(fallbackLanguageIndex + 1, translationId, interpolateParams, Interpolator, defaultTranslationText).then(deferred.resolve, deferred.reject);\n            }\n          );\n        } else {\n          // No translation found in any fallback language\n          // if a default translation text is set in the directive, then return this as a result\n          if (defaultTranslationText) {\n            deferred.resolve(defaultTranslationText);\n          } else {\n            // if no default translation is set and an error handler is defined, send it to the handler\n            // and then return the result\n            if ($missingTranslationHandlerFactory) {\n              deferred.resolve(translateByHandler(translationId, interpolateParams));\n            } else {\n              deferred.reject(translateByHandler(translationId, interpolateParams));\n            }\n\n          }\n        }\n        return deferred.promise;\n      };\n\n      /**\n       * @name resolveForFallbackLanguageInstant\n       * @private\n       *\n       * Recursive helper function for fallbackTranslation that will sequentially look\n       * for a translation in the fallbackLanguages starting with fallbackLanguageIndex.\n       *\n       * @param fallbackLanguageIndex\n       * @param translationId\n       * @param interpolateParams\n       * @param Interpolator\n       * @returns {string} translation\n       */\n      var resolveForFallbackLanguageInstant = function (fallbackLanguageIndex, translationId, interpolateParams, Interpolator) {\n        var result;\n\n        if (fallbackLanguageIndex < $fallbackLanguage.length) {\n          var langKey = $fallbackLanguage[fallbackLanguageIndex];\n          result = getFallbackTranslationInstant(langKey, translationId, interpolateParams, Interpolator);\n          if (!result) {\n            result = resolveForFallbackLanguageInstant(fallbackLanguageIndex + 1, translationId, interpolateParams, Interpolator);\n          }\n        }\n        return result;\n      };\n\n      /**\n       * Translates with the usage of the fallback languages.\n       *\n       * @param translationId\n       * @param interpolateParams\n       * @param Interpolator\n       * @returns {Q.promise} Promise, that resolves to the translation.\n       */\n      var fallbackTranslation = function (translationId, interpolateParams, Interpolator, defaultTranslationText) {\n        // Start with the fallbackLanguage with index 0\n        return resolveForFallbackLanguage((startFallbackIteration>0 ? startFallbackIteration : fallbackIndex), translationId, interpolateParams, Interpolator, defaultTranslationText);\n      };\n\n      /**\n       * Translates with the usage of the fallback languages.\n       *\n       * @param translationId\n       * @param interpolateParams\n       * @param Interpolator\n       * @returns {String} translation\n       */\n      var fallbackTranslationInstant = function (translationId, interpolateParams, Interpolator) {\n        // Start with the fallbackLanguage with index 0\n        return resolveForFallbackLanguageInstant((startFallbackIteration>0 ? startFallbackIteration : fallbackIndex), translationId, interpolateParams, Interpolator);\n      };\n\n      var determineTranslation = function (translationId, interpolateParams, interpolationId, defaultTranslationText, uses) {\n\n        var deferred = $q.defer();\n\n        var table = uses ? $translationTable[uses] : $translationTable,\n            Interpolator = (interpolationId) ? interpolatorHashMap[interpolationId] : defaultInterpolator;\n\n        // if the translation id exists, we can just interpolate it\n        if (table && Object.prototype.hasOwnProperty.call(table, translationId)) {\n          var translation = table[translationId];\n\n          // If using link, rerun $translate with linked translationId and return it\n          if (translation.substr(0, 2) === '@:') {\n\n            $translate(translation.substr(2), interpolateParams, interpolationId, defaultTranslationText, uses)\n              .then(deferred.resolve, deferred.reject);\n          } else {\n            //\n            var resolvedTranslation = Interpolator.interpolate(translation, interpolateParams);\n            resolvedTranslation = applyPostProcessing(translationId, translation, resolvedTranslation, interpolateParams, uses);\n            deferred.resolve(resolvedTranslation);\n          }\n        } else {\n          var missingTranslationHandlerTranslation;\n          // for logging purposes only (as in $translateMissingTranslationHandlerLog), value is not returned to promise\n          if ($missingTranslationHandlerFactory && !pendingLoader) {\n            missingTranslationHandlerTranslation = translateByHandler(translationId, interpolateParams, defaultTranslationText);\n          }\n\n          // since we couldn't translate the inital requested translation id,\n          // we try it now with one or more fallback languages, if fallback language(s) is\n          // configured.\n          if (uses && $fallbackLanguage && $fallbackLanguage.length) {\n            fallbackTranslation(translationId, interpolateParams, Interpolator, defaultTranslationText)\n                .then(function (translation) {\n                  deferred.resolve(translation);\n                }, function (_translationId) {\n                  deferred.reject(applyNotFoundIndicators(_translationId));\n                });\n          } else if ($missingTranslationHandlerFactory && !pendingLoader && missingTranslationHandlerTranslation) {\n            // looks like the requested translation id doesn't exists.\n            // Now, if there is a registered handler for missing translations and no\n            // asyncLoader is pending, we execute the handler\n            if (defaultTranslationText) {\n              deferred.resolve(defaultTranslationText);\n              } else {\n                deferred.resolve(missingTranslationHandlerTranslation);\n              }\n          } else {\n            if (defaultTranslationText) {\n              deferred.resolve(defaultTranslationText);\n            } else {\n              deferred.reject(applyNotFoundIndicators(translationId));\n            }\n          }\n        }\n        return deferred.promise;\n      };\n\n      var determineTranslationInstant = function (translationId, interpolateParams, interpolationId, uses) {\n\n        var result, table = uses ? $translationTable[uses] : $translationTable,\n            Interpolator = defaultInterpolator;\n\n        // if the interpolation id exists use custom interpolator\n        if (interpolatorHashMap && Object.prototype.hasOwnProperty.call(interpolatorHashMap, interpolationId)) {\n          Interpolator = interpolatorHashMap[interpolationId];\n        }\n\n        // if the translation id exists, we can just interpolate it\n        if (table && Object.prototype.hasOwnProperty.call(table, translationId)) {\n          var translation = table[translationId];\n\n          // If using link, rerun $translate with linked translationId and return it\n          if (translation.substr(0, 2) === '@:') {\n            result = determineTranslationInstant(translation.substr(2), interpolateParams, interpolationId, uses);\n          } else {\n            result = Interpolator.interpolate(translation, interpolateParams);\n            result = applyPostProcessing(translationId, translation, result, interpolateParams, uses);\n          }\n        } else {\n          var missingTranslationHandlerTranslation;\n          // for logging purposes only (as in $translateMissingTranslationHandlerLog), value is not returned to promise\n          if ($missingTranslationHandlerFactory && !pendingLoader) {\n            missingTranslationHandlerTranslation = translateByHandler(translationId, interpolateParams);\n          }\n\n          // since we couldn't translate the inital requested translation id,\n          // we try it now with one or more fallback languages, if fallback language(s) is\n          // configured.\n          if (uses && $fallbackLanguage && $fallbackLanguage.length) {\n            fallbackIndex = 0;\n            result = fallbackTranslationInstant(translationId, interpolateParams, Interpolator);\n          } else if ($missingTranslationHandlerFactory && !pendingLoader && missingTranslationHandlerTranslation) {\n            // looks like the requested translation id doesn't exists.\n            // Now, if there is a registered handler for missing translations and no\n            // asyncLoader is pending, we execute the handler\n            result = missingTranslationHandlerTranslation;\n          } else {\n            result = applyNotFoundIndicators(translationId);\n          }\n        }\n\n        return result;\n      };\n\n      var clearNextLangAndPromise = function(key) {\n        if ($nextLang === key) {\n          $nextLang = undefined;\n        }\n        langPromises[key] = undefined;\n      };\n\n      var applyPostProcessing = function (translationId, translation, resolvedTranslation, interpolateParams, uses) {\n        var fn = postProcessFn;\n\n        if (fn) {\n\n          if (typeof(fn) === 'string') {\n            // getting on-demand instance\n            fn = $injector.get(fn);\n          }\n          if (fn) {\n            return fn(translationId, translation, resolvedTranslation, interpolateParams, uses);\n          }\n        }\n\n        return resolvedTranslation;\n      };\n\n      var loadTranslationsIfMissing = function (key) {\n        if (!$translationTable[key] && $loaderFactory && !langPromises[key]) {\n          langPromises[key] = loadAsync(key).then(function (translation) {\n            translations(translation.key, translation.table);\n            return translation;\n          });\n        }\n      };\n\n      /**\n       * @ngdoc function\n       * @name pascalprecht.translate.$translate#preferredLanguage\n       * @methodOf pascalprecht.translate.$translate\n       *\n       * @description\n       * Returns the language key for the preferred language.\n       *\n       * @param {string} langKey language String or Array to be used as preferredLanguage (changing at runtime)\n       *\n       * @return {string} preferred language key\n       */\n      $translate.preferredLanguage = function (langKey) {\n        if(langKey) {\n          setupPreferredLanguage(langKey);\n        }\n        return $preferredLanguage;\n      };\n\n      /**\n       * @ngdoc function\n       * @name pascalprecht.translate.$translate#cloakClassName\n       * @methodOf pascalprecht.translate.$translate\n       *\n       * @description\n       * Returns the configured class name for `translate-cloak` directive.\n       *\n       * @return {string} cloakClassName\n       */\n      $translate.cloakClassName = function () {\n        return $cloakClassName;\n      };\n\n      /**\n       * @ngdoc function\n       * @name pascalprecht.translate.$translate#nestedObjectDelimeter\n       * @methodOf pascalprecht.translate.$translate\n       *\n       * @description\n       * Returns the configured delimiter for nested namespaces.\n       *\n       * @return {string} nestedObjectDelimeter\n       */\n      $translate.nestedObjectDelimeter = function () {\n        return $nestedObjectDelimeter;\n      };\n\n      /**\n       * @ngdoc function\n       * @name pascalprecht.translate.$translate#fallbackLanguage\n       * @methodOf pascalprecht.translate.$translate\n       *\n       * @description\n       * Returns the language key for the fallback languages or sets a new fallback stack.\n       *\n       * @param {string=} langKey language String or Array of fallback languages to be used (to change stack at runtime)\n       *\n       * @return {string||array} fallback language key\n       */\n      $translate.fallbackLanguage = function (langKey) {\n        if (langKey !== undefined && langKey !== null) {\n          fallbackStack(langKey);\n\n          // as we might have an async loader initiated and a new translation language might have been defined\n          // we need to add the promise to the stack also. So - iterate.\n          if ($loaderFactory) {\n            if ($fallbackLanguage && $fallbackLanguage.length) {\n              for (var i = 0, len = $fallbackLanguage.length; i < len; i++) {\n                if (!langPromises[$fallbackLanguage[i]]) {\n                  langPromises[$fallbackLanguage[i]] = loadAsync($fallbackLanguage[i]);\n                }\n              }\n            }\n          }\n          $translate.use($translate.use());\n        }\n        if ($fallbackWasString) {\n          return $fallbackLanguage[0];\n        } else {\n          return $fallbackLanguage;\n        }\n\n      };\n\n      /**\n       * @ngdoc function\n       * @name pascalprecht.translate.$translate#useFallbackLanguage\n       * @methodOf pascalprecht.translate.$translate\n       *\n       * @description\n       * Sets the first key of the fallback language stack to be used for translation.\n       * Therefore all languages in the fallback array BEFORE this key will be skipped!\n       *\n       * @param {string=} langKey Contains the langKey the iteration shall start with. Set to false if you want to\n       * get back to the whole stack\n       */\n      $translate.useFallbackLanguage = function (langKey) {\n        if (langKey !== undefined && langKey !== null) {\n          if (!langKey) {\n            startFallbackIteration = 0;\n          } else {\n            var langKeyPosition = indexOf($fallbackLanguage, langKey);\n            if (langKeyPosition > -1) {\n              startFallbackIteration = langKeyPosition;\n            }\n          }\n\n        }\n\n      };\n\n      /**\n       * @ngdoc function\n       * @name pascalprecht.translate.$translate#proposedLanguage\n       * @methodOf pascalprecht.translate.$translate\n       *\n       * @description\n       * Returns the language key of language that is currently loaded asynchronously.\n       *\n       * @return {string} language key\n       */\n      $translate.proposedLanguage = function () {\n        return $nextLang;\n      };\n\n      /**\n       * @ngdoc function\n       * @name pascalprecht.translate.$translate#storage\n       * @methodOf pascalprecht.translate.$translate\n       *\n       * @description\n       * Returns registered storage.\n       *\n       * @return {object} Storage\n       */\n      $translate.storage = function () {\n        return Storage;\n      };\n\n      /**\n       * @ngdoc function\n       * @name pascalprecht.translate.$translate#negotiateLocale\n       * @methodOf pascalprecht.translate.$translate\n       *\n       * @description\n       * Returns a language key based on available languages and language aliases. If a\n       * language key cannot be resolved, returns undefined.\n       *\n       * If no or a falsy key is given, returns undefined.\n       *\n       * @param {string} [key] Language key\n       * @return {string|undefined} Language key or undefined if no language key is found.\n       */\n      $translate.negotiateLocale = negotiateLocale;\n\n      /**\n       * @ngdoc function\n       * @name pascalprecht.translate.$translate#use\n       * @methodOf pascalprecht.translate.$translate\n       *\n       * @description\n       * Tells angular-translate which language to use by given language key. This method is\n       * used to change language at runtime. It also takes care of storing the language\n       * key in a configured store to let your app remember the choosed language.\n       *\n       * When trying to 'use' a language which isn't available it tries to load it\n       * asynchronously with registered loaders.\n       *\n       * Returns promise object with loaded language file data or string of the currently used language.\n       *\n       * If no or a falsy key is given it returns the currently used language key.\n       * The returned string will be ```undefined``` if setting up $translate hasn't finished.\n       * @example\n       * $translate.use(\"en_US\").then(function(data){\n       *   $scope.text = $translate(\"HELLO\");\n       * });\n       *\n       * @param {string} [key] Language key\n       * @return {object|string} Promise with loaded language data or the language key if a falsy param was given.\n       */\n      $translate.use = function (key) {\n        if (!key) {\n          return $uses;\n        }\n\n        var deferred = $q.defer();\n\n        $rootScope.$emit('$translateChangeStart', {language: key});\n\n        // Try to get the aliased language key\n        var aliasedKey = negotiateLocale(key);\n        // Ensure only registered language keys will be loaded\n        if ($availableLanguageKeys.length > 0 && !aliasedKey) {\n          return $q.reject(key);\n        }\n\n        if (aliasedKey) {\n          key = aliasedKey;\n        }\n\n        // if there isn't a translation table for the language we've requested,\n        // we load it asynchronously\n        $nextLang = key;\n        if (($forceAsyncReloadEnabled || !$translationTable[key]) && $loaderFactory && !langPromises[key]) {\n          langPromises[key] = loadAsync(key).then(function (translation) {\n            translations(translation.key, translation.table);\n            deferred.resolve(translation.key);\n            if ($nextLang === key) {\n              useLanguage(translation.key);\n            }\n            return translation;\n          }, function (key) {\n            $rootScope.$emit('$translateChangeError', {language: key});\n            deferred.reject(key);\n            $rootScope.$emit('$translateChangeEnd', {language: key});\n            return $q.reject(key);\n          });\n          langPromises[key]['finally'](function () {\n            clearNextLangAndPromise(key);\n          });\n        } else if (langPromises[key]) {\n          // we are already loading this asynchronously\n          // resolve our new deferred when the old langPromise is resolved\n          langPromises[key].then(function (translation) {\n            if ($nextLang === translation.key) {\n              useLanguage(translation.key);\n            }\n            deferred.resolve(translation.key);\n            return translation;\n          }, function (key) {\n            // find first available fallback language if that request has failed\n            if (!$uses && $fallbackLanguage && $fallbackLanguage.length > 0) {\n              return $translate.use($fallbackLanguage[0]).then(deferred.resolve, deferred.reject);\n            } else {\n              return deferred.reject(key);\n            }\n          });\n        } else {\n          deferred.resolve(key);\n          useLanguage(key);\n        }\n\n        return deferred.promise;\n      };\n\n      /**\n       * @ngdoc function\n       * @name pascalprecht.translate.$translate#resolveClientLocale\n       * @methodOf pascalprecht.translate.$translate\n       *\n       * @description\n       * This returns the current browser/client's language key. The result is processed with the configured uniform tag resolver.\n       *\n       * @returns {string} the current client/browser language key\n       */\n      $translate.resolveClientLocale = function () {\n        return getLocale();\n      };\n\n      /**\n       * @ngdoc function\n       * @name pascalprecht.translate.$translate#storageKey\n       * @methodOf pascalprecht.translate.$translate\n       *\n       * @description\n       * Returns the key for the storage.\n       *\n       * @return {string} storage key\n       */\n      $translate.storageKey = function () {\n        return storageKey();\n      };\n\n      /**\n       * @ngdoc function\n       * @name pascalprecht.translate.$translate#isPostCompilingEnabled\n       * @methodOf pascalprecht.translate.$translate\n       *\n       * @description\n       * Returns whether post compiling is enabled or not\n       *\n       * @return {bool} storage key\n       */\n      $translate.isPostCompilingEnabled = function () {\n        return $postCompilingEnabled;\n      };\n\n      /**\n       * @ngdoc function\n       * @name pascalprecht.translate.$translate#isForceAsyncReloadEnabled\n       * @methodOf pascalprecht.translate.$translate\n       *\n       * @description\n       * Returns whether force async reload is enabled or not\n       *\n       * @return {boolean} forceAsyncReload value\n       */\n      $translate.isForceAsyncReloadEnabled = function () {\n        return $forceAsyncReloadEnabled;\n      };\n\n      /**\n       * @ngdoc function\n       * @name pascalprecht.translate.$translate#isKeepContent\n       * @methodOf pascalprecht.translate.$translate\n       *\n       * @description\n       * Returns whether keepContent or not\n       *\n       * @return {boolean} keepContent value\n       */\n      $translate.isKeepContent = function () {\n        return $keepContent;\n      };\n\n      /**\n       * @ngdoc function\n       * @name pascalprecht.translate.$translate#refresh\n       * @methodOf pascalprecht.translate.$translate\n       *\n       * @description\n       * Refreshes a translation table pointed by the given langKey. If langKey is not specified,\n       * the module will drop all existent translation tables and load new version of those which\n       * are currently in use.\n       *\n       * Refresh means that the module will drop target translation table and try to load it again.\n       *\n       * In case there are no loaders registered the refresh() method will throw an Error.\n       *\n       * If the module is able to refresh translation tables refresh() method will broadcast\n       * $translateRefreshStart and $translateRefreshEnd events.\n       *\n       * @example\n       * // this will drop all currently existent translation tables and reload those which are\n       * // currently in use\n       * $translate.refresh();\n       * // this will refresh a translation table for the en_US language\n       * $translate.refresh('en_US');\n       *\n       * @param {string} langKey A language key of the table, which has to be refreshed\n       *\n       * @return {promise} Promise, which will be resolved in case a translation tables refreshing\n       * process is finished successfully, and reject if not.\n       */\n      $translate.refresh = function (langKey) {\n        if (!$loaderFactory) {\n          throw new Error('Couldn\\'t refresh translation table, no loader registered!');\n        }\n\n        var deferred = $q.defer();\n\n        function resolve() {\n          deferred.resolve();\n          $rootScope.$emit('$translateRefreshEnd', {language: langKey});\n        }\n\n        function reject() {\n          deferred.reject();\n          $rootScope.$emit('$translateRefreshEnd', {language: langKey});\n        }\n\n        $rootScope.$emit('$translateRefreshStart', {language: langKey});\n\n        if (!langKey) {\n          // if there's no language key specified we refresh ALL THE THINGS!\n          var tables = [], loadingKeys = {};\n\n          // reload registered fallback languages\n          if ($fallbackLanguage && $fallbackLanguage.length) {\n            for (var i = 0, len = $fallbackLanguage.length; i < len; i++) {\n              tables.push(loadAsync($fallbackLanguage[i]));\n              loadingKeys[$fallbackLanguage[i]] = true;\n            }\n          }\n\n          // reload currently used language\n          if ($uses && !loadingKeys[$uses]) {\n            tables.push(loadAsync($uses));\n          }\n\n          var allTranslationsLoaded = function (tableData) {\n            $translationTable = {};\n            angular.forEach(tableData, function (data) {\n              translations(data.key, data.table);\n            });\n            if ($uses) {\n              useLanguage($uses);\n            }\n            resolve();\n          };\n          allTranslationsLoaded.displayName = 'refreshPostProcessor';\n\n          $q.all(tables).then(allTranslationsLoaded, reject);\n\n        } else if ($translationTable[langKey]) {\n\n          var oneTranslationsLoaded = function (data) {\n            translations(data.key, data.table);\n            if (langKey === $uses) {\n              useLanguage($uses);\n            }\n            resolve();\n            return data;\n          };\n          oneTranslationsLoaded.displayName = 'refreshPostProcessor';\n\n          loadAsync(langKey).then(oneTranslationsLoaded, reject);\n\n        } else {\n          reject();\n        }\n        return deferred.promise;\n      };\n\n      /**\n       * @ngdoc function\n       * @name pascalprecht.translate.$translate#instant\n       * @methodOf pascalprecht.translate.$translate\n       *\n       * @description\n       * Returns a translation instantly from the internal state of loaded translation. All rules\n       * regarding the current language, the preferred language of even fallback languages will be\n       * used except any promise handling. If a language was not found, an asynchronous loading\n       * will be invoked in the background.\n       *\n       * @param {string|array} translationId A token which represents a translation id\n       *                                     This can be optionally an array of translation ids which\n       *                                     results that the function's promise returns an object where\n       *                                     each key is the translation id and the value the translation.\n       * @param {object} interpolateParams Params\n       * @param {string} interpolationId The id of the interpolation to use\n       * @param {string} forceLanguage A language to be used instead of the current language\n       *\n       * @return {string|object} translation\n       */\n      $translate.instant = function (translationId, interpolateParams, interpolationId, forceLanguage) {\n\n        // we don't want to re-negotiate $uses\n        var uses = (forceLanguage && forceLanguage !== $uses) ? // we don't want to re-negotiate $uses\n              (negotiateLocale(forceLanguage) || forceLanguage) : $uses;\n\n        // Detect undefined and null values to shorten the execution and prevent exceptions\n        if (translationId === null || angular.isUndefined(translationId)) {\n          return translationId;\n        }\n\n        // Check forceLanguage is present\n        if (forceLanguage) {\n          loadTranslationsIfMissing(forceLanguage);\n        }\n\n        // Duck detection: If the first argument is an array, a bunch of translations was requested.\n        // The result is an object.\n        if (angular.isArray(translationId)) {\n          var results = {};\n          for (var i = 0, c = translationId.length; i < c; i++) {\n            results[translationId[i]] = $translate.instant(translationId[i], interpolateParams, interpolationId, forceLanguage);\n          }\n          return results;\n        }\n\n        // We discarded unacceptable values. So we just need to verify if translationId is empty String\n        if (angular.isString(translationId) && translationId.length < 1) {\n          return translationId;\n        }\n\n        // trim off any whitespace\n        if (translationId) {\n          translationId = trim.apply(translationId);\n        }\n\n        var result, possibleLangKeys = [];\n        if ($preferredLanguage) {\n          possibleLangKeys.push($preferredLanguage);\n        }\n        if (uses) {\n          possibleLangKeys.push(uses);\n        }\n        if ($fallbackLanguage && $fallbackLanguage.length) {\n          possibleLangKeys = possibleLangKeys.concat($fallbackLanguage);\n        }\n        for (var j = 0, d = possibleLangKeys.length; j < d; j++) {\n          var possibleLangKey = possibleLangKeys[j];\n          if ($translationTable[possibleLangKey]) {\n            if (typeof $translationTable[possibleLangKey][translationId] !== 'undefined') {\n              result = determineTranslationInstant(translationId, interpolateParams, interpolationId, uses);\n            }\n          }\n          if (typeof result !== 'undefined') {\n            break;\n          }\n        }\n\n        if (!result && result !== '') {\n          if ($notFoundIndicatorLeft || $notFoundIndicatorRight) {\n            result = applyNotFoundIndicators(translationId);\n          } else {\n            // Return translation of default interpolator if not found anything.\n            result = defaultInterpolator.interpolate(translationId, interpolateParams);\n            if ($missingTranslationHandlerFactory && !pendingLoader) {\n              result = translateByHandler(translationId, interpolateParams);\n            }\n          }\n        }\n\n        return result;\n      };\n\n      /**\n       * @ngdoc function\n       * @name pascalprecht.translate.$translate#versionInfo\n       * @methodOf pascalprecht.translate.$translate\n       *\n       * @description\n       * Returns the current version information for the angular-translate library\n       *\n       * @return {string} angular-translate version\n       */\n      $translate.versionInfo = function () {\n        return version;\n      };\n\n      /**\n       * @ngdoc function\n       * @name pascalprecht.translate.$translate#loaderCache\n       * @methodOf pascalprecht.translate.$translate\n       *\n       * @description\n       * Returns the defined loaderCache.\n       *\n       * @return {boolean|string|object} current value of loaderCache\n       */\n      $translate.loaderCache = function () {\n        return loaderCache;\n      };\n\n      // internal purpose only\n      $translate.directivePriority = function () {\n        return directivePriority;\n      };\n\n      // internal purpose only\n      $translate.statefulFilter = function () {\n        return statefulFilter;\n      };\n\n      /**\n       * @ngdoc function\n       * @name pascalprecht.translate.$translate#isReady\n       * @methodOf pascalprecht.translate.$translate\n       *\n       * @description\n       * Returns whether the service is \"ready\" to translate (i.e. loading 1st language).\n       *\n       * See also {@link pascalprecht.translate.$translate#methods_onReady onReady()}.\n       *\n       * @return {boolean} current value of ready\n       */\n      $translate.isReady = function () {\n        return $isReady;\n      };\n\n      var $onReadyDeferred = $q.defer();\n      $onReadyDeferred.promise.then(function () {\n        $isReady = true;\n      });\n\n      /**\n       * @ngdoc function\n       * @name pascalprecht.translate.$translate#onReady\n       * @methodOf pascalprecht.translate.$translate\n       *\n       * @description\n       * Returns whether the service is \"ready\" to translate (i.e. loading 1st language).\n       *\n       * See also {@link pascalprecht.translate.$translate#methods_isReady isReady()}.\n       *\n       * @param {Function=} fn Function to invoke when service is ready\n       * @return {object} Promise resolved when service is ready\n       */\n      $translate.onReady = function (fn) {\n        var deferred = $q.defer();\n        if (angular.isFunction(fn)) {\n          deferred.promise.then(fn);\n        }\n        if ($isReady) {\n          deferred.resolve();\n        } else {\n          $onReadyDeferred.promise.then(deferred.resolve);\n        }\n        return deferred.promise;\n      };\n\n      /**\n       * @ngdoc function\n       * @name pascalprecht.translate.$translate#getAvailableLanguageKeys\n       * @methodOf pascalprecht.translate.$translate\n       *\n       * @description\n       * This function simply returns the registered language keys being defined before in the config phase\n       * With this, an application can use the array to provide a language selection dropdown or similar\n       * without any additional effort\n       *\n       * @returns {object} returns the list of possibly registered language keys and mapping or null if not defined\n       */\n      $translate.getAvailableLanguageKeys = function () {\n        if ($availableLanguageKeys.length > 0) {\n          return $availableLanguageKeys;\n        }\n        return null;\n      };\n\n      // Whenever $translateReady is being fired, this will ensure the state of $isReady\n      var globalOnReadyListener = $rootScope.$on('$translateReady', function () {\n        $onReadyDeferred.resolve();\n        globalOnReadyListener(); // one time only\n        globalOnReadyListener = null;\n      });\n      var globalOnChangeListener = $rootScope.$on('$translateChangeEnd', function () {\n        $onReadyDeferred.resolve();\n        globalOnChangeListener(); // one time only\n        globalOnChangeListener = null;\n      });\n\n      if ($loaderFactory) {\n\n        // If at least one async loader is defined and there are no\n        // (default) translations available we should try to load them.\n        if (angular.equals($translationTable, {})) {\n          if ($translate.use()) {\n            $translate.use($translate.use());\n          }\n        }\n\n        // Also, if there are any fallback language registered, we start\n        // loading them asynchronously as soon as we can.\n        if ($fallbackLanguage && $fallbackLanguage.length) {\n          var processAsyncResult = function (translation) {\n            translations(translation.key, translation.table);\n            $rootScope.$emit('$translateChangeEnd', { language: translation.key });\n            return translation;\n          };\n          for (var i = 0, len = $fallbackLanguage.length; i < len; i++) {\n            var fallbackLanguageId = $fallbackLanguage[i];\n            if ($forceAsyncReloadEnabled || !$translationTable[fallbackLanguageId]) {\n              langPromises[fallbackLanguageId] = loadAsync(fallbackLanguageId).then(processAsyncResult);\n            }\n          }\n        }\n      } else {\n        $rootScope.$emit('$translateReady', { language: $translate.use() });\n      }\n\n      return $translate;\n    }\n  ];\n}\n\n$translate.displayName = 'displayName';\n\n/**\n * @ngdoc object\n * @name pascalprecht.translate.$translateDefaultInterpolation\n * @requires $interpolate\n *\n * @description\n * Uses angular's `$interpolate` services to interpolate strings against some values.\n *\n * Be aware to configure a proper sanitization strategy.\n *\n * See also:\n * * {@link pascalprecht.translate.$translateSanitization}\n *\n * @return {object} $translateDefaultInterpolation Interpolator service\n */\nangular.module('pascalprecht.translate').factory('$translateDefaultInterpolation', $translateDefaultInterpolation);\n\nfunction $translateDefaultInterpolation ($interpolate, $translateSanitization) {\n\n  'use strict';\n\n  var $translateInterpolator = {},\n      $locale,\n      $identifier = 'default';\n\n  /**\n   * @ngdoc function\n   * @name pascalprecht.translate.$translateDefaultInterpolation#setLocale\n   * @methodOf pascalprecht.translate.$translateDefaultInterpolation\n   *\n   * @description\n   * Sets current locale (this is currently not use in this interpolation).\n   *\n   * @param {string} locale Language key or locale.\n   */\n  $translateInterpolator.setLocale = function (locale) {\n    $locale = locale;\n  };\n\n  /**\n   * @ngdoc function\n   * @name pascalprecht.translate.$translateDefaultInterpolation#getInterpolationIdentifier\n   * @methodOf pascalprecht.translate.$translateDefaultInterpolation\n   *\n   * @description\n   * Returns an identifier for this interpolation service.\n   *\n   * @returns {string} $identifier\n   */\n  $translateInterpolator.getInterpolationIdentifier = function () {\n    return $identifier;\n  };\n\n  /**\n   * @deprecated will be removed in 3.0\n   * @see {@link pascalprecht.translate.$translateSanitization}\n   */\n  $translateInterpolator.useSanitizeValueStrategy = function (value) {\n    $translateSanitization.useStrategy(value);\n    return this;\n  };\n\n  /**\n   * @ngdoc function\n   * @name pascalprecht.translate.$translateDefaultInterpolation#interpolate\n   * @methodOf pascalprecht.translate.$translateDefaultInterpolation\n   *\n   * @description\n   * Interpolates given value agains given interpolate params using angulars\n   * `$interpolate` service.\n   *\n   * Since AngularJS 1.5, `value` must not be a string but can be anything input.\n   *\n   * @returns {string} interpolated string.\n   */\n  $translateInterpolator.interpolate = function (value, interpolationParams) {\n    interpolationParams = interpolationParams || {};\n    interpolationParams = $translateSanitization.sanitize(interpolationParams, 'params');\n\n    var interpolatedText;\n    if (angular.isNumber(value)) {\n      // numbers are safe\n      interpolatedText = '' + value;\n    } else if (angular.isString(value)) {\n      // strings must be interpolated (that's the job here)\n      interpolatedText = $interpolate(value)(interpolationParams);\n      interpolatedText = $translateSanitization.sanitize(interpolatedText, 'text');\n    } else {\n      // neither a number or a string, cant interpolate => empty string\n      interpolatedText = '';\n    }\n\n    return interpolatedText;\n  };\n\n  return $translateInterpolator;\n}\n\n$translateDefaultInterpolation.displayName = '$translateDefaultInterpolation';\n\nangular.module('pascalprecht.translate').constant('$STORAGE_KEY', 'NG_TRANSLATE_LANG_KEY');\n\nangular.module('pascalprecht.translate')\n/**\n * @ngdoc directive\n * @name pascalprecht.translate.directive:translate\n * @requires $compile\n * @requires $filter\n * @requires $interpolate\n * @restrict AE\n *\n * @description\n * Translates given translation id either through attribute or DOM content.\n * Internally it uses `translate` filter to translate translation id. It possible to\n * pass an optional `translate-values` object literal as string into translation id.\n *\n * @param {string=} translate Translation id which could be either string or interpolated string.\n * @param {string=} translate-values Values to pass into translation id. Can be passed as object literal string or interpolated object.\n * @param {string=} translate-attr-ATTR translate Translation id and put it into ATTR attribute.\n * @param {string=} translate-default will be used unless translation was successful\n * @param {boolean=} translate-compile (default true if present) defines locally activation of {@link pascalprecht.translate.$translateProvider#methods_usePostCompiling}\n * @param {boolean=} translate-keep-content (default true if present) defines that in case a KEY could not be translated, that the existing content is left in the innerHTML}\n *\n * @example\n   <example module=\"ngView\">\n    <file name=\"index.html\">\n      <div ng-controller=\"TranslateCtrl\">\n\n        <pre translate=\"TRANSLATION_ID\"></pre>\n        <pre translate>TRANSLATION_ID</pre>\n        <pre translate translate-attr-title=\"TRANSLATION_ID\"></pre>\n        <pre translate=\"{{translationId}}\"></pre>\n        <pre translate>{{translationId}}</pre>\n        <pre translate=\"WITH_VALUES\" translate-values=\"{value: 5}\"></pre>\n        <pre translate translate-values=\"{value: 5}\">WITH_VALUES</pre>\n        <pre translate=\"WITH_VALUES\" translate-values=\"{{values}}\"></pre>\n        <pre translate translate-values=\"{{values}}\">WITH_VALUES</pre>\n        <pre translate translate-attr-title=\"WITH_VALUES\" translate-values=\"{{values}}\"></pre>\n        <pre translate=\"WITH_CAMEL_CASE_KEY\" translate-value-camel-case-key=\"Hi\"></pre>\n\n      </div>\n    </file>\n    <file name=\"script.js\">\n      angular.module('ngView', ['pascalprecht.translate'])\n\n      .config(function ($translateProvider) {\n\n        $translateProvider.translations('en',{\n          'TRANSLATION_ID': 'Hello there!',\n          'WITH_VALUES': 'The following value is dynamic: {{value}}',\n          'WITH_CAMEL_CASE_KEY': 'The interpolation key is camel cased: {{camelCaseKey}}'\n        }).preferredLanguage('en');\n\n      });\n\n      angular.module('ngView').controller('TranslateCtrl', function ($scope) {\n        $scope.translationId = 'TRANSLATION_ID';\n\n        $scope.values = {\n          value: 78\n        };\n      });\n    </file>\n    <file name=\"scenario.js\">\n      it('should translate', function () {\n        inject(function ($rootScope, $compile) {\n          $rootScope.translationId = 'TRANSLATION_ID';\n\n          element = $compile('<p translate=\"TRANSLATION_ID\"></p>')($rootScope);\n          $rootScope.$digest();\n          expect(element.text()).toBe('Hello there!');\n\n          element = $compile('<p translate=\"{{translationId}}\"></p>')($rootScope);\n          $rootScope.$digest();\n          expect(element.text()).toBe('Hello there!');\n\n          element = $compile('<p translate>TRANSLATION_ID</p>')($rootScope);\n          $rootScope.$digest();\n          expect(element.text()).toBe('Hello there!');\n\n          element = $compile('<p translate>{{translationId}}</p>')($rootScope);\n          $rootScope.$digest();\n          expect(element.text()).toBe('Hello there!');\n\n          element = $compile('<p translate translate-attr-title=\"TRANSLATION_ID\"></p>')($rootScope);\n          $rootScope.$digest();\n          expect(element.attr('title')).toBe('Hello there!');\n\n          element = $compile('<p translate=\"WITH_CAMEL_CASE_KEY\" translate-value-camel-case-key=\"Hello\"></p>')($rootScope);\n          $rootScope.$digest();\n          expect(element.text()).toBe('The interpolation key is camel cased: Hello');\n        });\n      });\n    </file>\n   </example>\n */\n.directive('translate', translateDirective);\nfunction translateDirective($translate, $q, $interpolate, $compile, $parse, $rootScope) {\n\n  'use strict';\n\n  /**\n   * @name trim\n   * @private\n   *\n   * @description\n   * trim polyfill\n   *\n   * @returns {string} The string stripped of whitespace from both ends\n   */\n  var trim = function() {\n    return this.toString().replace(/^\\s+|\\s+$/g, '');\n  };\n\n  return {\n    restrict: 'AE',\n    scope: true,\n    priority: $translate.directivePriority(),\n    compile: function (tElement, tAttr) {\n\n      var translateValuesExist = (tAttr.translateValues) ?\n        tAttr.translateValues : undefined;\n\n      var translateInterpolation = (tAttr.translateInterpolation) ?\n        tAttr.translateInterpolation : undefined;\n\n      var translateValueExist = tElement[0].outerHTML.match(/translate-value-+/i);\n\n      var interpolateRegExp = '^(.*)(' + $interpolate.startSymbol() + '.*' + $interpolate.endSymbol() + ')(.*)',\n          watcherRegExp = '^(.*)' + $interpolate.startSymbol() + '(.*)' + $interpolate.endSymbol() + '(.*)';\n\n      return function linkFn(scope, iElement, iAttr) {\n\n        scope.interpolateParams = {};\n        scope.preText = '';\n        scope.postText = '';\n        scope.translateNamespace = getTranslateNamespace(scope);\n        var translationIds = {};\n\n        var initInterpolationParams = function (interpolateParams, iAttr, tAttr) {\n          // initial setup\n          if (iAttr.translateValues) {\n            angular.extend(interpolateParams, $parse(iAttr.translateValues)(scope.$parent));\n          }\n          // initially fetch all attributes if existing and fill the params\n          if (translateValueExist) {\n            for (var attr in tAttr) {\n              if (Object.prototype.hasOwnProperty.call(iAttr, attr) && attr.substr(0, 14) === 'translateValue' && attr !== 'translateValues') {\n                var attributeName = angular.lowercase(attr.substr(14, 1)) + attr.substr(15);\n                interpolateParams[attributeName] = tAttr[attr];\n              }\n            }\n          }\n        };\n\n        // Ensures any change of the attribute \"translate\" containing the id will\n        // be re-stored to the scope's \"translationId\".\n        // If the attribute has no content, the element's text value (white spaces trimmed off) will be used.\n        var observeElementTranslation = function (translationId) {\n\n          // Remove any old watcher\n          if (angular.isFunction(observeElementTranslation._unwatchOld)) {\n            observeElementTranslation._unwatchOld();\n            observeElementTranslation._unwatchOld = undefined;\n          }\n\n          if (angular.equals(translationId , '') || !angular.isDefined(translationId)) {\n            var iElementText = trim.apply(iElement.text());\n\n            // Resolve translation id by inner html if required\n            var interpolateMatches = iElementText.match(interpolateRegExp);\n            // Interpolate translation id if required\n            if (angular.isArray(interpolateMatches)) {\n              scope.preText = interpolateMatches[1];\n              scope.postText = interpolateMatches[3];\n              translationIds.translate = $interpolate(interpolateMatches[2])(scope.$parent);\n              var watcherMatches = iElementText.match(watcherRegExp);\n              if (angular.isArray(watcherMatches) && watcherMatches[2] && watcherMatches[2].length) {\n                observeElementTranslation._unwatchOld = scope.$watch(watcherMatches[2], function (newValue) {\n                  translationIds.translate = newValue;\n                  updateTranslations();\n                });\n              }\n            } else {\n              // do not assigne the translation id if it is empty.\n              translationIds.translate = !iElementText ? undefined : iElementText;\n            }\n          } else {\n            translationIds.translate = translationId;\n          }\n          updateTranslations();\n        };\n\n        var observeAttributeTranslation = function (translateAttr) {\n          iAttr.$observe(translateAttr, function (translationId) {\n            translationIds[translateAttr] = translationId;\n            updateTranslations();\n          });\n        };\n\n        // initial setup with values\n        initInterpolationParams(scope.interpolateParams, iAttr, tAttr);\n\n        var firstAttributeChangedEvent = true;\n        iAttr.$observe('translate', function (translationId) {\n          if (typeof translationId === 'undefined') {\n            // case of element \"<translate>xyz</translate>\"\n            observeElementTranslation('');\n          } else {\n            // case of regular attribute\n            if (translationId !== '' || !firstAttributeChangedEvent) {\n              translationIds.translate = translationId;\n              updateTranslations();\n            }\n          }\n          firstAttributeChangedEvent = false;\n        });\n\n        for (var translateAttr in iAttr) {\n          if (iAttr.hasOwnProperty(translateAttr) && translateAttr.substr(0, 13) === 'translateAttr') {\n            observeAttributeTranslation(translateAttr);\n          }\n        }\n\n        iAttr.$observe('translateDefault', function (value) {\n          scope.defaultText = value;\n          updateTranslations();\n        });\n\n        if (translateValuesExist) {\n          iAttr.$observe('translateValues', function (interpolateParams) {\n            if (interpolateParams) {\n              scope.$parent.$watch(function () {\n                angular.extend(scope.interpolateParams, $parse(interpolateParams)(scope.$parent));\n              });\n            }\n          });\n        }\n\n        if (translateValueExist) {\n          var observeValueAttribute = function (attrName) {\n            iAttr.$observe(attrName, function (value) {\n              var attributeName = angular.lowercase(attrName.substr(14, 1)) + attrName.substr(15);\n              scope.interpolateParams[attributeName] = value;\n            });\n          };\n          for (var attr in iAttr) {\n            if (Object.prototype.hasOwnProperty.call(iAttr, attr) && attr.substr(0, 14) === 'translateValue' && attr !== 'translateValues') {\n              observeValueAttribute(attr);\n            }\n          }\n        }\n\n        // Master update function\n        var updateTranslations = function () {\n          for (var key in translationIds) {\n            if (translationIds.hasOwnProperty(key) && translationIds[key] !== undefined) {\n              updateTranslation(key, translationIds[key], scope, scope.interpolateParams, scope.defaultText, scope.translateNamespace);\n            }\n          }\n        };\n\n        // Put translation processing function outside loop\n        var updateTranslation = function(translateAttr, translationId, scope, interpolateParams, defaultTranslationText, translateNamespace) {\n          if (translationId) {\n            // if translation id starts with '.' and translateNamespace given, prepend namespace\n            if (translateNamespace && translationId.charAt(0) === '.') {\n              translationId = translateNamespace + translationId;\n            }\n\n            $translate(translationId, interpolateParams, translateInterpolation, defaultTranslationText, scope.translateLanguage)\n              .then(function (translation) {\n                applyTranslation(translation, scope, true, translateAttr);\n              }, function (translationId) {\n                applyTranslation(translationId, scope, false, translateAttr);\n              });\n          } else {\n            // as an empty string cannot be translated, we can solve this using successful=false\n            applyTranslation(translationId, scope, false, translateAttr);\n          }\n        };\n\n        var applyTranslation = function (value, scope, successful, translateAttr) {\n          if (!successful) {\n            if (typeof scope.defaultText !== 'undefined') {\n              value = scope.defaultText;\n            }\n          }\n          if (translateAttr === 'translate') {\n            // default translate into innerHTML\n            if (successful || (!successful && !$translate.isKeepContent() && typeof iAttr.translateKeepContent === 'undefined')) {\n              iElement.empty().append(scope.preText + value + scope.postText);\n            }\n            var globallyEnabled = $translate.isPostCompilingEnabled();\n            var locallyDefined = typeof tAttr.translateCompile !== 'undefined';\n            var locallyEnabled = locallyDefined && tAttr.translateCompile !== 'false';\n            if ((globallyEnabled && !locallyDefined) || locallyEnabled) {\n              $compile(iElement.contents())(scope);\n            }\n          } else {\n            // translate attribute\n            var attributeName = iAttr.$attr[translateAttr];\n            if (attributeName.substr(0, 5) === 'data-') {\n              // ensure html5 data prefix is stripped\n              attributeName = attributeName.substr(5);\n            }\n            attributeName = attributeName.substr(15);\n            iElement.attr(attributeName, value);\n          }\n        };\n\n        if (translateValuesExist || translateValueExist || iAttr.translateDefault) {\n          scope.$watch('interpolateParams', updateTranslations, true);\n        }\n\n        // Replaced watcher on translateLanguage with event listener\n        var unbindTranslateLanguage = scope.$on('translateLanguageChanged', updateTranslations);\n\n        // Ensures the text will be refreshed after the current language was changed\n        // w/ $translate.use(...)\n        var unbind = $rootScope.$on('$translateChangeSuccess', updateTranslations);\n\n        // ensure translation will be looked up at least one\n        if (iElement.text().length) {\n          if (iAttr.translate) {\n            observeElementTranslation(iAttr.translate);\n          } else {\n            observeElementTranslation('');\n          }\n        } else if (iAttr.translate) {\n          // ensure attribute will be not skipped\n          observeElementTranslation(iAttr.translate);\n        }\n        updateTranslations();\n        scope.$on('$destroy', function(){\n          unbindTranslateLanguage();\n          unbind();\n        });\n      };\n    }\n  };\n}\n\n/**\n * Returns the scope's namespace.\n * @private\n * @param scope\n * @returns {string}\n */\nfunction getTranslateNamespace(scope) {\n  'use strict';\n  if (scope.translateNamespace) {\n    return scope.translateNamespace;\n  }\n  if (scope.$parent) {\n    return getTranslateNamespace(scope.$parent);\n  }\n}\n\ntranslateDirective.displayName = 'translateDirective';\n\nangular.module('pascalprecht.translate')\n/**\n * @ngdoc directive\n * @name pascalprecht.translate.directive:translateCloak\n * @requires $rootScope\n * @requires $translate\n * @restrict A\n *\n * $description\n * Adds a `translate-cloak` class name to the given element where this directive\n * is applied initially and removes it, once a loader has finished loading.\n *\n * This directive can be used to prevent initial flickering when loading translation\n * data asynchronously.\n *\n * The class name is defined in\n * {@link pascalprecht.translate.$translateProvider#cloakClassName $translate.cloakClassName()}.\n *\n * @param {string=} translate-cloak If a translationId is provided, it will be used for showing\n *                                  or hiding the cloak. Basically it relies on the translation\n *                                  resolve.\n */\n.directive('translateCloak', translateCloakDirective);\n\nfunction translateCloakDirective($translate, $rootScope) {\n\n  'use strict';\n\n  return {\n    compile: function (tElement) {\n      var applyCloak = function () {\n        tElement.addClass($translate.cloakClassName());\n      },\n      removeCloak = function () {\n        tElement.removeClass($translate.cloakClassName());\n      };\n      $translate.onReady(function () {\n        removeCloak();\n      });\n      applyCloak();\n\n      return function linkFn(scope, iElement, iAttr) {\n        if (iAttr.translateCloak && iAttr.translateCloak.length) {\n          // Register a watcher for the defined translation allowing a fine tuned cloak\n          iAttr.$observe('translateCloak', function (translationId) {\n            $translate(translationId).then(removeCloak, applyCloak);\n          });\n          // Register for change events as this is being another indicicator revalidating the cloak)\n          $rootScope.$on('$translateChangeSuccess', function () {\n            $translate(iAttr.translateCloak).then(removeCloak, applyCloak);\n          });\n        }\n      };\n    }\n  };\n}\n\ntranslateCloakDirective.displayName = 'translateCloakDirective';\n\nangular.module('pascalprecht.translate')\n/**\n * @ngdoc directive\n * @name pascalprecht.translate.directive:translateNamespace\n * @restrict A\n *\n * @description\n * Translates given translation id either through attribute or DOM content.\n * Internally it uses `translate` filter to translate translation id. It possible to\n * pass an optional `translate-values` object literal as string into translation id.\n *\n * @param {string=} translate namespace name which could be either string or interpolated string.\n *\n * @example\n   <example module=\"ngView\">\n    <file name=\"index.html\">\n      <div translate-namespace=\"CONTENT\">\n\n        <div>\n            <h1 translate>.HEADERS.TITLE</h1>\n            <h1 translate>.HEADERS.WELCOME</h1>\n        </div>\n\n        <div translate-namespace=\".HEADERS\">\n            <h1 translate>.TITLE</h1>\n            <h1 translate>.WELCOME</h1>\n        </div>\n\n      </div>\n    </file>\n    <file name=\"script.js\">\n      angular.module('ngView', ['pascalprecht.translate'])\n\n      .config(function ($translateProvider) {\n\n        $translateProvider.translations('en',{\n          'TRANSLATION_ID': 'Hello there!',\n          'CONTENT': {\n            'HEADERS': {\n                TITLE: 'Title'\n            }\n          },\n          'CONTENT.HEADERS.WELCOME': 'Welcome'\n        }).preferredLanguage('en');\n\n      });\n\n    </file>\n   </example>\n */\n.directive('translateNamespace', translateNamespaceDirective);\n\nfunction translateNamespaceDirective() {\n\n  'use strict';\n\n  return {\n    restrict: 'A',\n    scope: true,\n    compile: function () {\n      return {\n        pre: function (scope, iElement, iAttrs) {\n          scope.translateNamespace = getTranslateNamespace(scope);\n\n          if (scope.translateNamespace && iAttrs.translateNamespace.charAt(0) === '.') {\n            scope.translateNamespace += iAttrs.translateNamespace;\n          } else {\n            scope.translateNamespace = iAttrs.translateNamespace;\n          }\n        }\n      };\n    }\n  };\n}\n\n/**\n * Returns the scope's namespace.\n * @private\n * @param scope\n * @returns {string}\n */\nfunction getTranslateNamespace(scope) {\n  'use strict';\n  if (scope.translateNamespace) {\n    return scope.translateNamespace;\n  }\n  if (scope.$parent) {\n    return getTranslateNamespace(scope.$parent);\n  }\n}\n\ntranslateNamespaceDirective.displayName = 'translateNamespaceDirective';\n\nangular.module('pascalprecht.translate')\n/**\n * @ngdoc directive\n * @name pascalprecht.translate.directive:translateLanguage\n * @restrict A\n *\n * @description\n * Forces the language to the directives in the underlying scope.\n *\n * @param {string=} translate language that will be negotiated.\n *\n * @example\n   <example module=\"ngView\">\n    <file name=\"index.html\">\n      <div>\n\n        <div>\n            <h1 translate>HELLO</h1>\n        </div>\n\n        <div translate-language=\"de\">\n            <h1 translate>HELLO</h1>\n        </div>\n\n      </div>\n    </file>\n    <file name=\"script.js\">\n      angular.module('ngView', ['pascalprecht.translate'])\n\n      .config(function ($translateProvider) {\n\n        $translateProvider\n          .translations('en',{\n            'HELLO': 'Hello world!'\n          })\n          .translations('de',{\n            'HELLO': 'Hallo Welt!'\n          })\n          .preferredLanguage('en');\n\n      });\n\n    </file>\n   </example>\n */\n.directive('translateLanguage', translateLanguageDirective);\n\nfunction translateLanguageDirective() {\n\n  'use strict';\n\n  return {\n    restrict: 'A',\n    scope: true,\n    compile: function () {\n      return function linkFn(scope, iElement, iAttrs) {\n\n        iAttrs.$observe('translateLanguage', function (newTranslateLanguage) {\n          scope.translateLanguage = newTranslateLanguage;\n        });\n\n        scope.$watch('translateLanguage', function(){\n          scope.$broadcast('translateLanguageChanged');\n        });\n      };\n    }\n  };\n}\n\ntranslateLanguageDirective.displayName = 'translateLanguageDirective';\n\nangular.module('pascalprecht.translate')\n/**\n * @ngdoc filter\n * @name pascalprecht.translate.filter:translate\n * @requires $parse\n * @requires pascalprecht.translate.$translate\n * @function\n *\n * @description\n * Uses `$translate` service to translate contents. Accepts interpolate parameters\n * to pass dynamized values though translation.\n *\n * @param {string} translationId A translation id to be translated.\n * @param {*=} interpolateParams Optional object literal (as hash or string) to pass values into translation.\n *\n * @returns {string} Translated text.\n *\n * @example\n   <example module=\"ngView\">\n    <file name=\"index.html\">\n      <div ng-controller=\"TranslateCtrl\">\n\n        <pre>{{ 'TRANSLATION_ID' | translate }}</pre>\n        <pre>{{ translationId | translate }}</pre>\n        <pre>{{ 'WITH_VALUES' | translate:'{value: 5}' }}</pre>\n        <pre>{{ 'WITH_VALUES' | translate:values }}</pre>\n\n      </div>\n    </file>\n    <file name=\"script.js\">\n      angular.module('ngView', ['pascalprecht.translate'])\n\n      .config(function ($translateProvider) {\n\n        $translateProvider.translations('en', {\n          'TRANSLATION_ID': 'Hello there!',\n          'WITH_VALUES': 'The following value is dynamic: {{value}}'\n        });\n        $translateProvider.preferredLanguage('en');\n\n      });\n\n      angular.module('ngView').controller('TranslateCtrl', function ($scope) {\n        $scope.translationId = 'TRANSLATION_ID';\n\n        $scope.values = {\n          value: 78\n        };\n      });\n    </file>\n   </example>\n */\n.filter('translate', translateFilterFactory);\n\nfunction translateFilterFactory($parse, $translate) {\n\n  'use strict';\n\n  var translateFilter = function (translationId, interpolateParams, interpolation, forceLanguage) {\n    if (!angular.isObject(interpolateParams)) {\n      interpolateParams = $parse(interpolateParams)(this);\n    }\n\n    return $translate.instant(translationId, interpolateParams, interpolation, forceLanguage);\n  };\n\n  if ($translate.statefulFilter()) {\n    translateFilter.$stateful = true;\n  }\n\n  return translateFilter;\n}\n\ntranslateFilterFactory.displayName = 'translateFilterFactory';\n\nangular.module('pascalprecht.translate')\n\n/**\n * @ngdoc object\n * @name pascalprecht.translate.$translationCache\n * @requires $cacheFactory\n *\n * @description\n * The first time a translation table is used, it is loaded in the translation cache for quick retrieval. You\n * can load translation tables directly into the cache by consuming the\n * `$translationCache` service directly.\n *\n * @return {object} $cacheFactory object.\n */\n  .factory('$translationCache', $translationCache);\n\nfunction $translationCache($cacheFactory) {\n\n  'use strict';\n\n  return $cacheFactory('translations');\n}\n\n$translationCache.displayName = '$translationCache';\nreturn 'pascalprecht.translate';\n\n}));\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/angular-translate/dist/angular-translate.js\n ** module id = 8\n ** module chunks = 2\n **/","require('./angular-cookies');\nmodule.exports = 'ngCookies';\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/angular-cookies/index.js\n ** module id = 9\n ** module chunks = 2\n **/","/**\n * @license AngularJS v1.5.8\n * (c) 2010-2016 Google, Inc. http://angularjs.org\n * License: MIT\n */\n(function(window, angular) {'use strict';\n\n/**\n * @ngdoc module\n * @name ngCookies\n * @description\n *\n * # ngCookies\n *\n * The `ngCookies` module provides a convenient wrapper for reading and writing browser cookies.\n *\n *\n * <div doc-module-components=\"ngCookies\"></div>\n *\n * See {@link ngCookies.$cookies `$cookies`} for usage.\n */\n\n\nangular.module('ngCookies', ['ng']).\n  /**\n   * @ngdoc provider\n   * @name $cookiesProvider\n   * @description\n   * Use `$cookiesProvider` to change the default behavior of the {@link ngCookies.$cookies $cookies} service.\n   * */\n   provider('$cookies', [function $CookiesProvider() {\n    /**\n     * @ngdoc property\n     * @name $cookiesProvider#defaults\n     * @description\n     *\n     * Object containing default options to pass when setting cookies.\n     *\n     * The object may have following properties:\n     *\n     * - **path** - `{string}` - The cookie will be available only for this path and its\n     *   sub-paths. By default, this is the URL that appears in your `<base>` tag.\n     * - **domain** - `{string}` - The cookie will be available only for this domain and\n     *   its sub-domains. For security reasons the user agent will not accept the cookie\n     *   if the current domain is not a sub-domain of this domain or equal to it.\n     * - **expires** - `{string|Date}` - String of the form \"Wdy, DD Mon YYYY HH:MM:SS GMT\"\n     *   or a Date object indicating the exact date/time this cookie will expire.\n     * - **secure** - `{boolean}` - If `true`, then the cookie will only be available through a\n     *   secured connection.\n     *\n     * Note: By default, the address that appears in your `<base>` tag will be used as the path.\n     * This is important so that cookies will be visible for all routes when html5mode is enabled.\n     *\n     **/\n    var defaults = this.defaults = {};\n\n    function calcOptions(options) {\n      return options ? angular.extend({}, defaults, options) : defaults;\n    }\n\n    /**\n     * @ngdoc service\n     * @name $cookies\n     *\n     * @description\n     * Provides read/write access to browser's cookies.\n     *\n     * <div class=\"alert alert-info\">\n     * Up until Angular 1.3, `$cookies` exposed properties that represented the\n     * current browser cookie values. In version 1.4, this behavior has changed, and\n     * `$cookies` now provides a standard api of getters, setters etc.\n     * </div>\n     *\n     * Requires the {@link ngCookies `ngCookies`} module to be installed.\n     *\n     * @example\n     *\n     * ```js\n     * angular.module('cookiesExample', ['ngCookies'])\n     *   .controller('ExampleController', ['$cookies', function($cookies) {\n     *     // Retrieving a cookie\n     *     var favoriteCookie = $cookies.get('myFavorite');\n     *     // Setting a cookie\n     *     $cookies.put('myFavorite', 'oatmeal');\n     *   }]);\n     * ```\n     */\n    this.$get = ['$$cookieReader', '$$cookieWriter', function($$cookieReader, $$cookieWriter) {\n      return {\n        /**\n         * @ngdoc method\n         * @name $cookies#get\n         *\n         * @description\n         * Returns the value of given cookie key\n         *\n         * @param {string} key Id to use for lookup.\n         * @returns {string} Raw cookie value.\n         */\n        get: function(key) {\n          return $$cookieReader()[key];\n        },\n\n        /**\n         * @ngdoc method\n         * @name $cookies#getObject\n         *\n         * @description\n         * Returns the deserialized value of given cookie key\n         *\n         * @param {string} key Id to use for lookup.\n         * @returns {Object} Deserialized cookie value.\n         */\n        getObject: function(key) {\n          var value = this.get(key);\n          return value ? angular.fromJson(value) : value;\n        },\n\n        /**\n         * @ngdoc method\n         * @name $cookies#getAll\n         *\n         * @description\n         * Returns a key value object with all the cookies\n         *\n         * @returns {Object} All cookies\n         */\n        getAll: function() {\n          return $$cookieReader();\n        },\n\n        /**\n         * @ngdoc method\n         * @name $cookies#put\n         *\n         * @description\n         * Sets a value for given cookie key\n         *\n         * @param {string} key Id for the `value`.\n         * @param {string} value Raw value to be stored.\n         * @param {Object=} options Options object.\n         *    See {@link ngCookies.$cookiesProvider#defaults $cookiesProvider.defaults}\n         */\n        put: function(key, value, options) {\n          $$cookieWriter(key, value, calcOptions(options));\n        },\n\n        /**\n         * @ngdoc method\n         * @name $cookies#putObject\n         *\n         * @description\n         * Serializes and sets a value for given cookie key\n         *\n         * @param {string} key Id for the `value`.\n         * @param {Object} value Value to be stored.\n         * @param {Object=} options Options object.\n         *    See {@link ngCookies.$cookiesProvider#defaults $cookiesProvider.defaults}\n         */\n        putObject: function(key, value, options) {\n          this.put(key, angular.toJson(value), options);\n        },\n\n        /**\n         * @ngdoc method\n         * @name $cookies#remove\n         *\n         * @description\n         * Remove given cookie\n         *\n         * @param {string} key Id of the key-value pair to delete.\n         * @param {Object=} options Options object.\n         *    See {@link ngCookies.$cookiesProvider#defaults $cookiesProvider.defaults}\n         */\n        remove: function(key, options) {\n          $$cookieWriter(key, undefined, calcOptions(options));\n        }\n      };\n    }];\n  }]);\n\nangular.module('ngCookies').\n/**\n * @ngdoc service\n * @name $cookieStore\n * @deprecated\n * @requires $cookies\n *\n * @description\n * Provides a key-value (string-object) storage, that is backed by session cookies.\n * Objects put or retrieved from this storage are automatically serialized or\n * deserialized by angular's toJson/fromJson.\n *\n * Requires the {@link ngCookies `ngCookies`} module to be installed.\n *\n * <div class=\"alert alert-danger\">\n * **Note:** The $cookieStore service is **deprecated**.\n * Please use the {@link ngCookies.$cookies `$cookies`} service instead.\n * </div>\n *\n * @example\n *\n * ```js\n * angular.module('cookieStoreExample', ['ngCookies'])\n *   .controller('ExampleController', ['$cookieStore', function($cookieStore) {\n *     // Put cookie\n *     $cookieStore.put('myFavorite','oatmeal');\n *     // Get cookie\n *     var favoriteCookie = $cookieStore.get('myFavorite');\n *     // Removing a cookie\n *     $cookieStore.remove('myFavorite');\n *   }]);\n * ```\n */\n factory('$cookieStore', ['$cookies', function($cookies) {\n\n    return {\n      /**\n       * @ngdoc method\n       * @name $cookieStore#get\n       *\n       * @description\n       * Returns the value of given cookie key\n       *\n       * @param {string} key Id to use for lookup.\n       * @returns {Object} Deserialized cookie value, undefined if the cookie does not exist.\n       */\n      get: function(key) {\n        return $cookies.getObject(key);\n      },\n\n      /**\n       * @ngdoc method\n       * @name $cookieStore#put\n       *\n       * @description\n       * Sets a value for given cookie key\n       *\n       * @param {string} key Id for the `value`.\n       * @param {Object} value Value to be stored.\n       */\n      put: function(key, value) {\n        $cookies.putObject(key, value);\n      },\n\n      /**\n       * @ngdoc method\n       * @name $cookieStore#remove\n       *\n       * @description\n       * Remove given cookie\n       *\n       * @param {string} key Id of the key-value pair to delete.\n       */\n      remove: function(key) {\n        $cookies.remove(key);\n      }\n    };\n\n  }]);\n\n/**\n * @name $$cookieWriter\n * @requires $document\n *\n * @description\n * This is a private service for writing cookies\n *\n * @param {string} name Cookie name\n * @param {string=} value Cookie value (if undefined, cookie will be deleted)\n * @param {Object=} options Object with options that need to be stored for the cookie.\n */\nfunction $$CookieWriter($document, $log, $browser) {\n  var cookiePath = $browser.baseHref();\n  var rawDocument = $document[0];\n\n  function buildCookieString(name, value, options) {\n    var path, expires;\n    options = options || {};\n    expires = options.expires;\n    path = angular.isDefined(options.path) ? options.path : cookiePath;\n    if (angular.isUndefined(value)) {\n      expires = 'Thu, 01 Jan 1970 00:00:00 GMT';\n      value = '';\n    }\n    if (angular.isString(expires)) {\n      expires = new Date(expires);\n    }\n\n    var str = encodeURIComponent(name) + '=' + encodeURIComponent(value);\n    str += path ? ';path=' + path : '';\n    str += options.domain ? ';domain=' + options.domain : '';\n    str += expires ? ';expires=' + expires.toUTCString() : '';\n    str += options.secure ? ';secure' : '';\n\n    // per http://www.ietf.org/rfc/rfc2109.txt browser must allow at minimum:\n    // - 300 cookies\n    // - 20 cookies per unique domain\n    // - 4096 bytes per cookie\n    var cookieLength = str.length + 1;\n    if (cookieLength > 4096) {\n      $log.warn(\"Cookie '\" + name +\n        \"' possibly not set or overflowed because it was too large (\" +\n        cookieLength + \" > 4096 bytes)!\");\n    }\n\n    return str;\n  }\n\n  return function(name, value, options) {\n    rawDocument.cookie = buildCookieString(name, value, options);\n  };\n}\n\n$$CookieWriter.$inject = ['$document', '$log', '$browser'];\n\nangular.module('ngCookies').provider('$$cookieWriter', function $$CookieWriterProvider() {\n  this.$get = $$CookieWriter;\n});\n\n\n})(window, window.angular);\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/angular-cookies/angular-cookies.js\n ** module id = 10\n ** module chunks = 2\n **/","require('./angular-resource');\nmodule.exports = 'ngResource';\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/angular-resource/index.js\n ** module id = 11\n ** module chunks = 2\n **/","/**\n * @license AngularJS v1.5.8\n * (c) 2010-2016 Google, Inc. http://angularjs.org\n * License: MIT\n */\n(function(window, angular) {'use strict';\n\nvar $resourceMinErr = angular.$$minErr('$resource');\n\n// Helper functions and regex to lookup a dotted path on an object\n// stopping at undefined/null.  The path must be composed of ASCII\n// identifiers (just like $parse)\nvar MEMBER_NAME_REGEX = /^(\\.[a-zA-Z_$@][0-9a-zA-Z_$@]*)+$/;\n\nfunction isValidDottedPath(path) {\n  return (path != null && path !== '' && path !== 'hasOwnProperty' &&\n      MEMBER_NAME_REGEX.test('.' + path));\n}\n\nfunction lookupDottedPath(obj, path) {\n  if (!isValidDottedPath(path)) {\n    throw $resourceMinErr('badmember', 'Dotted member path \"@{0}\" is invalid.', path);\n  }\n  var keys = path.split('.');\n  for (var i = 0, ii = keys.length; i < ii && angular.isDefined(obj); i++) {\n    var key = keys[i];\n    obj = (obj !== null) ? obj[key] : undefined;\n  }\n  return obj;\n}\n\n/**\n * Create a shallow copy of an object and clear other fields from the destination\n */\nfunction shallowClearAndCopy(src, dst) {\n  dst = dst || {};\n\n  angular.forEach(dst, function(value, key) {\n    delete dst[key];\n  });\n\n  for (var key in src) {\n    if (src.hasOwnProperty(key) && !(key.charAt(0) === '$' && key.charAt(1) === '$')) {\n      dst[key] = src[key];\n    }\n  }\n\n  return dst;\n}\n\n/**\n * @ngdoc module\n * @name ngResource\n * @description\n *\n * # ngResource\n *\n * The `ngResource` module provides interaction support with RESTful services\n * via the $resource service.\n *\n *\n * <div doc-module-components=\"ngResource\"></div>\n *\n * See {@link ngResource.$resourceProvider} and {@link ngResource.$resource} for usage.\n */\n\n/**\n * @ngdoc provider\n * @name $resourceProvider\n *\n * @description\n *\n * Use `$resourceProvider` to change the default behavior of the {@link ngResource.$resource}\n * service.\n *\n * ## Dependencies\n * Requires the {@link ngResource } module to be installed.\n *\n */\n\n/**\n * @ngdoc service\n * @name $resource\n * @requires $http\n * @requires ng.$log\n * @requires $q\n * @requires ng.$timeout\n *\n * @description\n * A factory which creates a resource object that lets you interact with\n * [RESTful](http://en.wikipedia.org/wiki/Representational_State_Transfer) server-side data sources.\n *\n * The returned resource object has action methods which provide high-level behaviors without\n * the need to interact with the low level {@link ng.$http $http} service.\n *\n * Requires the {@link ngResource `ngResource`} module to be installed.\n *\n * By default, trailing slashes will be stripped from the calculated URLs,\n * which can pose problems with server backends that do not expect that\n * behavior.  This can be disabled by configuring the `$resourceProvider` like\n * this:\n *\n * ```js\n     app.config(['$resourceProvider', function($resourceProvider) {\n       // Don't strip trailing slashes from calculated URLs\n       $resourceProvider.defaults.stripTrailingSlashes = false;\n     }]);\n * ```\n *\n * @param {string} url A parameterized URL template with parameters prefixed by `:` as in\n *   `/user/:username`. If you are using a URL with a port number (e.g.\n *   `http://example.com:8080/api`), it will be respected.\n *\n *   If you are using a url with a suffix, just add the suffix, like this:\n *   `$resource('http://example.com/resource.json')` or `$resource('http://example.com/:id.json')`\n *   or even `$resource('http://example.com/resource/:resource_id.:format')`\n *   If the parameter before the suffix is empty, :resource_id in this case, then the `/.` will be\n *   collapsed down to a single `.`.  If you need this sequence to appear and not collapse then you\n *   can escape it with `/\\.`.\n *\n * @param {Object=} paramDefaults Default values for `url` parameters. These can be overridden in\n *   `actions` methods. If a parameter value is a function, it will be called every time\n *   a param value needs to be obtained for a request (unless the param was overridden). The function\n *   will be passed the current data value as an argument.\n *\n *   Each key value in the parameter object is first bound to url template if present and then any\n *   excess keys are appended to the url search query after the `?`.\n *\n *   Given a template `/path/:verb` and parameter `{verb:'greet', salutation:'Hello'}` results in\n *   URL `/path/greet?salutation=Hello`.\n *\n *   If the parameter value is prefixed with `@`, then the value for that parameter will be\n *   extracted from the corresponding property on the `data` object (provided when calling a\n *   \"non-GET\" action method).\n *   For example, if the `defaultParam` object is `{someParam: '@someProp'}` then the value of\n *   `someParam` will be `data.someProp`.\n *   Note that the parameter will be ignored, when calling a \"GET\" action method (i.e. an action\n *   method that does not accept a request body)\n *\n * @param {Object.<Object>=} actions Hash with declaration of custom actions that should extend\n *   the default set of resource actions. The declaration should be created in the format of {@link\n *   ng.$http#usage $http.config}:\n *\n *       {action1: {method:?, params:?, isArray:?, headers:?, ...},\n *        action2: {method:?, params:?, isArray:?, headers:?, ...},\n *        ...}\n *\n *   Where:\n *\n *   - **`action`** – {string} – The name of action. This name becomes the name of the method on\n *     your resource object.\n *   - **`method`** – {string} – Case insensitive HTTP method (e.g. `GET`, `POST`, `PUT`,\n *     `DELETE`, `JSONP`, etc).\n *   - **`params`** – {Object=} – Optional set of pre-bound parameters for this action. If any of\n *     the parameter value is a function, it will be called every time when a param value needs to\n *     be obtained for a request (unless the param was overridden). The function will be passed the\n *     current data value as an argument.\n *   - **`url`** – {string} – action specific `url` override. The url templating is supported just\n *     like for the resource-level urls.\n *   - **`isArray`** – {boolean=} – If true then the returned object for this action is an array,\n *     see `returns` section.\n *   - **`transformRequest`** –\n *     `{function(data, headersGetter)|Array.<function(data, headersGetter)>}` –\n *     transform function or an array of such functions. The transform function takes the http\n *     request body and headers and returns its transformed (typically serialized) version.\n *     By default, transformRequest will contain one function that checks if the request data is\n *     an object and serializes to using `angular.toJson`. To prevent this behavior, set\n *     `transformRequest` to an empty array: `transformRequest: []`\n *   - **`transformResponse`** –\n *     `{function(data, headersGetter)|Array.<function(data, headersGetter)>}` –\n *     transform function or an array of such functions. The transform function takes the http\n *     response body and headers and returns its transformed (typically deserialized) version.\n *     By default, transformResponse will contain one function that checks if the response looks\n *     like a JSON string and deserializes it using `angular.fromJson`. To prevent this behavior,\n *     set `transformResponse` to an empty array: `transformResponse: []`\n *   - **`cache`** – `{boolean|Cache}` – If true, a default $http cache will be used to cache the\n *     GET request, otherwise if a cache instance built with\n *     {@link ng.$cacheFactory $cacheFactory}, this cache will be used for\n *     caching.\n *   - **`timeout`** – `{number}` – timeout in milliseconds.<br />\n *     **Note:** In contrast to {@link ng.$http#usage $http.config}, {@link ng.$q promises} are\n *     **not** supported in $resource, because the same value would be used for multiple requests.\n *     If you are looking for a way to cancel requests, you should use the `cancellable` option.\n *   - **`cancellable`** – `{boolean}` – if set to true, the request made by a \"non-instance\" call\n *     will be cancelled (if not already completed) by calling `$cancelRequest()` on the call's\n *     return value. Calling `$cancelRequest()` for a non-cancellable or an already\n *     completed/cancelled request will have no effect.<br />\n *   - **`withCredentials`** - `{boolean}` - whether to set the `withCredentials` flag on the\n *     XHR object. See\n *     [requests with credentials](https://developer.mozilla.org/en/http_access_control#section_5)\n *     for more information.\n *   - **`responseType`** - `{string}` - see\n *     [requestType](https://developer.mozilla.org/en-US/docs/DOM/XMLHttpRequest#responseType).\n *   - **`interceptor`** - `{Object=}` - The interceptor object has two optional methods -\n *     `response` and `responseError`. Both `response` and `responseError` interceptors get called\n *     with `http response` object. See {@link ng.$http $http interceptors}.\n *\n * @param {Object} options Hash with custom settings that should extend the\n *   default `$resourceProvider` behavior.  The supported options are:\n *\n *   - **`stripTrailingSlashes`** – {boolean} – If true then the trailing\n *   slashes from any calculated URL will be stripped. (Defaults to true.)\n *   - **`cancellable`** – {boolean} – If true, the request made by a \"non-instance\" call will be\n *   cancelled (if not already completed) by calling `$cancelRequest()` on the call's return value.\n *   This can be overwritten per action. (Defaults to false.)\n *\n * @returns {Object} A resource \"class\" object with methods for the default set of resource actions\n *   optionally extended with custom `actions`. The default set contains these actions:\n *   ```js\n *   { 'get':    {method:'GET'},\n *     'save':   {method:'POST'},\n *     'query':  {method:'GET', isArray:true},\n *     'remove': {method:'DELETE'},\n *     'delete': {method:'DELETE'} };\n *   ```\n *\n *   Calling these methods invoke an {@link ng.$http} with the specified http method,\n *   destination and parameters. When the data is returned from the server then the object is an\n *   instance of the resource class. The actions `save`, `remove` and `delete` are available on it\n *   as  methods with the `$` prefix. This allows you to easily perform CRUD operations (create,\n *   read, update, delete) on server-side data like this:\n *   ```js\n *   var User = $resource('/user/:userId', {userId:'@id'});\n *   var user = User.get({userId:123}, function() {\n *     user.abc = true;\n *     user.$save();\n *   });\n *   ```\n *\n *   It is important to realize that invoking a $resource object method immediately returns an\n *   empty reference (object or array depending on `isArray`). Once the data is returned from the\n *   server the existing reference is populated with the actual data. This is a useful trick since\n *   usually the resource is assigned to a model which is then rendered by the view. Having an empty\n *   object results in no rendering, once the data arrives from the server then the object is\n *   populated with the data and the view automatically re-renders itself showing the new data. This\n *   means that in most cases one never has to write a callback function for the action methods.\n *\n *   The action methods on the class object or instance object can be invoked with the following\n *   parameters:\n *\n *   - HTTP GET \"class\" actions: `Resource.action([parameters], [success], [error])`\n *   - non-GET \"class\" actions: `Resource.action([parameters], postData, [success], [error])`\n *   - non-GET instance actions:  `instance.$action([parameters], [success], [error])`\n *\n *\n *   Success callback is called with (value, responseHeaders) arguments, where the value is\n *   the populated resource instance or collection object. The error callback is called\n *   with (httpResponse) argument.\n *\n *   Class actions return empty instance (with additional properties below).\n *   Instance actions return promise of the action.\n *\n *   The Resource instances and collections have these additional properties:\n *\n *   - `$promise`: the {@link ng.$q promise} of the original server interaction that created this\n *     instance or collection.\n *\n *     On success, the promise is resolved with the same resource instance or collection object,\n *     updated with data from server. This makes it easy to use in\n *     {@link ngRoute.$routeProvider resolve section of $routeProvider.when()} to defer view\n *     rendering until the resource(s) are loaded.\n *\n *     On failure, the promise is rejected with the {@link ng.$http http response} object, without\n *     the `resource` property.\n *\n *     If an interceptor object was provided, the promise will instead be resolved with the value\n *     returned by the interceptor.\n *\n *   - `$resolved`: `true` after first server interaction is completed (either with success or\n *      rejection), `false` before that. Knowing if the Resource has been resolved is useful in\n *      data-binding.\n *\n *   The Resource instances and collections have these additional methods:\n *\n *   - `$cancelRequest`: If there is a cancellable, pending request related to the instance or\n *      collection, calling this method will abort the request.\n *\n *   The Resource instances have these additional methods:\n *\n *   - `toJSON`: It returns a simple object without any of the extra properties added as part of\n *     the Resource API. This object can be serialized through {@link angular.toJson} safely\n *     without attaching Angular-specific fields. Notice that `JSON.stringify` (and\n *     `angular.toJson`) automatically use this method when serializing a Resource instance\n *     (see [MDN](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/JSON/stringify#toJSON()_behavior)).\n *\n * @example\n *\n * # Credit card resource\n *\n * ```js\n     // Define CreditCard class\n     var CreditCard = $resource('/user/:userId/card/:cardId',\n      {userId:123, cardId:'@id'}, {\n       charge: {method:'POST', params:{charge:true}}\n      });\n\n     // We can retrieve a collection from the server\n     var cards = CreditCard.query(function() {\n       // GET: /user/123/card\n       // server returns: [ {id:456, number:'1234', name:'Smith'} ];\n\n       var card = cards[0];\n       // each item is an instance of CreditCard\n       expect(card instanceof CreditCard).toEqual(true);\n       card.name = \"J. Smith\";\n       // non GET methods are mapped onto the instances\n       card.$save();\n       // POST: /user/123/card/456 {id:456, number:'1234', name:'J. Smith'}\n       // server returns: {id:456, number:'1234', name: 'J. Smith'};\n\n       // our custom method is mapped as well.\n       card.$charge({amount:9.99});\n       // POST: /user/123/card/456?amount=9.99&charge=true {id:456, number:'1234', name:'J. Smith'}\n     });\n\n     // we can create an instance as well\n     var newCard = new CreditCard({number:'0123'});\n     newCard.name = \"Mike Smith\";\n     newCard.$save();\n     // POST: /user/123/card {number:'0123', name:'Mike Smith'}\n     // server returns: {id:789, number:'0123', name: 'Mike Smith'};\n     expect(newCard.id).toEqual(789);\n * ```\n *\n * The object returned from this function execution is a resource \"class\" which has \"static\" method\n * for each action in the definition.\n *\n * Calling these methods invoke `$http` on the `url` template with the given `method`, `params` and\n * `headers`.\n *\n * @example\n *\n * # User resource\n *\n * When the data is returned from the server then the object is an instance of the resource type and\n * all of the non-GET methods are available with `$` prefix. This allows you to easily support CRUD\n * operations (create, read, update, delete) on server-side data.\n\n   ```js\n     var User = $resource('/user/:userId', {userId:'@id'});\n     User.get({userId:123}, function(user) {\n       user.abc = true;\n       user.$save();\n     });\n   ```\n *\n * It's worth noting that the success callback for `get`, `query` and other methods gets passed\n * in the response that came from the server as well as $http header getter function, so one\n * could rewrite the above example and get access to http headers as:\n *\n   ```js\n     var User = $resource('/user/:userId', {userId:'@id'});\n     User.get({userId:123}, function(user, getResponseHeaders){\n       user.abc = true;\n       user.$save(function(user, putResponseHeaders) {\n         //user => saved user object\n         //putResponseHeaders => $http header getter\n       });\n     });\n   ```\n *\n * You can also access the raw `$http` promise via the `$promise` property on the object returned\n *\n   ```\n     var User = $resource('/user/:userId', {userId:'@id'});\n     User.get({userId:123})\n         .$promise.then(function(user) {\n           $scope.user = user;\n         });\n   ```\n *\n * @example\n *\n * # Creating a custom 'PUT' request\n *\n * In this example we create a custom method on our resource to make a PUT request\n * ```js\n *    var app = angular.module('app', ['ngResource', 'ngRoute']);\n *\n *    // Some APIs expect a PUT request in the format URL/object/ID\n *    // Here we are creating an 'update' method\n *    app.factory('Notes', ['$resource', function($resource) {\n *    return $resource('/notes/:id', null,\n *        {\n *            'update': { method:'PUT' }\n *        });\n *    }]);\n *\n *    // In our controller we get the ID from the URL using ngRoute and $routeParams\n *    // We pass in $routeParams and our Notes factory along with $scope\n *    app.controller('NotesCtrl', ['$scope', '$routeParams', 'Notes',\n                                      function($scope, $routeParams, Notes) {\n *    // First get a note object from the factory\n *    var note = Notes.get({ id:$routeParams.id });\n *    $id = note.id;\n *\n *    // Now call update passing in the ID first then the object you are updating\n *    Notes.update({ id:$id }, note);\n *\n *    // This will PUT /notes/ID with the note object in the request payload\n *    }]);\n * ```\n *\n * @example\n *\n * # Cancelling requests\n *\n * If an action's configuration specifies that it is cancellable, you can cancel the request related\n * to an instance or collection (as long as it is a result of a \"non-instance\" call):\n *\n   ```js\n     // ...defining the `Hotel` resource...\n     var Hotel = $resource('/api/hotel/:id', {id: '@id'}, {\n       // Let's make the `query()` method cancellable\n       query: {method: 'get', isArray: true, cancellable: true}\n     });\n\n     // ...somewhere in the PlanVacationController...\n     ...\n     this.onDestinationChanged = function onDestinationChanged(destination) {\n       // We don't care about any pending request for hotels\n       // in a different destination any more\n       this.availableHotels.$cancelRequest();\n\n       // Let's query for hotels in '<destination>'\n       // (calls: /api/hotel?location=<destination>)\n       this.availableHotels = Hotel.query({location: destination});\n     };\n   ```\n *\n */\nangular.module('ngResource', ['ng']).\n  provider('$resource', function() {\n    var PROTOCOL_AND_DOMAIN_REGEX = /^https?:\\/\\/[^\\/]*/;\n    var provider = this;\n\n    /**\n     * @ngdoc property\n     * @name $resourceProvider#defaults\n     * @description\n     * Object containing default options used when creating `$resource` instances.\n     *\n     * The default values satisfy a wide range of usecases, but you may choose to overwrite any of\n     * them to further customize your instances. The available properties are:\n     *\n     * - **stripTrailingSlashes** – `{boolean}` – If true, then the trailing slashes from any\n     *   calculated URL will be stripped.<br />\n     *   (Defaults to true.)\n     * - **cancellable** – `{boolean}` – If true, the request made by a \"non-instance\" call will be\n     *   cancelled (if not already completed) by calling `$cancelRequest()` on the call's return\n     *   value. For more details, see {@link ngResource.$resource}. This can be overwritten per\n     *   resource class or action.<br />\n     *   (Defaults to false.)\n     * - **actions** - `{Object.<Object>}` - A hash with default actions declarations. Actions are\n     *   high-level methods corresponding to RESTful actions/methods on resources. An action may\n     *   specify what HTTP method to use, what URL to hit, if the return value will be a single\n     *   object or a collection (array) of objects etc. For more details, see\n     *   {@link ngResource.$resource}. The actions can also be enhanced or overwritten per resource\n     *   class.<br />\n     *   The default actions are:\n     *   ```js\n     *   {\n     *     get: {method: 'GET'},\n     *     save: {method: 'POST'},\n     *     query: {method: 'GET', isArray: true},\n     *     remove: {method: 'DELETE'},\n     *     delete: {method: 'DELETE'}\n     *   }\n     *   ```\n     *\n     * #### Example\n     *\n     * For example, you can specify a new `update` action that uses the `PUT` HTTP verb:\n     *\n     * ```js\n     *   angular.\n     *     module('myApp').\n     *     config(['resourceProvider', function ($resourceProvider) {\n     *       $resourceProvider.defaults.actions.update = {\n     *         method: 'PUT'\n     *       };\n     *     });\n     * ```\n     *\n     * Or you can even overwrite the whole `actions` list and specify your own:\n     *\n     * ```js\n     *   angular.\n     *     module('myApp').\n     *     config(['resourceProvider', function ($resourceProvider) {\n     *       $resourceProvider.defaults.actions = {\n     *         create: {method: 'POST'}\n     *         get:    {method: 'GET'},\n     *         getAll: {method: 'GET', isArray:true},\n     *         update: {method: 'PUT'},\n     *         delete: {method: 'DELETE'}\n     *       };\n     *     });\n     * ```\n     *\n     */\n    this.defaults = {\n      // Strip slashes by default\n      stripTrailingSlashes: true,\n\n      // Make non-instance requests cancellable (via `$cancelRequest()`)\n      cancellable: false,\n\n      // Default actions configuration\n      actions: {\n        'get': {method: 'GET'},\n        'save': {method: 'POST'},\n        'query': {method: 'GET', isArray: true},\n        'remove': {method: 'DELETE'},\n        'delete': {method: 'DELETE'}\n      }\n    };\n\n    this.$get = ['$http', '$log', '$q', '$timeout', function($http, $log, $q, $timeout) {\n\n      var noop = angular.noop,\n        forEach = angular.forEach,\n        extend = angular.extend,\n        copy = angular.copy,\n        isFunction = angular.isFunction;\n\n      /**\n       * We need our custom method because encodeURIComponent is too aggressive and doesn't follow\n       * http://www.ietf.org/rfc/rfc3986.txt with regards to the character set\n       * (pchar) allowed in path segments:\n       *    segment       = *pchar\n       *    pchar         = unreserved / pct-encoded / sub-delims / \":\" / \"@\"\n       *    pct-encoded   = \"%\" HEXDIG HEXDIG\n       *    unreserved    = ALPHA / DIGIT / \"-\" / \".\" / \"_\" / \"~\"\n       *    sub-delims    = \"!\" / \"$\" / \"&\" / \"'\" / \"(\" / \")\"\n       *                     / \"*\" / \"+\" / \",\" / \";\" / \"=\"\n       */\n      function encodeUriSegment(val) {\n        return encodeUriQuery(val, true).\n          replace(/%26/gi, '&').\n          replace(/%3D/gi, '=').\n          replace(/%2B/gi, '+');\n      }\n\n\n      /**\n       * This method is intended for encoding *key* or *value* parts of query component. We need a\n       * custom method because encodeURIComponent is too aggressive and encodes stuff that doesn't\n       * have to be encoded per http://tools.ietf.org/html/rfc3986:\n       *    query       = *( pchar / \"/\" / \"?\" )\n       *    pchar         = unreserved / pct-encoded / sub-delims / \":\" / \"@\"\n       *    unreserved    = ALPHA / DIGIT / \"-\" / \".\" / \"_\" / \"~\"\n       *    pct-encoded   = \"%\" HEXDIG HEXDIG\n       *    sub-delims    = \"!\" / \"$\" / \"&\" / \"'\" / \"(\" / \")\"\n       *                     / \"*\" / \"+\" / \",\" / \";\" / \"=\"\n       */\n      function encodeUriQuery(val, pctEncodeSpaces) {\n        return encodeURIComponent(val).\n          replace(/%40/gi, '@').\n          replace(/%3A/gi, ':').\n          replace(/%24/g, '$').\n          replace(/%2C/gi, ',').\n          replace(/%20/g, (pctEncodeSpaces ? '%20' : '+'));\n      }\n\n      function Route(template, defaults) {\n        this.template = template;\n        this.defaults = extend({}, provider.defaults, defaults);\n        this.urlParams = {};\n      }\n\n      Route.prototype = {\n        setUrlParams: function(config, params, actionUrl) {\n          var self = this,\n            url = actionUrl || self.template,\n            val,\n            encodedVal,\n            protocolAndDomain = '';\n\n          var urlParams = self.urlParams = {};\n          forEach(url.split(/\\W/), function(param) {\n            if (param === 'hasOwnProperty') {\n              throw $resourceMinErr('badname', \"hasOwnProperty is not a valid parameter name.\");\n            }\n            if (!(new RegExp(\"^\\\\d+$\").test(param)) && param &&\n              (new RegExp(\"(^|[^\\\\\\\\]):\" + param + \"(\\\\W|$)\").test(url))) {\n              urlParams[param] = {\n                isQueryParamValue: (new RegExp(\"\\\\?.*=:\" + param + \"(?:\\\\W|$)\")).test(url)\n              };\n            }\n          });\n          url = url.replace(/\\\\:/g, ':');\n          url = url.replace(PROTOCOL_AND_DOMAIN_REGEX, function(match) {\n            protocolAndDomain = match;\n            return '';\n          });\n\n          params = params || {};\n          forEach(self.urlParams, function(paramInfo, urlParam) {\n            val = params.hasOwnProperty(urlParam) ? params[urlParam] : self.defaults[urlParam];\n            if (angular.isDefined(val) && val !== null) {\n              if (paramInfo.isQueryParamValue) {\n                encodedVal = encodeUriQuery(val, true);\n              } else {\n                encodedVal = encodeUriSegment(val);\n              }\n              url = url.replace(new RegExp(\":\" + urlParam + \"(\\\\W|$)\", \"g\"), function(match, p1) {\n                return encodedVal + p1;\n              });\n            } else {\n              url = url.replace(new RegExp(\"(\\/?):\" + urlParam + \"(\\\\W|$)\", \"g\"), function(match,\n                  leadingSlashes, tail) {\n                if (tail.charAt(0) == '/') {\n                  return tail;\n                } else {\n                  return leadingSlashes + tail;\n                }\n              });\n            }\n          });\n\n          // strip trailing slashes and set the url (unless this behavior is specifically disabled)\n          if (self.defaults.stripTrailingSlashes) {\n            url = url.replace(/\\/+$/, '') || '/';\n          }\n\n          // then replace collapse `/.` if found in the last URL path segment before the query\n          // E.g. `http://url.com/id./format?q=x` becomes `http://url.com/id.format?q=x`\n          url = url.replace(/\\/\\.(?=\\w+($|\\?))/, '.');\n          // replace escaped `/\\.` with `/.`\n          config.url = protocolAndDomain + url.replace(/\\/\\\\\\./, '/.');\n\n\n          // set params - delegate param encoding to $http\n          forEach(params, function(value, key) {\n            if (!self.urlParams[key]) {\n              config.params = config.params || {};\n              config.params[key] = value;\n            }\n          });\n        }\n      };\n\n\n      function resourceFactory(url, paramDefaults, actions, options) {\n        var route = new Route(url, options);\n\n        actions = extend({}, provider.defaults.actions, actions);\n\n        function extractParams(data, actionParams) {\n          var ids = {};\n          actionParams = extend({}, paramDefaults, actionParams);\n          forEach(actionParams, function(value, key) {\n            if (isFunction(value)) { value = value(data); }\n            ids[key] = value && value.charAt && value.charAt(0) == '@' ?\n              lookupDottedPath(data, value.substr(1)) : value;\n          });\n          return ids;\n        }\n\n        function defaultResponseInterceptor(response) {\n          return response.resource;\n        }\n\n        function Resource(value) {\n          shallowClearAndCopy(value || {}, this);\n        }\n\n        Resource.prototype.toJSON = function() {\n          var data = extend({}, this);\n          delete data.$promise;\n          delete data.$resolved;\n          return data;\n        };\n\n        forEach(actions, function(action, name) {\n          var hasBody = /^(POST|PUT|PATCH)$/i.test(action.method);\n          var numericTimeout = action.timeout;\n          var cancellable = angular.isDefined(action.cancellable) ? action.cancellable :\n              (options && angular.isDefined(options.cancellable)) ? options.cancellable :\n              provider.defaults.cancellable;\n\n          if (numericTimeout && !angular.isNumber(numericTimeout)) {\n            $log.debug('ngResource:\\n' +\n                       '  Only numeric values are allowed as `timeout`.\\n' +\n                       '  Promises are not supported in $resource, because the same value would ' +\n                       'be used for multiple requests. If you are looking for a way to cancel ' +\n                       'requests, you should use the `cancellable` option.');\n            delete action.timeout;\n            numericTimeout = null;\n          }\n\n          Resource[name] = function(a1, a2, a3, a4) {\n            var params = {}, data, success, error;\n\n            /* jshint -W086 */ /* (purposefully fall through case statements) */\n            switch (arguments.length) {\n              case 4:\n                error = a4;\n                success = a3;\n              //fallthrough\n              case 3:\n              case 2:\n                if (isFunction(a2)) {\n                  if (isFunction(a1)) {\n                    success = a1;\n                    error = a2;\n                    break;\n                  }\n\n                  success = a2;\n                  error = a3;\n                  //fallthrough\n                } else {\n                  params = a1;\n                  data = a2;\n                  success = a3;\n                  break;\n                }\n              case 1:\n                if (isFunction(a1)) success = a1;\n                else if (hasBody) data = a1;\n                else params = a1;\n                break;\n              case 0: break;\n              default:\n                throw $resourceMinErr('badargs',\n                  \"Expected up to 4 arguments [params, data, success, error], got {0} arguments\",\n                  arguments.length);\n            }\n            /* jshint +W086 */ /* (purposefully fall through case statements) */\n\n            var isInstanceCall = this instanceof Resource;\n            var value = isInstanceCall ? data : (action.isArray ? [] : new Resource(data));\n            var httpConfig = {};\n            var responseInterceptor = action.interceptor && action.interceptor.response ||\n              defaultResponseInterceptor;\n            var responseErrorInterceptor = action.interceptor && action.interceptor.responseError ||\n              undefined;\n            var timeoutDeferred;\n            var numericTimeoutPromise;\n\n            forEach(action, function(value, key) {\n              switch (key) {\n                default:\n                  httpConfig[key] = copy(value);\n                  break;\n                case 'params':\n                case 'isArray':\n                case 'interceptor':\n                case 'cancellable':\n                  break;\n              }\n            });\n\n            if (!isInstanceCall && cancellable) {\n              timeoutDeferred = $q.defer();\n              httpConfig.timeout = timeoutDeferred.promise;\n\n              if (numericTimeout) {\n                numericTimeoutPromise = $timeout(timeoutDeferred.resolve, numericTimeout);\n              }\n            }\n\n            if (hasBody) httpConfig.data = data;\n            route.setUrlParams(httpConfig,\n              extend({}, extractParams(data, action.params || {}), params),\n              action.url);\n\n            var promise = $http(httpConfig).then(function(response) {\n              var data = response.data;\n\n              if (data) {\n                // Need to convert action.isArray to boolean in case it is undefined\n                // jshint -W018\n                if (angular.isArray(data) !== (!!action.isArray)) {\n                  throw $resourceMinErr('badcfg',\n                      'Error in resource configuration for action `{0}`. Expected response to ' +\n                      'contain an {1} but got an {2} (Request: {3} {4})', name, action.isArray ? 'array' : 'object',\n                    angular.isArray(data) ? 'array' : 'object', httpConfig.method, httpConfig.url);\n                }\n                // jshint +W018\n                if (action.isArray) {\n                  value.length = 0;\n                  forEach(data, function(item) {\n                    if (typeof item === \"object\") {\n                      value.push(new Resource(item));\n                    } else {\n                      // Valid JSON values may be string literals, and these should not be converted\n                      // into objects. These items will not have access to the Resource prototype\n                      // methods, but unfortunately there\n                      value.push(item);\n                    }\n                  });\n                } else {\n                  var promise = value.$promise;     // Save the promise\n                  shallowClearAndCopy(data, value);\n                  value.$promise = promise;         // Restore the promise\n                }\n              }\n              response.resource = value;\n\n              return response;\n            }, function(response) {\n              (error || noop)(response);\n              return $q.reject(response);\n            });\n\n            promise['finally'](function() {\n              value.$resolved = true;\n              if (!isInstanceCall && cancellable) {\n                value.$cancelRequest = angular.noop;\n                $timeout.cancel(numericTimeoutPromise);\n                timeoutDeferred = numericTimeoutPromise = httpConfig.timeout = null;\n              }\n            });\n\n            promise = promise.then(\n              function(response) {\n                var value = responseInterceptor(response);\n                (success || noop)(value, response.headers);\n                return value;\n              },\n              responseErrorInterceptor);\n\n            if (!isInstanceCall) {\n              // we are creating instance / collection\n              // - set the initial promise\n              // - return the instance / collection\n              value.$promise = promise;\n              value.$resolved = false;\n              if (cancellable) value.$cancelRequest = timeoutDeferred.resolve;\n\n              return value;\n            }\n\n            // instance call\n            return promise;\n          };\n\n\n          Resource.prototype['$' + name] = function(params, success, error) {\n            if (isFunction(params)) {\n              error = success; success = params; params = {};\n            }\n            var result = Resource[name].call(this, params, this, success, error);\n            return result.$promise || result;\n          };\n        });\n\n        Resource.bind = function(additionalParamDefaults) {\n          return resourceFactory(url, extend({}, paramDefaults, additionalParamDefaults), actions);\n        };\n\n        return Resource;\n      }\n\n      return resourceFactory;\n    }];\n  });\n\n\n})(window, window.angular);\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/angular-resource/angular-resource.js\n ** module id = 12\n ** module chunks = 2\n **/"],"sourceRoot":""}